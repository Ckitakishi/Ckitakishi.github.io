<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ckitakishi.playground</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ckitakishi.com/"/>
  <updated>2019-02-23T07:40:37.921Z</updated>
  <id>http://ckitakishi.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Memory warning: 大隐隐于市</title>
    <link href="http://ckitakishi.com/2019/02/23/Memory-warning-%E5%A4%A7%E9%9A%90%E9%9A%90%E4%BA%8E%E5%B8%82/"/>
    <id>http://ckitakishi.com/2019/02/23/Memory-warning-大隐隐于市/</id>
    <published>2019-02-23T03:32:21.000Z</published>
    <updated>2019-02-23T07:40:37.921Z</updated>
    
    <content type="html"><![CDATA[<p>对 memory warning (内存警告) 的处理是一个在开发中极其容易被忽略的问题，究其原因，最重要莫过于 warning 并不那么容易发生<del>，开发中尤其如此</del>。即使发生了，在我们分析崩溃日志的时候，也未必能够明察与之是否有关，再进一步说，就算知道了十有八九是 memory warning 导致了崩溃，有时候要准确定位根源仍需耗费一番功夫。</p><h2 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h2><p>由内存原因导致的崩溃类型多不胜数，不过在这里只打算讨论内存不足导致应用被强制终结这一种。比较常见的是下述几种：</p><ul><li>自然消耗，处理媒体资源尤其容易消耗内存。<ul><li>未处理 memory warning</li><li>对 memory warning 的处理不正确</li></ul></li><li>memory leak (内存泄漏)，确切来说 memory leak 不是直接原因，而是一个加速器。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>之所以认识到这个问题的重要性，是因为最近在看崩溃日志的时候，发现有很多个原因近似，但发生场所不太相同的崩溃，不过总体来说发生率只有 0.0X%。因为夹杂着一些 RxSwift 的代码，真正发生崩溃的位置变得很难判断，真实原因更是扑朔迷离。所谓家家有本难念的经，相似的，短短代码都有说不尽的故事，所以就事论事，来说说到底发生了什么。</p><a id="more"></a><p>首先，我们有一个封装了 <code>UICollectionView</code> 的 <code>UIViewController</code>，也就是 <code>BaseCollectionViewController</code>，在其中定义了一个可以“保证”不是 <code>nil</code> 且不为 <code>weak</code> 的 <code>collectionVIew</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseCollectionViewController.swift</span></span><br><span class="line"><span class="keyword">fileprivate</span>(<span class="keyword">set</span>) <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isViewLoaded &amp;&amp; view.window == <span class="literal">nil</span> &amp;&amp; collectionView.isDescendant(of: view) &#123;</span><br><span class="line">        collectionView.removeFromSuperview()</span><br><span class="line">        collectionView.delegate = <span class="literal">nil</span></span><br><span class="line">        collectionView.dataSource = <span class="literal">nil</span></span><br><span class="line">        collectionView = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.loadView()</span><br><span class="line">    <span class="comment">// init collectionView in code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还拥有一个继承自 BaseCollectionViewController 的 XXViewController：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXViewController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXViewController</span>: <span class="title">BaseCollectionViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> isViewLoaded &amp;&amp; view.window == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">reloadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// fetch data from server then reload collection view</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的运用情景是，在 <code>XXViewController`</code> 中存在 pop 一个新 ViewController 的情况，这个时候，XXViewController<code>需要重新获取数据来刷新页面并更新 collectionView 的</code>contentOffset<code>。按道理来说，刷新数据在下一次 view will appear 的时候进行会更保险，但是由于被强烈要求调整</code>contentOffset` 这个过程不可见，所以…这样一来，bug 就“应运而生”了。</p><p>当新 ViewController 位于最顶端的时候，XXViewController 就不再被 window 所持有。由于它继承自 BaseCollectionViewController，<code>didReceiveMemoryWarning</code> 发生时 collectionView 会在不知不觉中被置为 nil，如果这一切发生在 collectionView.reloadData() 之前，那噩梦就诞生了。</p><p>这个时候，或许会反思 controller view 之间的继承关系到底合理么，调整 <code>contentOffset</code> 不可见到底合理么，<code>collectionView = nil</code> 到底有没有意义。我认为这些都是合理的着手点，对于这类问题，找到原因其实就已经解决了 80% 了。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>未雨绸缪这句话在这里非常适用，提前去思考一些问题有助于我们规避 memory warning 带来的麻烦：</p><ul><li>当接收到 memery warning 时我们该做什么？</li><li>view controller  不被 window 持有的时候需要做什么？</li><li>当一个 view controller 被恢复的时候，<code>loadView</code>, <code>viewDidLoad</code> 会默认被调用，但是自定义的 <code>init</code> 方法们就不一定了，这样仍能顺利完成初始化吗？</li><li>是否存在显著的内存泄漏？</li></ul><p>当这些问题都梳理清楚的时候，也就大大减少了后顾之忧。</p><p>除了上面提到过的 <code>didReceiveMemoryWarning</code>，还有一个比较常用的方法： <code>applicationDidReceiveMemoryWarning</code>，后者是 App delegate 的方法，所以我认为可以用来管理一些全局对象，或是缓存之类的。除此之外，还可以在必要的时候监听名为 <code>UIApplicationDidReceiveMemoryWarningNotification</code> 的通知来做一些特殊的处理。</p><h2 id="触发-memory-warning"><a href="#触发-memory-warning" class="headerlink" title="触发 memory warning"></a>触发 memory warning</h2><p>那么，当准备就绪的时候，我们就可以通过触发 memory warning 来进行测试了。</p><ol><li>模拟器 –&gt; Debug –&gt; Simulate Memory Warning (<code>Shift + Command + M</code>): 模拟器调试选项，结合断点模拟 warning</li><li><code>UIApplication.shared.perform(Selector((&quot;_performMemoryWarning&quot;)))</code>: 在代码中指定位置触发 warning</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>内存管理着实不是一个简单的问题，上述内容不过浮于浅表。如果想要稍微再多了解一点，推荐看一看 WWDC 2018 的 <a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">Session 416</a> ，有很多内容刷新了我的既存认知…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 memory warning (内存警告) 的处理是一个在开发中极其容易被忽略的问题，究其原因，最重要莫过于 warning 并不那么容易发生&lt;del&gt;，开发中尤其如此&lt;/del&gt;。即使发生了，在我们分析崩溃日志的时候，也未必能够明察与之是否有关，再进一步说，就算知道了十有八九是 memory warning 导致了崩溃，有时候要准确定位根源仍需耗费一番功夫。&lt;/p&gt;
&lt;h2 id=&quot;常见原因&quot;&gt;&lt;a href=&quot;#常见原因&quot; class=&quot;headerlink&quot; title=&quot;常见原因&quot;&gt;&lt;/a&gt;常见原因&lt;/h2&gt;&lt;p&gt;由内存原因导致的崩溃类型多不胜数，不过在这里只打算讨论内存不足导致应用被强制终结这一种。比较常见的是下述几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自然消耗，处理媒体资源尤其容易消耗内存。&lt;ul&gt;
&lt;li&gt;未处理 memory warning&lt;/li&gt;
&lt;li&gt;对 memory warning 的处理不正确&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;memory leak (内存泄漏)，确切来说 memory leak 不是直接原因，而是一个加速器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h2&gt;&lt;p&gt;之所以认识到这个问题的重要性，是因为最近在看崩溃日志的时候，发现有很多个原因近似，但发生场所不太相同的崩溃，不过总体来说发生率只有 0.0X%。因为夹杂着一些 RxSwift 的代码，真正发生崩溃的位置变得很难判断，真实原因更是扑朔迷离。所谓家家有本难念的经，相似的，短短代码都有说不尽的故事，所以就事论事，来说说到底发生了什么。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于 MetaX 的三言两语</title>
    <link href="http://ckitakishi.com/2018/04/29/%E5%85%B3%E4%BA%8E-MetaX-%E7%9A%84%E4%B8%89%E8%A8%80%E4%B8%A4%E8%AF%AD/"/>
    <id>http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/</id>
    <published>2018-04-29T11:47:04.000Z</published>
    <updated>2018-05-07T15:21:47.183Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Support:</strong></p><p>If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.</p></blockquote><p>Source: <a href="https://github.com/Ckitakishi/MetaX" target="_blank" rel="noopener">MetaX on Github</a></p><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所以就自己动手丰衣足食了。<br>作为一个总结，下文的主题是照片框架 PhotoKit 和简单的问题解决记录。</p><h2 id="关于照片框架-PhotoKit"><a href="#关于照片框架-PhotoKit" class="headerlink" title="关于照片框架 - PhotoKit"></a>关于照片框架 - PhotoKit</h2><p>在 <strong>PhotoKit</strong> 之前，AssetsLibrary 是被广泛使用的，由于并没有实际用过，就不再赘述。从 <strong>PhotoKit</strong> 的文档就可以看出来，这是一个十分庞大的框架，包含了相当多的类。<strong>PhotoKit</strong> 可以使得自己的应用与照片库以相同流程工作，此外性能也相当不错。</p><h3 id="从获取图像开始"><a href="#从获取图像开始" class="headerlink" title="从获取图像开始"></a>从获取图像开始</h3><h4 id="相册取得"><a href="#相册取得" class="headerlink" title="相册取得"></a>相册取得</h4><p>如果以从相册列表选取照片这个流程为例来看，相册列表中的所有对象都是 <code>PHCollection</code>，它是一个抽象父类，拥有两个子类： <code>PHAssetCollection</code> 和 <code>PHCollectionList</code>，前者表示相册，后者表示相册列表也就是文件夹。题外话，在 iOS 设备上创建文件夹几乎可以说是一个隐藏功能，点击追加按钮是相册，而长按则可以选择相册或文件夹。而获取相册的方法是使用上述几个类中的 fetch 方法，返回 <code>PHFetchResult&lt;XXX&gt;</code>，可以用部分与 <code>Foundation</code> 中集合类型相同的接口来处理这个结果，比如用 <code>enumerateObjects(_:)</code> 来进行遍历。该方法默认会取回所有结果，但是可以通过使用 <code>PHFetchOptions</code> 来做一些过滤或是排序处理。例如取回所有智能相册：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = <span class="type">PHFetchOptions</span>()</span><br><span class="line">options.sortDescriptors = [<span class="type">NSSortDescriptor</span>(key: <span class="string">"creationDate"</span>, ascending: <span class="literal">false</span>)]</span><br><span class="line"><span class="keyword">let</span> smartAlbums: <span class="type">PHFetchResult</span>&lt;<span class="type">PHAssetCollection</span>&gt;?</span><br><span class="line">smartAlbums = <span class="type">PHAssetCollection</span>.fetchAssetCollections(with: .smartAlbum, subtype: .albumRegular, options: options)</span><br></pre></td></tr></table></figure><p>智能相册由系统按照图像类型自动生成，所以并不会出现文件夹。然而，如果以系统照片库来说，还有一类相册是用户自定义相册，处理这类相册的时候必须要注意区分文件夹与相册。我选择的处理方法是暴力地用一个递归将文件夹完全平铺展开作为首级相册。</p><p>另外，访问图片库需要请求用户权限，在权限未决定的情况下，第一次调用 fetch 方法的时候会自动请求权限。也可以通过 <code>PHPhotoLibrary</code> 的类方法 <code>requestAuthorization:</code> 显式地发起请求。如果被拒..绝..了，添加一个类似 404 页面的视图并设置一个按钮指向应用的设置页面是 (我认为) 比较优雅的做法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="type">UIApplicationOpenSettingsURLString</span>)</span><br><span class="line"><span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url!, options: [:], completionHandler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h4 id="照片取得"><a href="#照片取得" class="headerlink" title="照片取得"></a>照片取得</h4><p>照片的取得是一个层层递进的过程，在取得了相册之后，便可以尝试获取 <code>PHAsset</code> 对象，小标题说的比较狭隘一些，实际上 <code>PHAsset</code> 对象包含图像，视频，和 Live Photo。此时可以通过调用 <code>fetchAssets(in:options:)</code> 来取得一个类型为 <code>PHFetchResult&lt;PHAsset&gt;</code> 的资源集：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assetCollection = smartAlbums.object(at: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> fetchResult = <span class="type">PHAsset</span>.fetchAssets(<span class="keyword">in</span>: assetCollection, options: options)</span><br></pre></td></tr></table></figure><p>手握 <code>PHAsset</code>，几乎就拥有了一切。此刻 <code>PHImageManager</code> 该出场了，这是一个专门用于请求特定 asset 对应的媒体资源的类。以请求图片为例，其中最重要的一个方法是 <code>requestImage(for:targetSize:contentMode:options:resultHandler:)</code>，通过参数就会发现，请求的同时就可以确定图片的尺寸，并进行裁剪。</p><p>我们还能够为这个请求设定一个类型为 <code>PHImageRequestOptions</code> 的 option，借助它的 <code>isSynchronous</code> 属性可以决定以同步还是异步的方式来发起请求；而 <code>deliverryMode</code> 则是让你们能够在图像的加载时间和质量中做一个权衡或抉择，<code>.highQualityFormat</code> 不论耗时多久都会加载原尺寸图片，<code>.fastFormat</code> 会舍弃质量来快速加载图像，<code>.opportunistic</code> 约等于前两者的和，先 <code>.fastFormat</code> 后 <code>.highQualityFormat</code>，所以会发生两次请求，但是，如果 <code>isSynchronous = true</code>，那么请求一定是 <code>.highQualityFormat</code>；还有 <code>isNetworkAccessAllowed</code>，表示是否允许从 iCloud 下载图片，如果允许，那 <code>progressHandler</code> 也会被同时调用，于是我们可以将进度体现在 UI 上。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = <span class="type">PHImageRequestOptions</span>()</span><br><span class="line">options.deliveryMode = .opportunistic</span><br><span class="line"><span class="comment">// options.isSynchronous = true</span></span><br><span class="line">options.isNetworkAccessAllowed = <span class="literal">true</span></span><br><span class="line">options.progressHandler = &#123;(progress: <span class="type">Double</span>, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imageRequestId = <span class="type">PHImageManager</span>.<span class="keyword">default</span>().requestImage(<span class="keyword">for</span>: asset, targetSize: targetSize, contentMode: .aspectFit, options: options, resultHandler: &#123; image, info <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到这里基本上一张图片的取得就完成了。不过，如果由于一些原因请求失败或者不完整呢？在上述代码中，<code>info</code> 便是一个包含了多条可以帮助我们判断结果的信息的字典。<code>PHImageResultIsInCloudKey</code> 可以知道图像是否需要从 iCloud 下载；<code>PHImageResultIsDegradedKey</code> 意味着当前的图像是否是低质量版本；以及 <code>PHImageErrorKey</code>，顾名思义是表示了错误信息，等等。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>最后值得一提的是图片取得的缓存机制。</p><p>通常，在获取一张具体的图片之前，我们会先获取整个相册的所有图片做成一个列表，比如一个如同系统图片库的 collectionView，为了性能考虑，有时候会需要提前将图片载入内存，而 <code>PHImageManager</code> 有一个子类 <code>PHImageCachingManager</code> 正好可以用来做这件事。</p><p><code>PHImageCachingManager</code> 有两个比较重要的方法，一个是开始缓存：<code>startCachingImages(for:targetSize:contentMode:options:)</code>，另一个是停止缓存，<code>stopCachingImages(for:targetSize:contentMode:options:)</code>，彻底停止缓存时候可以使用 <code>stopCachingImagesForAllAssets()</code>。接受的参数和上面提到了请求图像几乎一样一样，而事实上在取得缓存之后，再次使用 <code>requestImage</code> 取得独立图像的时候，如果参数相同，则会从缓存中获取。</p><p>那究竟是将所有图像资源都放入缓存以供不时之需呢，还是仅仅是缓存一部分呢？是一开始就缓存所有资源呢，还是一边滑动一边缓存呢？时机，范围等等都是非常重要而必须要考虑的问题。推荐参考一下 Apple 的示例代码 — <a href="https://developer.apple.com/library/content/samplecode/UsingPhotosFramework/Introduction/Intro.html" target="_blank" rel="noopener">Using Photos Framework</a>，虽然这个示例 bug 有点点多，但是缓存部分的设计还是很妙的～也因此借鉴了这个部分的实现。它的设计策略在于，载入画面及画面滚动两个时机更新缓存，而区域只包括以可见部分为中心，高度为两倍的部分 (例如：可见范围 [0, 0, 768, 1024] 对应缓存区域：[-512, 0, 768, 2048])，随着画面的滑动，不停调用 <code>startCachingImages</code> 与 <code>stopCachingImages</code>，该区域也会随之改变，就像一个滑动窗口一样。</p><h3 id="修改图像"><a href="#修改图像" class="headerlink" title="修改图像"></a>修改图像</h3><p>按照从上到下的顺序，有关图像的框架依次是：</p><ul><li>UIKit</li><li>CoreImage</li><li>CoreGraphics</li><li>ImageIO</li></ul><p>下面打算讨论两个维度的图片修改，滤镜和 Metadata。接着上一部分的流程继续往下来说，虽然实现滤镜其实又很多方法，但是若选择 <strong>Core Image</strong>，那么不论哪一种，都要先通过 PHAsset 的实例方法 <code>requestContentEditingInput(with:completionHandler:)</code> 来获取完整尺寸的 <code>CIImage</code> 图像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asset.requestContentEditingInput(with: options, completionHandler: &#123; contentEditingInput, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> imageURL = contentEditingInput?.fullSizeImageURL <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> ciImageOfURL = <span class="type">CIImage</span>(contentsOf: imageURL)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> ciImage = ciImageOfURL <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h4><p>在顺利取得 <code>CIImage</code> 之后，添加滤镜的流程大致如下。<strong>Core Image</strong> 提供了一些滤镜，如果需要自定的话，看一看 WWDC2014 Session 515 会非常有帮助。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对过去版本的管理</span></span><br><span class="line"><span class="keyword">let</span> adjustmentData = <span class="type">PHAdjustmentData</span>...</span><br><span class="line">                                                  </span><br><span class="line"><span class="keyword">let</span> contentEditingOutput = <span class="type">PHContentEditingOutput</span>(contentEditingInput: contentEditingInput)</span><br><span class="line">contentEditingOutput.adjustmentData = adjustmentData</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outputImage = ciImage</span><br><span class="line">    .applyingOrientation(input.fullSizeImageOrientation)</span><br><span class="line">    .applyingFilter(<span class="built_in">filter</span>, withInputParameters: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line"><span class="type">CIContext</span>().writeJPEGRepresentation(of: outputImage,</span><br><span class="line">                                    to: contentEditingOutput.renderedContentURL, </span><br><span class="line">                                    colorSpace: ciImage.colorSpace!,</span><br><span class="line">                                    options: [:])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认修改</span></span><br><span class="line"><span class="type">PHPhotoLibrary</span>.shared().performChanges(&#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">PHAssetChangeRequest</span>(<span class="keyword">for</span>: <span class="keyword">self</span>.asset)</span><br><span class="line">    request.contentEditingOutput = contentEditingOutput</span><br><span class="line">&#125;, completionHandler: &#123; success, error <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h4><p>有了 <code>CIImage</code>，读取 Metadata 只需要获取 <code>CIImage</code> 的 <code>properties</code> 属性即可。但是如果要写入，就需要基于相对底层的 <code>ImageIO</code> 框架来完成。</p><p>首先，我创建了临时存储，，虽然最初的想法是直接覆盖当前编辑中的图像，这个方案在模拟器竟然成功了，但是真实设备行不通。后来迫不得已选择了迂回的方法，覆盖 =&gt; 追加新图像 + (可选)删除旧图像。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = <span class="type">CIContext</span>(options:<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个临时存储</span></span><br><span class="line"><span class="keyword">var</span> tmpUrl = <span class="type">NSURL</span>.fileURL(withPath: <span class="type">NSTemporaryDirectory</span>() + imageURL.lastPathComponent)</span><br></pre></td></tr></table></figure><p>为了让新创建的图像保持与原始图像相同的类型，通过 <code>CGImageSource</code> 来获取。如果获取成功，就可以指定上面的临时 URL 作为位置，尝试创建 <code>CGImageDestination</code>，之所以说是尝试，是因为不得不考虑如果当前设备并不支持期待创建的类型，那么我们就会得到 <code>nil</code>。这个时候别无选择，只能够再试一次，在当前版本中，这个做法主要是为了解决 <strong>HEIF</strong> 格式在一些较有历史的设备上并不被支持而带来的问题，所以在失败的情况下，默认将目标类型设定为 <strong>JPEG</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 CIImage 创建 CGImage</span></span><br><span class="line"><span class="keyword">let</span> cgImage = context.createCGImage(ciImage, from: ciImage.extent)</span><br><span class="line"><span class="comment">// 根据 CGImageSource 来获取图片类型标识 (UTI)</span></span><br><span class="line"><span class="keyword">let</span> cgImageSource = <span class="type">CGImageSourceCreateWithURL</span>(imageURL <span class="keyword">as</span> <span class="type">CFURL</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> sourceType = <span class="type">CGImageSourceGetType</span>(cgImageSource!) <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试创建 CGImageDestination</span></span><br><span class="line"><span class="keyword">var</span> createdDestination: <span class="type">CGImageDestination?</span> = <span class="type">CGImageDestinationCreateWithURL</span>(tmpUrl <span class="keyword">as</span> <span class="type">CFURL</span>, sourceType</span><br><span class="line">    , <span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该版本暂定方案：无法创建的图像格式就存储为 JPEG</span></span><br><span class="line"><span class="keyword">if</span> createdDestination == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// media type is unsupported: delete temp file, create new one with extension [.JPG].</span></span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">try</span>? <span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: tmpUrl)</span><br><span class="line">    tmpUrl = <span class="type">NSURL</span>.fileURL(withPath: <span class="type">NSTemporaryDirectory</span>() + imageURL.deletingPathExtension().lastPathComponent + <span class="string">".JPG"</span>)</span><br><span class="line">    createdDestination = <span class="type">CGImageDestinationCreateWithURL</span>(tmpUrl <span class="keyword">as</span> <span class="type">CFURL</span>, <span class="string">"public.jpeg"</span> <span class="keyword">as</span> <span class="type">CFString</span></span><br><span class="line">        , <span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> destination = createdDestination <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若完成了 <code>CGImageDestination</code> 创建，就可以开始向这个目标添加图像了。在上一段代码中，创建时传入的第 3 个参数正是代表着图像的数量，因为只是单张图像，所以是自然是 1；该方法也可以用来创建 GIF。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 CGImageDestination 添加图像，以及该图像的 metadata。</span></span><br><span class="line"><span class="type">CGImageDestinationAddImage</span>(destination, cgImage!, newProps <span class="keyword">as</span> <span class="type">CFDictionary</span>)</span><br><span class="line"><span class="keyword">if</span> !<span class="type">CGImageDestinationFinalize</span>(destination) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，通过仍在临时存储位置的图像来创建一个新的 asset 追加请求，并将临时存储的图像移除即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PHPhotoLibrary</span>.shared().performChanges(&#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">PHAssetChangeRequest</span>.creationRequestForAssetFromImage(atFileURL: tempURL)</span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">try</span>? <span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: tempURL)</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="HEIF"><a href="#HEIF" class="headerlink" title="HEIF"></a>HEIF</h4><p><strong>HEIF</strong> 是全新的图片格式，相应的还有视频的 <strong>HEVC</strong>。苹果表示在相同画质下大小能节约 50% 的存储空间。如果想要了解更多，推荐看一看 WWDC 2017 Session 511。</p><p>在实际运用中遇到了一个问题，如果我在相对较旧的设备上查看 <strong>.HEIC (HEIF)</strong> 的图片，并尝试去修改它，上面提到的 <code>CGImageDestination</code> 会得到一个 <code>nil</code> 对象。结果并不意外，毕竟这需要软件与硬件双方面的支持。但是具体来说究竟分界线在哪里呢？可以在 511 找到答案，而<a href="https://support.apple.com/en-us/HT207022" target="_blank" rel="noopener">这个支持页</a>也讲的很详细。基本条件就是运行 iOS 11 的 iPhone 7 等设备以及之后的新设备。</p><h3 id="监听变化"><a href="#监听变化" class="headerlink" title="监听变化"></a>监听变化</h3><p>万事俱备，只欠东风。但，如果此时系统的图片库发生了改变，又该怎么办？</p><p>只需要记住四步，就可以解决这个问题了：</p><ol><li>让当前的类遵循 <code>PHPhotoLibraryChangeObserver</code> 协议。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailInfoViewController</span>: <span class="title">PHPhotoLibraryChangeObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在视图即将出现时将当前的类作为观察者注册到 <code>PHPhotoLibrary</code> 共享对象上。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PHPhotoLibrary</span>.shared().register(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>实现 <code>PHPhotoLibraryChangeObserver</code> 协议的 <code>photoLibraryDidChange(_:)</code><br>方法。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">photoLibraryDidChange</span><span class="params">(<span class="number">_</span> changeInstance: PHChange)</span></span> &#123;</span><br><span class="line">    <span class="comment">// changeDetails 方法有接受不同参数的多个版本，可参照文档。</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> curAsset = asset, <span class="keyword">let</span> details = changeInstance.changeDetails(<span class="keyword">for</span>: curAsset) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    asset = details.objectAfterChanges</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>最后在 <code>deinit</code> 中解除监听。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="type">PHPhotoLibrary</span>.shared().unregisterChangeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 一些笔记</span><br><span class="line"></span><br><span class="line">### <span class="type">PromiseKit</span> <span class="number">6</span> </span><br><span class="line"></span><br><span class="line"><span class="type">PromiseKit</span> <span class="number">6</span> 对几个比较核心的点做出了修改。说实话，我觉得这个框架的文档可读性其实还有待提升。直接看源码及其中的注释反而是个很好的选择。</span><br><span class="line"></span><br><span class="line">其中一点是改变了核心初始化方法：</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="type">Promise</span> &#123; fulfill, reject <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line"><span class="type">Promise</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// seal.fulfill(foo)</span></span><br><span class="line">    <span class="comment">// seal.reject(error)</span></span><br><span class="line">    <span class="comment">// seal.resolve(foo, error)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一点是，将万能的 <code>then</code> 拆分为了 <code>then</code>, <code>done</code> 和 <code>map</code>。作者的解释是，以前 <code>then</code> 做很多事，但是由于依赖 Swift 根据上下文做推断，在用了多个 <code>then</code> 之后推断就会发生失败。而且很难判断错误发生在哪。所以就只能选择从比较高的层级就修复这个问题，于是有了现在的方案：</p><ul><li><code>then</code>：返回一个 promise。</li><li><code>done</code>：返回一个 Void promise (80% 的情况用在 promise 链中)。</li><li><code>map</code>：返回非 promise 值，比如一个单纯的值。</li></ul><h3 id="地理位置检索"><a href="#地理位置检索" class="headerlink" title="地理位置检索"></a>地理位置检索</h3><p>我需要的是一个根据关键字获取相关地点的一个检索，也就是常说的 POI 检索。因为需要比较简单，所以先考虑了 <strong>MapKit</strong> 的 <code>MKLocalSearch</code> 或者 <code>MKLocalSearchCompleter</code>。</p><p>前者常常会用在地图的检索，通过 <code>start(completionHandler:)</code> 可以取得 10 个结果，并且这个 limit 无法自定义，它在主线程工作，而且当发起新的请求时当前即使有正在进行的检索也不会被终止，如果不注意很可能会得到错误的结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localSearchRequest = <span class="type">MKLocalSearchRequest</span>()</span><br><span class="line"><span class="keyword">let</span> newestLocation = locations.last! <span class="keyword">as</span> <span class="type">CLLocation</span></span><br><span class="line">localSearchRequest.region = <span class="type">MKCoordinateRegion</span>(center: newestLocation.coordinate, span: <span class="type">MKCoordinateSpanMake</span>(<span class="number">5.0</span>, <span class="number">5.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">MKLocalSearch</span>(request: localSearchRequest).start(completionHandler: &#123; (localSearchResponse, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> searchText == searchBar.text <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以这似乎并不是一个理想的选择。辅以后者的 <code>MKLocalSearchCompleter</code> 会更好一些：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completer = <span class="type">MKLocalSearchCompleter</span>()</span><br><span class="line">completer.queryFragment = searchText</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: MKLocalSearchCompleter Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LocationSearchViewController</span>: <span class="title">MKLocalSearchCompleterDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理检索结果</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">completerDidUpdateResults</span><span class="params">(<span class="number">_</span> completer: MKLocalSearchCompleter)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.resultDataSource = completer.results</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">completer</span><span class="params">(<span class="number">_</span> completer: MKLocalSearchCompleter, didFailWithError error: Error)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，检索结果列表就可以很简单的表示出来了。当需要取得各个位置的详细信息时，还是无法离开 <code>MKLocalSearch</code>，根据检索结果创建请求即可。</p><p>不过即使这样也还是有很多制限，比如近邻检索，尝试使用了 Foursquare，虽然这个问题得以解决，但是请求数量的限制又是新的需要考虑的问题，所以，要走的路还很长。另外，由于在中国无法检索海外地点，也无法逆向转换海外经纬度，要走的路不是很长，而是很长很长。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Support:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/Ckitakishi/MetaX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MetaX on Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;初衷&quot;&gt;&lt;a href=&quot;#初衷&quot; class=&quot;headerlink&quot; title=&quot;初衷&quot;&gt;&lt;/a&gt;初衷&lt;/h2&gt;&lt;p&gt;常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所以就自己动手丰衣足食了。&lt;br&gt;作为一个总结，下文的主题是照片框架 PhotoKit 和简单的问题解决记录。&lt;/p&gt;
&lt;h2 id=&quot;关于照片框架-PhotoKit&quot;&gt;&lt;a href=&quot;#关于照片框架-PhotoKit&quot; class=&quot;headerlink&quot; title=&quot;关于照片框架 - PhotoKit&quot;&gt;&lt;/a&gt;关于照片框架 - PhotoKit&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;PhotoKit&lt;/strong&gt; 之前，AssetsLibrary 是被广泛使用的，由于并没有实际用过，就不再赘述。从 &lt;strong&gt;PhotoKit&lt;/strong&gt; 的文档就可以看出来，这是一个十分庞大的框架，包含了相当多的类。&lt;strong&gt;PhotoKit&lt;/strong&gt; 可以使得自己的应用与照片库以相同流程工作，此外性能也相当不错。&lt;/p&gt;
&lt;h3 id=&quot;从获取图像开始&quot;&gt;&lt;a href=&quot;#从获取图像开始&quot; class=&quot;headerlink&quot; title=&quot;从获取图像开始&quot;&gt;&lt;/a&gt;从获取图像开始&lt;/h3&gt;&lt;h4 id=&quot;相册取得&quot;&gt;&lt;a href=&quot;#相册取得&quot; class=&quot;headerlink&quot; title=&quot;相册取得&quot;&gt;&lt;/a&gt;相册取得&lt;/h4&gt;&lt;p&gt;如果以从相册列表选取照片这个流程为例来看，相册列表中的所有对象都是 &lt;code&gt;PHCollection&lt;/code&gt;，它是一个抽象父类，拥有两个子类： &lt;code&gt;PHAssetCollection&lt;/code&gt; 和 &lt;code&gt;PHCollectionList&lt;/code&gt;，前者表示相册，后者表示相册列表也就是文件夹。题外话，在 iOS 设备上创建文件夹几乎可以说是一个隐藏功能，点击追加按钮是相册，而长按则可以选择相册或文件夹。而获取相册的方法是使用上述几个类中的 fetch 方法，返回 &lt;code&gt;PHFetchResult&amp;lt;XXX&amp;gt;&lt;/code&gt;，可以用部分与 &lt;code&gt;Foundation&lt;/code&gt; 中集合类型相同的接口来处理这个结果，比如用 &lt;code&gt;enumerateObjects(_:)&lt;/code&gt; 来进行遍历。该方法默认会取回所有结果，但是可以通过使用 &lt;code&gt;PHFetchOptions&lt;/code&gt; 来做一些过滤或是排序处理。例如取回所有智能相册：&lt;/p&gt;
    
    </summary>
    
      <category term="Projects" scheme="http://ckitakishi.com/categories/Projects/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
      <category term="图像" scheme="http://ckitakishi.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
      <category term="摄影" scheme="http://ckitakishi.com/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>回顾 Try!Swift Tokyo 2018</title>
    <link href="http://ckitakishi.com/2018/03/14/%E5%9B%9E%E9%A1%BEtryswift-2018/"/>
    <id>http://ckitakishi.com/2018/03/14/回顾tryswift-2018/</id>
    <published>2018-03-14T10:37:51.000Z</published>
    <updated>2018-03-14T06:23:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>拖延症很可怕，过了快两周终于开始着手写 Try!Swift Tokyo 2018 的感想。受到了前同事的影响，今年的大会我是做为志愿者参加的，玩得很开心，然而只听到了一半的演讲T.T。所以之后会从听众和志愿者两个角度来简短的写一写让我印象深刻的一些事儿。</p><p><img src="/images/tryswift1.jpg" alt="集合写真"></p><blockquote><p><a href="https://www.tryswift.co/events/2018/tokyo/jp" target="_blank" rel="noopener">Try!Swift 官网</a></p></blockquote><p>久闻不如一见，各种机缘巧合终于和<a href="https://onevcat.com" target="_blank" rel="noopener">喵神</a>碰面了，一路学习 iOS 可能读的最多的就是喵神写的文章了，真的是受益匪浅。虽然因为比较忙只聊了一会儿还都是杂谈www，但是有种成就达成的激动感(`･∀･)</p><p>第一天早晨还遇到了 <a href="http://smoozapp.com/" target="_blank" rel="noopener">Smooz</a> 的创始人 Kato 桑，人很和善且健谈，回忆起第一次知道 Smooz 是 16 年的年初，那时候还在测试阶段，只有 iOS 版本，也还没有成立公司运营，类似于独立开发者项目。Smooz 拥有类似 web 浏览器的多 tab 置顶让人眼前一亮，各种手势的便利性也增色不少，另外颜色还相当可爱。当时 (很失礼地) 暗自想会不会渐渐又成为一个换肤浏览器？事实胜于一切，后来 Smooz 获得了 App Store Best of 2016，现在常常可以在电车上看到用户，总之是一款很不一样的移动端浏览器，值得一试。</p><a id="more"></a><h2 id="听众视角"><a href="#听众视角" class="headerlink" title="听众视角"></a>听众视角</h2><p>缺席了几场想听的演讲，像是 Charlse for iOS..泪目。下面所写的大多是临场感受。</p><blockquote><p>这是一份日语的<a href="https://qiita.com/ozwio/items/71fb765b48905d6a2193" target="_blank" rel="noopener">资料总结</a>。</p></blockquote><h3 id="代码优化：Optimizing-Swift-code-for-separation-of-concerns-and-simplicity"><a href="#代码优化：Optimizing-Swift-code-for-separation-of-concerns-and-simplicity" class="headerlink" title="代码优化：Optimizing Swift code for separation of concerns and simplicity"></a>代码优化：Optimizing Swift code for separation of concerns and simplicity</h3><p>代码的优化是一个老生常谈的话题，不过有些东西越老越能凸显它的价值所在。我个人对这个话题比较感兴趣，一方面是如讲者所说：代码通常读比写更多；还有一个原因就是团队合作，简洁明确再重要不过了。听完这个“最佳编程实践”之后，我觉得对于我这样段位不高的开发者来说还是颇有收获的，也许今后能把代码写的更 Swifty 一些？。另外，扩展给 Swift 带来的便利在这些例子中也是体现的淋漓尽致。</p><p>很多例子都深有同感，比如说下面这种模型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">api.requestReplies(postID: <span class="number">4815162342</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">switch</span> result &#123;</span><br><span class="line">   <span class="keyword">case</span> .success(<span class="keyword">let</span> replies):</span><br><span class="line">     <span class="keyword">var</span> filteredReplies: [<span class="type">Reply</span>] = []</span><br><span class="line">     <span class="keyword">for</span> reply <span class="keyword">in</span> replies &#123;</span><br><span class="line">       <span class="keyword">if</span> !user.isBlocking(reply.author) &#123;</span><br><span class="line">         filteredReplies.append(reply)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">self</span>?.replies = filteredReplies</span><br><span class="line">   <span class="keyword">case</span> .failure:</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个写 Objective-C 多于 Swift 的人，私以为这样的写法在大家的 Objc 代码中可是说是十分常见了～即使能优化，感觉也只能加入一个 filter 写成下面这样？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *filteredArray = [replies filteredArrayUsingPredicate:[<span class="built_in">NSPredicate</span> predicateWithBlock:^<span class="built_in">BOOL</span>(Reply *reply, <span class="built_in">NSDictionary</span> *bindings) &#123;</span><br><span class="line">    <span class="keyword">return</span> [user isBlocking:reply.author];</span><br><span class="line">&#125;]];</span><br></pre></td></tr></table></figure><p>讲者提到的 Swift 优化方案是：1. 将核心逻辑抽象出来作为一个 Collection 的扩展；2. 活用 <code>var</code> 和 <code>filter</code>。这样一来，代码的“信噪比”会得到不少提升，写法也比较优雅：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span> == <span class="title">Reply</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> filteringBlockedContent: [<span class="type">Reply</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">filter</span> &#123; !user.isBlocking($<span class="number">0</span>.author) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.requestReplies(postID: <span class="number">4815162342</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">switch</span> result &#123;</span><br><span class="line">   <span class="keyword">case</span> .success(<span class="keyword">let</span> replies):</span><br><span class="line">     <span class="keyword">self</span>?.replies = replies.filteringBlockedContent</span><br><span class="line">   <span class="keyword">case</span> .failure:</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真心希望以后写的代码都是 “After”。</p><blockquote><p>更多例子在<a href="https://github.com/JaviSoto/Talks/tree/master/TrySwiftTokyo2018" target="_blank" rel="noopener">这里</a></p></blockquote><h3 id="SwiftNIO"><a href="#SwiftNIO" class="headerlink" title="SwiftNIO"></a>SwiftNIO</h3><p>还在演讲前大家一起聊天时就推测这可能是当日最火？毕竟能在 WWDC 以外和 Apple 工程师交流的机会少之又少，因此还为 Q&amp;A 环节增派了志愿者～而发表的内容也没有让人失望，，在介绍了一些有关异步，以及 IO 事件的发生其实可能并没有我们想的那么频繁之后，表示不如打造一个 Swift 版的 Netty 来让性能得到一个飞跃吧，于是 SwiftNIO 就诞生了。后来的内容陷入了一种云里雾里，还是暂且先跳过吧😂。在意料之外的是最后直接宣布了 SwiftNIO 的开源。随着它的开源，服务器端 Swift 算是又迈出了重要一步。</p><p>最近有人担心 Norman 会不会因为 SwiftNIO 的开源而导致维护 Netty 的时间变少，他表示不用担心噢大家，我已经同时维护它们超过一年了～</p><blockquote><p>前两天视频已经公开了：<a href="https://www.youtube.com/watch?v=QJ3WG9kRLMo&amp;feature=youtu.be" target="_blank" rel="noopener">Youtube Link</a></p></blockquote><h3 id="用-Swift-进行游戏开发👾"><a href="#用-Swift-进行游戏开发👾" class="headerlink" title="用 Swift 进行游戏开发👾"></a>用 Swift 进行游戏开发👾</h3><p>演讲者 <a href="https://twitter.com/giginet" target="_blank" rel="noopener">giginet</a> 去年是 Lightning Talk，发表了用 SprireKit 在 AppleWatch 上开发超级玛丽的种种，并在此后的 Hackthon 中开发了一个 Touch Bar 小游戏，花样挖掘苹果家设备的潜能，很会玩。</p><p>今年再次卷土重来，上来就表示其实 Xcode 是一个游戏开发工具，并展示了在 Xcode 里绘制的世界地图…言归正传，开始着重介绍了一下 SprireKit 和 GameplayKit 的基本用法和示例。最后再把 SprireKit 与 Unity 进行了一波比较，几乎在所有平台全军覆没的 SprireKit 在 WatchOS 独占了一块阵地。。所以 Swift 开发者们都行动起来吧！</p><p>虽然开了很多玩笑，不过如果想着手游戏开发，也许还真可以用 Swift 一试呢？</p><blockquote><p><a href="https://speakerdeck.com/giginet/-11" target="_blank" rel="noopener">资料</a></p></blockquote><h3 id="算法可视化：Using-Swift-to-Visualize-Algorithms"><a href="#算法可视化：Using-Swift-to-Visualize-Algorithms" class="headerlink" title="算法可视化：Using Swift to Visualize Algorithms"></a>算法可视化：Using Swift to Visualize Algorithms</h3><p>没有听到演讲前以为会是一个借算法可视化来介绍 Swift 在图形绘制上的优势之类的。比较意外真正的核心主题是贝塞尔曲线。这个演讲在现场得到了相当好的反响，大概凭借的是讲解比较清晰易懂，像是给定任意点如何绘制，多阶贝塞尔曲线如何绘制都能从中找到答案。如果对动画有兴趣但不了解贝塞尔曲线的绘制方法不妨看一看～</p><blockquote><p><a href="https://speakerdeck.com/subdigital/bezier-curves" target="_blank" rel="noopener">资料</a></p></blockquote><h3 id="Open-Source-Swift-Workshop"><a href="#Open-Source-Swift-Workshop" class="headerlink" title="Open Source Swift Workshop"></a>Open Source Swift Workshop</h3><p>最后一天有几场 workshop，我只去了 Open Source Swift Workshop ( BY <a href="https://twitter.com/din0sr" target="_blank" rel="noopener">Nicholas Maccharoli</a> &amp; <a href="https://twitter.com/ikesyo" target="_blank" rel="noopener">ikesyo</a>  )。大概可以概括为 “如何通过改 bug 或优化为 Swift 贡献力量”。应该有很多人都想过，除了用 Swift 写代码，我们是不是能做的更多呢。现实的残酷在于，实际上手有时候并不是那么容易，也许是需要一个契机，也许是需要一个人引导。而这个 workshop 便成为了一个很好的机会，结束后有不止一个人提了 pr…</p><p>鉴于自身学识浅薄，当天向 ikesyo 桑请教了最初该如何着手，作为入门我觉得很细致很清晰：</p><ol start="0"><li>build 最新的 Swift 源码。</li><li><a href="https://bugs.swift.org" target="_blank" rel="noopener">https://bugs.swift.org</a> ：在这里会有很多待解决的 issue, 属于 Compiler,  LLDB for Swift, Package Manager, Standard  Library 等模块，第一次上手选择自己相对了解的会比较好，例如：Standard Library 和 Foundation。正确使用 Filter  也有助于找到适合自己的 issue，比如说检索带有入门级标签的 Standard Library 或 Foundation issue: <code>labels = StarterBug AND status = Open AND component in (&quot;Standard Library&quot;, Foundation)</code>。</li><li><a href="https://forums.swift.org/" target="_blank" rel="noopener">https://forums.swift.org/</a> ：在这里和大家愉快的讨论问题。</li><li>也可以通过从源码中查找 <code>FIXME</code>, <code>TODO</code> 这些关键字来查找可以改进的地方，这其中甚至有一些是文本层面的修正～</li></ol><p><strong>扩展阅读：</strong></p><ul><li><a href="https://swift.org/compiler-stdlib/#compiler-architecture" target="_blank" rel="noopener">https://swift.org/compiler-stdlib/#compiler-architecture</a></li><li><a href="https://swift.org/community/" target="_blank" rel="noopener">https://swift.org/community/</a></li><li><a href="https://academy.realm.io/posts/tryswift-jesse-squires-contributing-open-source-swift/" target="_blank" rel="noopener">https://academy.realm.io/posts/tryswift-jesse-squires-contributing-open-source-swift/</a></li><li><a href="https://www.uraimo.com/2016/02/09/a-short-swift-gyb-tutorial/" target="_blank" rel="noopener">https://www.uraimo.com/2016/02/09/a-short-swift-gyb-tutorial/</a></li><li><a href="https://www.youtube.com/watch?v=e18uipMmEoo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=e18uipMmEoo</a></li></ul><h2 id="志愿者视角"><a href="#志愿者视角" class="headerlink" title="志愿者视角"></a>志愿者视角</h2><p>今年的参会人数包括 Sponsor 和 Speaker 达到了 800 人，来自日本以外的参加者也超过了 200 人，志愿者的数量约为 30 人。阴差阳错，我主要担当的是 global support，引导演讲者与同传事前会面，按时上台，之后 Q&amp;A。很有意思的一个细节是，英语同声译日语其实很痛苦，因为日语真的很啰嗦，尤其是这种场合基本都是敬语，英语 10 个音节日语可能需要 20 个，每次同传们都会千叮咛万嘱咐演讲者慢一点再慢一点😂，事后再吐槽“你怎么越讲越快呢～～”。很大的收获是意识到了自己的语言是有多么差。。。</p><p>这次有一个很特殊的志愿者，80 多岁了仍然在学习写代码，有自己的主页及上架应用，听说之后觉得唯有敬佩，没能直接交流真是太遗憾了。有时候休会时间会看到一些人盒饭放一边，坐在走廊和墙边就噼里啪啦写代码，由衷的觉得：能如此热爱一件事真是太好了！</p><p>日本很多 iOS 活跃的企业都作为 Sponsor 有自己的展区，（主要还是为了招聘，到处看被塞了好几份介绍）。像是 Yahoo Japan 的 live coding 得到了很好的反响。于企业于个人这都是一个不错的机会。</p><p>P.S. Party 的蛋糕真的是太可爱了…</p><p><img src="/images/tryswift2.jpg" alt="Cake"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>于我而言，大概就是意识到了自己在很多方面都还差很远的事实，不管是技术还是日语英语。前路漫漫，继续加油。明年再见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖延症很可怕，过了快两周终于开始着手写 Try!Swift Tokyo 2018 的感想。受到了前同事的影响，今年的大会我是做为志愿者参加的，玩得很开心，然而只听到了一半的演讲T.T。所以之后会从听众和志愿者两个角度来简短的写一写让我印象深刻的一些事儿。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/tryswift1.jpg&quot; alt=&quot;集合写真&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tryswift.co/events/2018/tokyo/jp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Try!Swift 官网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;久闻不如一见，各种机缘巧合终于和&lt;a href=&quot;https://onevcat.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;喵神&lt;/a&gt;碰面了，一路学习 iOS 可能读的最多的就是喵神写的文章了，真的是受益匪浅。虽然因为比较忙只聊了一会儿还都是杂谈www，但是有种成就达成的激动感(`･∀･)&lt;/p&gt;
&lt;p&gt;第一天早晨还遇到了 &lt;a href=&quot;http://smoozapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Smooz&lt;/a&gt; 的创始人 Kato 桑，人很和善且健谈，回忆起第一次知道 Smooz 是 16 年的年初，那时候还在测试阶段，只有 iOS 版本，也还没有成立公司运营，类似于独立开发者项目。Smooz 拥有类似 web 浏览器的多 tab 置顶让人眼前一亮，各种手势的便利性也增色不少，另外颜色还相当可爱。当时 (很失礼地) 暗自想会不会渐渐又成为一个换肤浏览器？事实胜于一切，后来 Smooz 获得了 App Store Best of 2016，现在常常可以在电车上看到用户，总之是一款很不一样的移动端浏览器，值得一试。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>想要坚持下去的2018</title>
    <link href="http://ckitakishi.com/2018/01/08/%E6%83%B3%E8%A6%81%E5%9D%9A%E6%8C%81%E4%B8%8B%E5%8E%BB%E7%9A%842018/"/>
    <id>http://ckitakishi.com/2018/01/08/想要坚持下去的2018/</id>
    <published>2018-01-08T12:30:00.000Z</published>
    <updated>2018-01-08T14:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天终于看了电视剧版《火花》，久久无法释怀。很喜欢的一幕是 sparks 的谢幕演出，不再为了迎合潮流而讲段子，泪流满面说反话，哭着笑，笑着哭，最后的绽放啊。坚持与努力是因为还有梦想，可妥协与放弃并不是结束，还能平凡的活着，就总还会有平凡的奇迹。</p><a id="more"></a><h4 id="题外话的分割线"><a href="#题外话的分割线" class="headerlink" title="==== 题外话的分割线 ===="></a>==== 题外话的分割线 ====</h4><p>过去这一年，常常感觉好无奈。坚持运动，很大程度保持健康饮食，可身体状况却意外的差。可是除了坚持下去还能有什么办法呢？工作内容没有太大的变化，依然担当着几个应用的开发，只不过多了和客户的接洽，然鹅我这样的渣日语什么时候才能和客户谈笑风生啊。没有什么惊喜，不过感性的用心情来评价的话，其实真的也不太坏，还是很容易感动很容易开心。</p><p>2018 年最想要的在一些事情上坚持下去，纵然也许什么也改变不了，哈哈。颤抖着立个 flag 吧：</p><ul><li>日语和英语进阶</li><li>和更多人交流和沟通</li><li>在 test 和 project manage 方面有进步，分享知识，拥抱开源</li><li>拍不错的照片，做好吃的饭，坚持运动，去旅行</li><li>读 24 本书</li><li>上架 2～3 个小应用</li><li>换工作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天终于看了电视剧版《火花》，久久无法释怀。很喜欢的一幕是 sparks 的谢幕演出，不再为了迎合潮流而讲段子，泪流满面说反话，哭着笑，笑着哭，最后的绽放啊。坚持与努力是因为还有梦想，可妥协与放弃并不是结束，还能平凡的活着，就总还会有平凡的奇迹。&lt;/p&gt;
    
    </summary>
    
      <category term="浮生记" scheme="http://ckitakishi.com/categories/%E6%B5%AE%E7%94%9F%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://ckitakishi.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>实践：Objective-C的宏定义</title>
    <link href="http://ckitakishi.com/2017/11/30/%E5%AE%9E%E8%B7%B5%EF%BC%9AObjective-C%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://ckitakishi.com/2017/11/30/实践：Objective-C的宏定义/</id>
    <published>2017-11-30T13:17:13.000Z</published>
    <updated>2018-05-06T08:59:38.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前某一周的 LT 话题。</p></blockquote><p>宏定义在 Objective-C 中可以说是被广泛使用。就实际来说，目前组内对 Enum, Singeleton, Log 等都使用了宏来进行定义。究其原因，一部分是为了为了减少重复代码，提升开发体验，还有一部分来源于对条件编译的需求。</p><p>最早知道宏定义是在 C 语言课本上，然后就是笔试时候的各种宏展开。但是直到投入项目开发之后才算是稍微理解了一些宏的强大与脆弱。所以很想简单谈一谈 Objective-C 的宏定义实践。</p><h2 id="关于宏"><a href="#关于宏" class="headerlink" title="关于宏"></a>关于宏</h2><p>宏属于 C 预处理的一部分，C++，Objective-C 也一样通用。宏分为两种，对象宏 (<strong>Object-like</strong>) 和函数宏 (<strong>Function-like</strong>)。顾名思义，对象宏类似于数据对象，函数宏类似于函数调用。</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object-like</span></span><br><span class="line"><span class="meta">#define HEIGHT 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function-like</span></span><br><span class="line"><span class="meta">#define MIN(a, b) a <span class="meta-string">&lt; b ? a : b</span></span></span><br></pre></td></tr></table></figure><p>函数宏看起来可以说是相当便利，而且执行效率还非常高。但是在实际运用中很多时候并不推荐使用，比如当出现自增自减运算时，上面的最小值就可能会发生错误，你不能说它是陷阱，毕竟宏的强项并不是复杂的逻辑运算。但是艺高人胆大，如果能玩得转用一用也无妨~</p><p>扩展阅读：<a href="https://gcc.gnu.org/onlinedocs/cpp/index.html#SEC_Contents" target="_blank" rel="noopener">The C Preprocessor</a></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="单例的宏定义："><a href="#单例的宏定义：" class="headerlink" title="单例的宏定义："></a>单例的宏定义：</h3><p>使用了条件编译 <code>#ifndef</code>，推荐这种写法，尤其是在定义 cell 的高度时最好这么做，防止多重定义。<br>这是一个函数宏。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef Singleton_h</span></span><br><span class="line"><span class="meta">#define Singleton_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define SINGLETON_IMPL( classname )\</span></span><br><span class="line">+ (classname *)sharedInstance\</span><br><span class="line">&#123;\</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;\</span><br><span class="line"><span class="keyword">static</span> classname *_sharedInstance = <span class="literal">nil</span>;\</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;\</span><br><span class="line">_sharedInstance = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];\</span><br><span class="line">&#125;);\</span><br><span class="line"><span class="keyword">return</span> _sharedInstance;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define SINGLETON_DEFINE( classname )\</span></span><br><span class="line">+ (classname *)sharedInstance;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>利用例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassName.h</span><br><span class="line"><span class="function"><span class="title">SINGLETON_DEFINE</span><span class="params">(ClassName)</span></span></span><br><span class="line"></span><br><span class="line">ClassName.m</span><br><span class="line"><span class="function"><span class="title">SINGLETON_IMPL</span><span class="params">(ClassName)</span></span></span><br><span class="line"></span><br><span class="line">OtherClass:</span><br><span class="line">[ClassName sharedInstance].property</span><br></pre></td></tr></table></figure><h3 id="2-enum的宏定义："><a href="#2-enum的宏定义：" class="headerlink" title="2. enum的宏定义："></a>2. enum的宏定义：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef APP_ENUM</span></span><br><span class="line"><span class="meta">#define APP_ENUM( name_ ) \</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> name_ : <span class="built_in">NSInteger</span> name_; \</span><br><span class="line"><span class="keyword">enum</span> name_ : <span class="built_in">NSInteger</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>利用例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APP_ENUM( EnumName ) &#123;</span><br><span class="line">    EnumNameA,</span><br><span class="line">    EnumNameB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-LOG的宏定义："><a href="#3-LOG的宏定义：" class="headerlink" title="3. LOG的宏定义："></a>3. LOG的宏定义：</h3><p>当且仅当版本为开发版或内部测试版时输出 log。这里的 <code>__PRETTY_FUNCTION__</code>, <code>__LINE__</code> 都是 C 中已定义的函数宏，分别表示函数和行数。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef DEBUG</span></span><br><span class="line"><span class="meta">#define LOG(A, ...) NSLog(@<span class="meta-string">"DEBUG: %s:%d:%@"</span>, __PRETTY_FUNCTION__,__LINE__,[NSString stringWithFormat:A, ## __VA_ARGS__]);</span></span><br><span class="line"><span class="meta">#elif defined ALPHA</span></span><br><span class="line"><span class="meta">#define LOG(A, ...) NSLog(@<span class="meta-string">"ALPHA: %s:%d:%@"</span>, __PRETTY_FUNCTION__,__LINE__,[NSString stringWithFormat:A, ## __VA_ARGS__]);</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define LOG(...)</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>利用例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOG(<span class="string">@"test"</span>);</span><br></pre></td></tr></table></figure><p>出力：</p><p>[Time] [App Name] [Build Configuration] [File Name + Method] [Line Number] log </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017-11-27 09:35:19.099 AppName[59272:2201737] DEBUG: -[ClassName method]:330: test</span><br></pre></td></tr></table></figure><h3 id="4-TODO-amp-FIX-的宏定义："><a href="#4-TODO-amp-FIX-的宏定义：" class="headerlink" title="4. TODO&amp;FIX 的宏定义："></a>4. TODO&amp;FIX 的宏定义：</h3><p>参考自 <a href="http://blog.sunnyxx.com/2015/03/01/todo-macro/" target="_blank" rel="noopener">todo-macro</a>，很有意思的一篇文章，通过宏定义将 <code>#pragma message (&quot;msg&quot;)</code> 进行扩展而作为 TODO 使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define STRINGIFY(S) #S</span></span><br><span class="line"><span class="meta">#define DEFER_STRINGIFY(S) STRINGIFY(S)</span></span><br><span class="line"><span class="meta">#define PRAGMA_MESSAGE(MSG) _Pragma(STRINGIFY(message(MSG)))</span></span><br><span class="line"><span class="meta">#define FORMATTED_MESSAGE(MSG) <span class="meta-string">"[TODO-"</span> DEFER_STRINGIFY(__COUNTER__) <span class="meta-string">"]"</span> MSG <span class="meta-string">" Line:"</span> DEFER_STRINGIFY(__LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define TODO(MSG) PRAGMA_MESSAGE(FORMATTED_MESSAGE(MSG))</span></span><br></pre></td></tr></table></figure><p>利用例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@TODO(<span class="string">"test code 1"</span>)</span><br><span class="line">@TODO(<span class="string">"test code 2"</span>)</span><br></pre></td></tr></table></figure><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>当要使用宏时，务必要考虑有没有必要，合不合理，会不会有副作用。举个例子来说：当需要定义一个常量时，宏完全可以，但是更好的选择是使用 <code>const</code> 关键字。借助宏来定义常量最大的痛点就是不包含类型信息，<code>const</code> 不仅弥补了类型信息缺失的问题，而且在访问控制权限这块也表现地更好。</p><p>最后还想提一句 <code>typedef</code>，人们常常会拿它和 <code>#define</code> 相比较，看起来用法很相似，其实本质上有蛮大区别，<code>typedef</code> 是在编译期间进行处理的关键字。用途上来说，<code>typedef</code> 更多是用于创建类型别名，上述 Enum 的宏定义中为枚举指定别名就依赖于 <code>typedef</code>。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前某一周的 LT 话题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宏定义在 Objective-C 中可以说是被广泛使用。就实际来说，目前组内对 Enum, Singeleton, Log 等都使用了宏来进行定义。究其原因，一部分是为了为了减少重复代码，提升开发体验，还有一部分来源于对条件编译的需求。&lt;/p&gt;
&lt;p&gt;最早知道宏定义是在 C 语言课本上，然后就是笔试时候的各种宏展开。但是直到投入项目开发之后才算是稍微理解了一些宏的强大与脆弱。所以很想简单谈一谈 Objective-C 的宏定义实践。&lt;/p&gt;
&lt;h2 id=&quot;关于宏&quot;&gt;&lt;a href=&quot;#关于宏&quot; class=&quot;headerlink&quot; title=&quot;关于宏&quot;&gt;&lt;/a&gt;关于宏&lt;/h2&gt;&lt;p&gt;宏属于 C 预处理的一部分，C++，Objective-C 也一样通用。宏分为两种，对象宏 (&lt;strong&gt;Object-like&lt;/strong&gt;) 和函数宏 (&lt;strong&gt;Function-like&lt;/strong&gt;)。顾名思义，对象宏类似于数据对象，函数宏类似于函数调用。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
      <category term="LT" scheme="http://ckitakishi.com/tags/LT/"/>
    
      <category term="Objective-C" scheme="http://ckitakishi.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Storyboard 和 Xib 的“抉择”</title>
    <link href="http://ckitakishi.com/2017/09/24/Storyboard-%E4%B8%8E-Xib-%E7%9A%84%E2%80%9C%E6%8A%89%E6%8B%A9%E2%80%9D/"/>
    <id>http://ckitakishi.com/2017/09/24/Storyboard-与-Xib-的“抉择”/</id>
    <published>2017-09-24T13:33:29.000Z</published>
    <updated>2017-10-23T15:37:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近期开始进行一个新项目的原型制作及其结构设计，打算把一些心路历程记录下来，随便先给它取个名字叫做：<strong>P-OOP</strong>。</p></blockquote><p>比起手写 UI，“拖控件”的 Storyboard 和 Xib 似乎一直都更投我所好。不过即使是 Storyboard 和 Xib 之间，似乎也还是多多少少有一些纷争。</p><h2 id="Storyboard-amp-Xib"><a href="#Storyboard-amp-Xib" class="headerlink" title="Storyboard &amp; Xib"></a>Storyboard &amp; Xib</h2><p>公司 (年久失修) 的 iOS Guidelines 中写着一句话：</p><blockquote><p>进行源码管理时 Storyboard 极易导致冲突，团队开发时，各画面与各组件尽可能使用 Xib 进行实现。</p></blockquote><p>对此我一直抱着赞否两论的观点。在实际工作时，同一 Storyboard 中存在大量 ViewController 十分容易冲突是一个不争的事实，掉进这个坑的人有可能还进行过 xml 修正。但是这个锅 Storyboard 不背。一部分人可能因此选择了弃 Storyboard 从 Xib 之路，我也一度徘徊是否这才是正道。但是很显然的是，Storyboard 从一开始就不是为了代替 Xib 而来。</p><p>除了 UI 设置的相似部分以外，Storyboard 更重视画面之间的关联和迁移，而 Xib 作为通用组件的模版应该是不二的选择。</p><a id="more"></a><p>在 P-OOP 中，将会存在大量的 dialog，尽管可以很容易的使用 Present Modally 来实现，不过为了保持系列产品的风格一致性，需要考虑如何以比较好的方式来实现共通的 header 和 footer 样式。考虑过很多方案，比如：</p><ol><li>将 footer 和 header 集成在同一个 view 中，并添加一个 content view，最终在某 controlelr view 中将上述 view 与实际从另一个 xib 中载入的 content view 组合，完成组装。但是存在一个比较显著的缺点，实际可见的 controller view 所呈现的内容并不是很直观，果然还是必须看代码才能梳理清楚。 </li><li>将 footer 和 header 以及一个 content view 集成在同一个 controller view 中。在代码中按照要求载入 content，代理方法之类变得容易管理了一些，但是更糟糕的是这个 controller 的代码终将成为垃圾场的。。。那加入继承呢？有些小题大做？</li></ol><p>果然简洁才是最高的，将 footer 和 header 完全独立为两个 view，按需载入。结合 @IBInspectable 和 @IBDesignable 可以说是比较完美了，从画面设计到迁移等都很清晰。不足一提的小缺点是使用时候的 auto layout 的设置可能存在一些重复操作 (比如 Auto Layout 之类的)，若考虑 Model 除了 form sheet 以外可以是 full screen，后者需要在顶部额外预留 20px，这样一来反而变得巧妙了。</p><p>也许过几天自己的想法又发生了细微变化，但简洁清晰无论何时都不会太坏。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="Storyboard-Reference"><a href="#Storyboard-Reference" class="headerlink" title="Storyboard Reference"></a>Storyboard Reference</h3><p>Storyboard 容易引发冲突，这句话在 Storyboard Reference 面前是不成立的。</p><p><strong>Storyboard Reference</strong> 第一次出现在 Xcode 7，可以从组件库中找到它，并自行进行配置和关联，十分简单，无需赘述。即使是一个已经完成且十分繁杂的 Storyboard，也可以选中想要分离的 Storyboard，通过 <strong>Editor -&gt; Refactor to Storyboard</strong> 来实现。比如，使用了两个 Container View，默认情况下此时画面中存在三个 controller，对其进行分离之后，变成了这样：</p><p><img src="/images/Storyboard_reference.png" alt="Storyboard Reference"></p><h3 id="Loadable-Nib"><a href="#Loadable-Nib" class="headerlink" title="Loadable Nib"></a>Loadable Nib</h3><p>将 Xib 组件的载入协议化，其中一个目的是为了类型安全，另一个目的是为了减少重复代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Loadable</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Loadable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="type">Self</span>.<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>UIView</code> 进行扩展，要求被载入的 view 遵循 <code>Loadable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiateFromNib</span>&lt;T: UIView&gt;<span class="params">(<span class="number">_</span>:T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Loadable</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="type">T</span>.nibName, bundle: <span class="literal">nil</span>).instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>).first <span class="keyword">as</span>? <span class="type">T</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nib</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Nib \(T.nibName) is not exist ?!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiateFromNibOwner</span>&lt;T: UIView&gt;<span class="params">(<span class="number">_</span>:T.<span class="keyword">Type</span>)</span></span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Loadable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="type">T</span>.nibName, bundle: bundle).instantiate(withOwner: <span class="keyword">self</span>, options: <span class="literal">nil</span>).first <span class="keyword">as</span>? <span class="type">UIView</span> &#123;</span><br><span class="line">            nib.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">            nib.autoresizingMask = [.flexibleWidth, .flexibleHeight]</span><br><span class="line">            <span class="keyword">self</span>.addSubview(nib)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Nib \(T.nibName) is not exist ?!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁的初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view:<span class="type">ClassName</span> = <span class="keyword">self</span>.instantiateFromNib(<span class="type">ClassName</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">self</span>.instantiateFromNibOwner(<span class="type">ClassName</span>.<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p>后来发现一个名为 <a href="https://github.com/AliSoftware/Reusable" target="_blank" rel="noopener">Reusable</a> 的库，其中除了这一部分的实现之外，还有对 Cell 甚至是 Storyboard 和 ViewController 的重用，十分强大。</p><p>回到这一部分的实现，略有区别的地方在于：</p><ol><li><em>Reusable</em> 在初始化 nib 的时候选择了扩展协议。</li><li>在 <em>File’s Owner</em> 的情况下，<em>Reusable</em> 使用了 Auto Layout。由于我们的 <strong>P-OOP</strong> 项目对应的设备尺寸不多，所以像是部分弹出框就没有对应 Auto Layout，所以就直接从 frame 的尺寸下手了。。</li></ol><blockquote><p>追记：把这部分实现和例子提了出来放在了 <a href="https://github.com/Ckitakishi/LoadableNib" target="_blank" rel="noopener">Github</a> 上～</p></blockquote><h3 id="IBDesignable-和-IBInspectable"><a href="#IBDesignable-和-IBInspectable" class="headerlink" title="@IBDesignable 和 @IBInspectable"></a>@IBDesignable 和 @IBInspectable</h3><p><strong>@IBDesignable</strong> 可以用于视图的实时渲染，<strong>@IBInspectable</strong> 可以用于定义运行时属性。</p><p>举个例子来说：首先在定义一个 <code>DialogHeaderView</code>，标记为 <code>@IBDesignable</code>，将它的 <code>headerTitle</code> 属性设置为 <code>@IBInspectable</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBDesignable</span> <span class="class"><span class="keyword">class</span> <span class="title">DialogHeaderView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBInspectable</span> <span class="keyword">var</span> headerTitle: <span class="type">String</span> = <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            navigationBar.topItem?.title = <span class="keyword">self</span>.headerTitle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后向目标视图添加一个 UIView，并将类定义为 <code>DialogHeaderView</code>，此时在 <em>Attribuite Inspector</em> 中可以直接设置属性：</p><p><img src="/images/IB1.png" alt="IB1"></p><p>之后即会反映在运行时属性栏中：</p><p><img src="/images/IB2.png" alt="IB2"></p><p>不过构建失败的时候还是挺多的，不妨通过 <strong>Editor -&gt; Debug Selected Views</strong> 来调试一下选中的视图。</p><h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><p>除了定义上面的 <code>Loadable</code> 协议，在类型安全这个问题上还可以进一步再做一些工作。</p><p>存在 Storyboard，Segue 的定义也就会有存在，由于 identifier 的定义是字符串，防不胜防，不匹配的情况还是会时而发生。这时候使用 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 就能够完全解消这个担忧了。</p><p><em>R.swift</em> 被广泛使用于解决类型安全的问题，图片、字体、本地化等等都受益于此。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;近期开始进行一个新项目的原型制作及其结构设计，打算把一些心路历程记录下来，随便先给它取个名字叫做：&lt;strong&gt;P-OOP&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比起手写 UI，“拖控件”的 Storyboard 和 Xib 似乎一直都更投我所好。不过即使是 Storyboard 和 Xib 之间，似乎也还是多多少少有一些纷争。&lt;/p&gt;
&lt;h2 id=&quot;Storyboard-amp-Xib&quot;&gt;&lt;a href=&quot;#Storyboard-amp-Xib&quot; class=&quot;headerlink&quot; title=&quot;Storyboard &amp;amp; Xib&quot;&gt;&lt;/a&gt;Storyboard &amp;amp; Xib&lt;/h2&gt;&lt;p&gt;公司 (年久失修) 的 iOS Guidelines 中写着一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进行源码管理时 Storyboard 极易导致冲突，团队开发时，各画面与各组件尽可能使用 Xib 进行实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对此我一直抱着赞否两论的观点。在实际工作时，同一 Storyboard 中存在大量 ViewController 十分容易冲突是一个不争的事实，掉进这个坑的人有可能还进行过 xml 修正。但是这个锅 Storyboard 不背。一部分人可能因此选择了弃 Storyboard 从 Xib 之路，我也一度徘徊是否这才是正道。但是很显然的是，Storyboard 从一开始就不是为了代替 Xib 而来。&lt;/p&gt;
&lt;p&gt;除了 UI 设置的相似部分以外，Storyboard 更重视画面之间的关联和迁移，而 Xib 作为通用组件的模版应该是不二的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://ckitakishi.com/tags/Swift/"/>
    
      <category term="P-OOP记录" scheme="http://ckitakishi.com/tags/P-OOP%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>viewWillAppear 杂谈</title>
    <link href="http://ckitakishi.com/2017/07/26/viewWillAppear-%E6%9D%82%E8%B0%88/"/>
    <id>http://ckitakishi.com/2017/07/26/viewWillAppear-杂谈/</id>
    <published>2017-07-26T14:48:22.000Z</published>
    <updated>2017-10-07T15:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为 view 的状态之一，<code>viewWillAppear</code> 的关注率极高，所以其实并没有什么好说的…我们都知道它会在 view 每一次将要准备出现之前被调用，所以常常可以用来初始化一些基本数据。</p><p>前两周花了一点点时间重构了组里的某个小应用，前开发者新手上路，感觉不少代码值得推敲。在 debug 的时候发现应用一到后台就自动退出了，根本无法看它在后台的活动，震惊之余发现 info.plist 的 <code>Application does not run in background</code> 被设置为了 <code>YES</code>…反复揣摩整个应用的功能也不知道这么做目的何在，于是果断将其改为了 <code>NO</code>。</p><p>不过事情并没有那么简单，毕竟这是一段关于 viewWillAppear 的杂谈。</p><a id="more"></a><p>后来随着时间的推移，总算发现禁止后台运行的“用处”了。某个 view 有一个相对特殊的需求，应用从后台回到前台时需要重新初始化它的数据，尽管在 <code>viewWillAppear</code> 中准备了完备的初始化代码，但是这个状态的迁移并不能认为是 view 即将出现，毕竟 view 并没有消失，一直都是显示状态。所以自然 <code>viewWillAppear</code> 就不会被调用，为了解决这个问题，于是这位同学想了这个办法。</p><p>不得不承认这个思路还是很清奇的，但是为了避免一些不必要的麻烦，我还是决定改用常规解决方案。在应用重回前台的时候发一个通知，告诉 view 可以重新初始化数据了。这种情况下，在 <code>viewWillAppear</code> 中添加一个对 <code>.UIApplicationWillEnterForeground</code> 通知的观察应该是一个不二的选择，它也常常被用于处理像是电话强制中断之类的需求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(willEnterForeground), name: .<span class="type">UIApplicationWillEnterForeground</span>, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这个方案可是说是比较优雅的，不过不可以忘记移除通知。关于声明周期这些事儿，有时候真是操碎了心~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为 view 的状态之一，&lt;code&gt;viewWillAppear&lt;/code&gt; 的关注率极高，所以其实并没有什么好说的…我们都知道它会在 view 每一次将要准备出现之前被调用，所以常常可以用来初始化一些基本数据。&lt;/p&gt;
&lt;p&gt;前两周花了一点点时间重构了组里的某个小应用，前开发者新手上路，感觉不少代码值得推敲。在 debug 的时候发现应用一到后台就自动退出了，根本无法看它在后台的活动，震惊之余发现 info.plist 的 &lt;code&gt;Application does not run in background&lt;/code&gt; 被设置为了 &lt;code&gt;YES&lt;/code&gt;…反复揣摩整个应用的功能也不知道这么做目的何在，于是果断将其改为了 &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不过事情并没有那么简单，毕竟这是一段关于 viewWillAppear 的杂谈。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Thread Sanitizer</title>
    <link href="http://ckitakishi.com/2017/05/13/Thread-Sanitizer/"/>
    <id>http://ckitakishi.com/2017/05/13/Thread-Sanitizer/</id>
    <published>2017-05-13T05:39:19.000Z</published>
    <updated>2017-10-07T15:58:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>作为一项惯例，周五早晨，组内每个人都要进行三分钟的 LT，将自己感兴趣的话题分享给大家。</em></p><p>之前在修正并优化应用内线程管理的时候用了 <strong>Thread Sanitizer</strong> 功能，于是以此为机给大家简单介绍了一下。更多详细的内容，可以看一看 2016 WWDC 的 <a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">Session 412</a>。线程问题发生的时候一般还是挺焦虑的，因为时间敏感，有时候再现很困难，自然就不易调适。<strong>TSan</strong> 能够发现一些问题，诸如 Keynote 里提到的：</p><blockquote><p>Use of uninitialized mutexes<br>Thread leaks (missing pthred_join)<br>Unsafe calls in signal handlers (ex:malloc)<br>Unlock from wrong thread<br>Data races</p></blockquote><p>因为在实际中遇到过，而且感觉发生概率相对较高，所以只展开说一下最后一项：数据竞争。数据竞争发生的基本条件是多个线程在同时访问同一块内存，并且其中至少又一个线程正在进行的是写操作。实际中常常表现为数据不整合，亦或是应用崩溃。比如下面这个例子：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[context performBlock:^&#123;</span><br><span class="line">    if (result &amp;&amp; context) &#123;</span><br><span class="line">        result = [self persistentSaveContext:context]; // 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">return result; // 2</span><br></pre></td></tr></table></figure><p><code>result</code> 在 1 和 2 两个地方发生了竞争。在 1 进行写操作之前，有可能处于不同线程的 2 早已经返回了，这样数据就发生了不整合。</p><p>有很多方法可以解决这个问题，比如说：由异步操作变为同步操作，或是改变写操作的时间点。这里采取了第一个方案，使用同样用途的同步方法 <code>performBlockAndWait</code> 来取代 <code>performBlock</code>，这样以来，数据竞争的问题也就自然而然解决了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[context performBlockAndWait:^&#123;</span><br><span class="line">    if (result &amp;&amp; context) &#123;</span><br><span class="line">        result = [self persistentSaveContext:context]; // 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">return result; // 2</span><br></pre></td></tr></table></figure><p>由于 <strong>TSan</strong> 是统合在编译器 (Clang) 层面的，所以当使用 Swift 来编写服务器代码的时候，完全可以在命令行中使用它：</p><p><img src="/images/datarace.png" alt="Tsan command"></p><p>P.S.目前 <strong>TSan</strong> 只支持 64bit 的模拟器及 macOS 自身。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;作为一项惯例，周五早晨，组内每个人都要进行三分钟的 LT，将自己感兴趣的话题分享给大家。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;之前在修正并优化应用内线程管理的时候用了 &lt;strong&gt;Thread Sanitizer&lt;/strong&gt; 功能，于是以此为机给大家简单介绍了一下。更多详细的内容，可以看一看 2016 WWDC 的 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/412/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Session 412&lt;/a&gt;。线程问题发生的时候一般还是挺焦虑的，因为时间敏感，有时候再现很困难，自然就不易调适。&lt;strong&gt;TSan&lt;/strong&gt; 能够发现一些问题，诸如 Keynote 里提到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use of uninitialized mutexes&lt;br&gt;Thread leaks (missing pthred_join)&lt;br&gt;Unsafe calls in signal handlers (ex:malloc)&lt;br&gt;Unlock from wrong thread&lt;br&gt;Data races&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为在实际中遇到过，而且感觉发生概率相对较高，所以只展开说一下最后一项：数据竞争。数据竞争发生的基本条件是多个线程在同时访问同一块内存，并且其中至少又一个线程正在进行的是写操作。实际中常常表现为数据不整合，亦或是应用崩溃。比如下面这个例子：&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
      <category term="LT" scheme="http://ckitakishi.com/tags/LT/"/>
    
  </entry>
  
  <entry>
    <title>Swift App:一个意料之外的崩溃理由</title>
    <link href="http://ckitakishi.com/2017/02/13/Swift-App-%E4%B8%80%E4%B8%AA%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%E7%9A%84%E5%B4%A9%E6%BA%83%E7%90%86%E7%94%B1/"/>
    <id>http://ckitakishi.com/2017/02/13/Swift-App-一个意料之外的崩溃理由/</id>
    <published>2017-02-13T14:10:51.000Z</published>
    <updated>2017-10-07T15:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个发生在去年年底的故事。背景是一个新规 Swift 应用处于准备发布阶段，证书由开发测试用更替为发布用， 这是两份 Team 不同的企业版证书。</p><p>应用功能本身十分简单，开发测试阶段也比较顺利，几乎没有发生崩溃。然而在更替证书之后，真机测试应用时却陷入了无限崩溃的境地。</p><a id="more"></a><p>Log 类似下面这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dyld</span>: Library not <span class="attribute">loaded</span>: <span class="variable">@rpath</span>/libswiftCore.dylib</span><br><span class="line">  Referenced <span class="attribute">from</span>: ...</span><br><span class="line">  <span class="attribute">Reason</span>: no suitable image found.  Did <span class="attribute">find</span>:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>有很多原因会导致提示这个错误，作为 Trouble Shooting 记录下来：</p><ul><li>可能存在缓存，<strong>Clean</strong> 工程</li><li>很多时候该问题发生在 Swift 与 Objective-C 混编的时候，所以需要检查 <em>Building Setting</em> 中 <em>Embeedded Content Contains Swift Code</em> 的设置是否已经为 <strong>YES</strong>。</li><li>依然是配置，检查 <em>Building Setting</em> 中的 <em>Runpath Search Paths</em> 是否正确，通常是：<strong>@executable_path/Frameworks</strong>。</li><li>重置证书 (注销再新建) 。</li></ul><p>实际的生产过程中，首先 check 了前三项，最终强烈怀疑是证书问题。关于 “libswiftCore.dylib 崩溃“这个话题，很容易能看到这篇 <a href="https://developer.apple.com/library/content/qa/qa1886/_index.html" target="_blank" rel="noopener">Q&amp;A</a>，其中提到要运行 Swift 应用必须使用 iOS 8 Released 之后创建的证书。对比手中的两份证书，除了 Team 不同之外，最大的差别在于创建时间，分别为 2016 年夏天，和 2014 年夏天。所以更新证书之后，问题也幸运地解决了。</p><p>关于 libswiftCore.dylib 文件还想再多扯几句，看名字就能够猜到是 Swift 动态库，具体说来它其实是 Swift 的运行时库，但是该文件和证书有什么关系呢？原因在于目前 Swift 的版本升级还不稳定，如果将这些运行时库直接放到系统中，很可能会导致每次 Swift 升级都导致应用不再能够使用，而作为这个问题的解决方案，Apple 选择将运行时库打包进应用中，这样就保证了开发与应用的 Swift 版本一致。由于 libswiftCore.dylib 属于应用的一部分，所以也是需要签名的，而像上一段所说，能够为 Swift 的运行时库签名的证书必须创建于 iOS 8 Released 之后。这一切，都是为了提高 Swift 的兼容性，关于兼容性，强烈推荐这条 <a href="http://swifter.tips/compatibility/" target="_blank" rel="noopener">Tip</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个发生在去年年底的故事。背景是一个新规 Swift 应用处于准备发布阶段，证书由开发测试用更替为发布用， 这是两份 Team 不同的企业版证书。&lt;/p&gt;
&lt;p&gt;应用功能本身十分简单，开发测试阶段也比较顺利，几乎没有发生崩溃。然而在更替证书之后，真机测试应用时却陷入了无限崩溃的境地。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>重新启程的 2016</title>
    <link href="http://ckitakishi.com/2017/01/14/%E9%87%8D%E6%96%B0%E5%90%AF%E7%A8%8B%E7%9A%84-2016/"/>
    <id>http://ckitakishi.com/2017/01/14/重新启程的-2016/</id>
    <published>2017-01-14T10:23:17.000Z</published>
    <updated>2017-01-29T15:02:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼一月都已过半…如果说 2015 于我而言是承前启后的一年，那 2016 大概算是重新启程的一年。</p><h2 id="第一个完整的工作年"><a href="#第一个完整的工作年" class="headerlink" title="第一个完整的工作年"></a>第一个完整的工作年</h2><p>2016 是我的第一个完整工作年，有吐不完的槽，也有说不尽的感谢。</p><a id="more"></a><p>远离家乡，薪水不可观，事多，责任重，没有靠谱的工作搭档，无数次质疑自己为什么不早点做个了断，但是无法否认自己在成长，也得到了一定程度上的回报。曾一夜无眠的想过，好多事，时候未到。</p><p>年初，工作重心正式从前端转回 iOS，充满了期待。然而如果知道注定我会一个人孤独奋斗一整年，我还会这么想么～没有答案。从比 0 多一点的基础开始，搞了好多事儿，被嘲笑过日语说的烂，被以经验不足为由甩过锅…很喜欢一个词，「賛否両論」，本意是赞成与反对并存，不分优劣。我并不害怕被反对，被嘲笑（反正没人能在我的 bgm 里打败我哈哈哈，只怕 10 年后还像某些人一样活在自己的嘴里，活在自己的 yy 中（摊手。</p><p>一年的勤勉工作换来了「奨励賞」，开心，但是更期待优秀的团队，优秀的自己。</p><h2 id="认真的生活"><a href="#认真的生活" class="headerlink" title="认真的生活"></a>认真的生活</h2><p>这一年来对时间管理还是没有什么清晰的概念，很遗憾，很遗憾。</p><p>做了一些时间投入与金钱回报并不是那么成正比事，但是于我而言绝对是这一年最棒的事情之一。能够有幸参与《函数式 Swift》的翻译，于我而言绝不是能够衡量的财富，和优秀的人一起，总会想把事情做的更好一点。</p><p>认识了一群爱读书的人，文学素养浅薄的我，也算是读了一些书。</p><p>生活过得挺不错，（觉得）做饭进阶啦，游泳进阶啦，拍照也进阶啦～</p><h2 id="新年愿望"><a href="#新年愿望" class="headerlink" title="新年愿望"></a>新年愿望</h2><p>为开源社区贡献力量<br>合适的时机换工作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼一月都已过半…如果说 2015 于我而言是承前启后的一年，那 2016 大概算是重新启程的一年。&lt;/p&gt;
&lt;h2 id=&quot;第一个完整的工作年&quot;&gt;&lt;a href=&quot;#第一个完整的工作年&quot; class=&quot;headerlink&quot; title=&quot;第一个完整的工作年&quot;&gt;&lt;/a&gt;第一个完整的工作年&lt;/h2&gt;&lt;p&gt;2016 是我的第一个完整工作年，有吐不完的槽，也有说不尽的感谢。&lt;/p&gt;
    
    </summary>
    
      <category term="浮生记" scheme="http://ckitakishi.com/categories/%E6%B5%AE%E7%94%9F%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://ckitakishi.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Swift 的字符串前后缀匹配</title>
    <link href="http://ckitakishi.com/2016/11/09/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D/"/>
    <id>http://ckitakishi.com/2016/11/09/Swift字符串前后缀匹配/</id>
    <published>2016-11-08T15:18:32.000Z</published>
    <updated>2017-10-07T15:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前修改了项目中一个 increment search 的组件，最近刚好又看到下题，于是想说一说前后缀匹配的事儿～</p><p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix</a></p><p>这是一个给定字符串数组，求所有字符串最长公有前缀的问题。</p><p>直接用 <code>O(1)</code> 的额外空间来存储一个最长公有前缀，一次遍历后返回前缀字符串。这个想法自然到不需要多加解释，然而这么一写竟然击败了 100% 的 Swift 提交结果…</p><p>所以不得不提一下十分高效的 <code>hasPrefix(_:)</code> 方法，它接受一个 <code>String</code> 类型的参数并返回 <code>Bool</code> 值，这里字符串大小写敏感，且基于 Unicode 标准等价。此外，与之对应用于比较后缀字符串的方法是 <code>hasSuffix(_:)</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode 标准等价</span></span><br><span class="line"><span class="keyword">let</span> composedCafe = <span class="string">"Café"</span></span><br><span class="line"><span class="keyword">let</span> decomposedCafe = <span class="string">"Cafe\u&#123;0301&#125;"</span></span><br><span class="line"><span class="built_in">print</span>(cafe.hasPrefix(composedCafe))</span><br><span class="line"><span class="comment">// Prints "true"</span></span><br><span class="line"><span class="built_in">print</span>(cafe.hasPrefix(decomposedCafe))</span><br><span class="line"><span class="comment">// Prints "true"</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/Ckitakishi/Daily/blob/master/LeetCode14_LongestCommonPrefix.swift" target="_blank" rel="noopener"></a>                                                           </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前修改了项目中一个 increment search 的组件，最近刚好又看到下题，于是想说一说前后缀匹配的事儿～&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot; target=&quot;_
      
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://ckitakishi.com/tags/LeetCode/"/>
    
      <category term="覚書" scheme="http://ckitakishi.com/tags/%E8%A6%9A%E6%9B%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS 的看门狗机制</title>
    <link href="http://ckitakishi.com/2016/08/17/WatchDog-%E6%9C%BA%E5%88%B6/"/>
    <id>http://ckitakishi.com/2016/08/17/WatchDog-机制/</id>
    <published>2016-08-17T14:34:09.000Z</published>
    <updated>2017-10-07T15:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>应用 100% Loss 时完全无法启动，一直崩溃。彻底切断网络连接正常启动，调试模式状态下等待时间非常久，但可以启动，并伴随 UI 微卡。强烈的预感这是线程阻塞。前一段时间被 Core Data Concurrency 折腾的够呛，看见线程问题就略有些心慌。</p><a id="more"></a><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>首先看了 crash log，一如猜测，的确是卡在了主线程；意料之外的是，无数次闪退只留下了一份崩溃日志，如下所示：</p><p><img src="/images/watchdog.png" alt="WatchDog"></p><p>第一次见，读了一些资料大概才算是明白了这是怎么一回事。为了避免应用陷入错误状态导致界面无响应，Apple 设计了看门狗 (WatchDog) 机制。一旦超时，强制杀死进程。在不同的生命周期，触发看门狗机制的超时时间有所不同：</p><table><thead><tr><th>生命周期</th><th>超时时间</th></tr></thead><tbody><tr><td>启动 Launch</td><td>20 s</td></tr><tr><td>恢复 Resume</td><td>10 s</td></tr><tr><td>悬挂 Suspend</td><td>10 s</td></tr><tr><td>退出 Quit</td><td>6 s</td></tr><tr><td>后台 Background</td><td>10 min</td></tr></tbody></table><p>首先说一说异常编码，也是寓意颇深。8badf00d = ate bad food，大概是在说看门狗吃了坏的食物所以暴走了？！异常记录则表示这并不是一次崩溃（邪魅一笑：强制退出而已）。信息一栏指出时间限制为 20 s。结合应用业务来看，表层原因在于：每次启动应用，首先进行一次模版同步，在此之前需要检测登录状况，通过 RunLoop 反复尝试直到收到响应为止。然而不幸的是，这一些都发生在主线程。</p><p>同步网络请求，主线程，超长超时时间，满足这三点，一定场景下几乎必然会触发看门狗机制。</p><h3 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h3><p>合理解决方案：</p><ol><li>异步网络请求：优点很多，最重要的是可以让你无忧无虑安全地访问网络，而无需担心线程。</li><li>在非主线程中使用同步网络请求：如果异步运行你的网络代码比登天还难的话(也许你的应用是一个基于同步网络请求的大型移植项目)，退而求次，你也可以在次级线程中运行同步代码，也可以避免触发看门狗机制。</li></ol><p>此外，一部分情况下，例如这次遇到登录和模版同步时触发看门狗，事实上，即使在运用到模版时再次请求也是勉强可行的，因此姑且先跳过网络请求也可以。此时，还以使用一种我认为是相对比较差的方案：</p><ol start="3"><li>通过 RunLoop 来操控一切，一旦超过既定的超时时间，就提示用户重试或者暂时先跳过网络请求。</li></ol><p>应用的网络部分基于公司的通用框架，因此优先考虑在非主线程中进行网络请求来避免触发看门狗。</p><p>至于调试模式下为什么可以正常启动应用，完全是因为该模式下看门狗机制处于禁用状态。</p><p>此外，除了网络操作，I/O 读写文件和大规模运算等耗时任务也极有可能触发看门狗机制。合理处理线程，优化耗时任务，很大程度能避免不佳用户体验。</p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ol><li><a href="https://developer.apple.com/library/ios/qa/qa1693/_index.html" target="_blank" rel="noopener">主线程上的同步网络请求</a></li><li><a href="https://developer.apple.com/library/ios/qa/qa1592/_index.html" target="_blank" rel="noopener">调试模式不发生崩溃</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;应用 100% Loss 时完全无法启动，一直崩溃。彻底切断网络连接正常启动，调试模式状态下等待时间非常久，但可以启动，并伴随 UI 微卡。强烈的预感这是线程阻塞。前一段时间被 Core Data Concurrency 折腾的够呛，看见线程问题就略有些心慌。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>沖縄三日</title>
    <link href="http://ckitakishi.com/2015/12/08/%E6%B2%96%E7%B8%84%E4%B8%89%E6%97%A5/"/>
    <id>http://ckitakishi.com/2015/12/08/沖縄三日/</id>
    <published>2015-12-08T13:56:53.000Z</published>
    <updated>2016-02-28T13:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>期待已久的冲绳之行和不那么期待的马拉松如此而至。出发的早晨阳光特别温暖，モノレール窗子上映出身影，好暖～</p><a id="more"></a><p>到达当晚和晴儿一起吃了冲绳そば，终于吃到本土的了（笑…</p><p><img src="/images/soba.jpg" alt="沖縄ぞば"></p><p>为了这次的马拉松的平安..从 7 月渐渐开始了不科学的练习，第一次早晨出去跑了 2km<br>就累成狗，恢复了好几天。8 月底参加了昆马 10km，幸运的达成！来日后，跑过小道，跑过荒川沿岸，跑过皇居，慢慢喜欢上了跑步的感觉。</p><p>每一次跑都是坚持再坚持，也许跟自己说过一万遍再，没有完赛好遗憾…也许是练习不足，也许是 FREE 4.0 FLYKNIT 并不太适合超长距离…不管怎么说，对得起自己了。</p><p>当日，起初天高气爽，后来风雨大作。一路上吃，跑，吃，跑，冲绳黑糖是真的很好吃。赛程最后阶段，遇到热心的大叔带我跑了一段，一直跟我说坚持跑还能赶得上哟～然而弱爆了的我还是在最终［还剩 1km］的地方听到了结束的信号。运动场入口的的志愿者们夹道给了我们［最后的击掌］，6:15，今天跑了这么久～</p><p><img src="/images/marathon.jpg" alt="那覇マラソン"></p><p>赛后第二天，逛水族馆，看海。词穷的我只说得出一个形容词：美。</p><p>来馆必看的ジンベエザメ，后来才知是鲸鲨。一瞬间感到自己的渺小。</p><p><img src="/images/aquarium.jpg" alt="美ら海水族館"></p><p>三面环海的岛上，自己拍婚纱照的情侣。</p><p><img src="/images/sea.jpg" alt="海"></p><p>曾经的参天大树，如今又是另一种风韵。一起，任海风吹～</p><p><img src="/images/sea2.jpg" alt="海"></p><p>于我而言，这三天又是一场洗礼，只想一生努力，一生被爱。用一句广告语作结吧，<strong>「苦しいけど、幸せ」</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;期待已久的冲绳之行和不那么期待的马拉松如此而至。出发的早晨阳光特别温暖，モノレール窗子上映出身影，好暖～&lt;/p&gt;
    
    </summary>
    
      <category term="浮生记" scheme="http://ckitakishi.com/categories/%E6%B5%AE%E7%94%9F%E8%AE%B0/"/>
    
    
      <category term="跑步" scheme="http://ckitakishi.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
      <category term="旅行" scheme="http://ckitakishi.com/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="美食" scheme="http://ckitakishi.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
  </entry>
  
  <entry>
    <title>前向き</title>
    <link href="http://ckitakishi.com/2015/11/04/%E5%89%8D%E5%90%91%E3%81%8D/"/>
    <id>http://ckitakishi.com/2015/11/04/前向き/</id>
    <published>2015-11-04T13:54:49.000Z</published>
    <updated>2015-11-04T15:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直很很喜欢 CIH 在知乎说的一句话：这个世界上，总是有人，为梦想而活。</p><p>深以为，我是这样的人，因为还有梦想，所以无论多么失落，多么悲伤，都忍耐。</p><a id="more"></a><p>－－－－ 分割线后的吐槽 －－－－</p><p>二十多天的努力，无论如何也没想到在中期发表中只有悲剧。无论项目做的好或者坏，who care？尽管似乎整个发表只有项目还ok。<br>其他方面就真是差到爆了，这么多天日语还是这么烂。<br>开玩笑说为了以后能继续装逼，一定要好好呆在这儿好好学日语。。。<br>关于日语，竟然有种心有余而力不足的感觉，<br>以及，发表内容都是些什么鬼？没有从用户角度出发的项目介绍都是耍流氓。</p><p>身边好多人，从方方面面照顾着我们，该吊打时吊打，失落时还有安慰和鼓励，感谢。</p><p>用一个喜欢的词做为结尾吧，前向き！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直很很喜欢 CIH 在知乎说的一句话：这个世界上，总是有人，为梦想而活。&lt;/p&gt;
&lt;p&gt;深以为，我是这样的人，因为还有梦想，所以无论多么失落，多么悲伤，都忍耐。&lt;/p&gt;
    
    </summary>
    
      <category term="浮生记" scheme="http://ckitakishi.com/categories/%E6%B5%AE%E7%94%9F%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://ckitakishi.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>轻图像工具－LightImage</title>
    <link href="http://ckitakishi.com/2015/08/01/%E8%BD%BB%E5%9B%BE%E5%83%8F%E5%B7%A5%E5%85%B7%EF%BC%8DLightImage/"/>
    <id>http://ckitakishi.com/2015/08/01/轻图像工具－LightImage/</id>
    <published>2015-08-01T07:58:35.000Z</published>
    <updated>2017-10-07T15:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>LightImage 是我的毕业设计项目，但是至今暂时还是一个残次成品，仍需大力的改善。初衷是开发一款轻量级的图像处理工具，后续又扩展了简易的图像分析和像素画绘制等功能。</p><p>项目主要基于 HTML5 中的 Canvas 开发，当提及 Canvas 的时候，常常还会提到 SVG。Canvas 只能通过脚本驱动，适合像素级的图形问题处理；相比较而言 SVG 的驱动方式更加灵活，XML、CSS等都可，所以处理图形是通过元素。对于本项目而言，Canvas 是不二的选择。</p><a id="more"></a><p>项目使用了框架 Vue.js，结合曾经完成的一个数据量较大的应用来看，很优雅，很轻量，很灵活，调试也很棒，不过也遇到一些需要仔细思考的问题，生命周期，路由，页面重载等等。</p><p>答辩完后就一直想把一个多月开发过程中的心得和遇到的有意思的问题总结一下，还好之前有在 trello 上记录。下面想从三个部分来说一说～</p><h2 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a>绘画</h2><p>关于这个部分，细节的部分集中于事件处理，例如笔迹离开和进入画布需要绑定 mouseleave 和 mouseenter 事件。想要说一说的是，这里添加了我很喜欢的像素画绘制，通过倍率来模拟不同格子数的像素画布，尝试过使用单个像素放大但并适用。在这里不得不提给我带来深刻影响的像素动画作品们 <a href="http://1041uuu.tumblr.com/" target="_blank" rel="noopener">1041uuu</a>。</p><p>未来展望：使用栈保存笔画，完成撤销前进；提供自定义像素数量；以及允许添加多张画布组成动画。</p><h2 id="图像分析"><a href="#图像分析" class="headerlink" title="图像分析"></a>图像分析</h2><p>这个部分也许名不副实？（笑。起初只是想做一个图像的色彩分析，统计色彩的出现频率。依据 rgb 色彩模型，则有256^3种色彩，非常大的数字，于是将相近的色彩归位一类，由大及小最终选定了 6^3 种色彩。使用一个长度为 256 的数组存储出现次数，色彩一一对应下标 0-255，并可反向由下标推导颜色以便在页面渲染。</p><p>后来增添了灰度直方图及均衡化的直方图来表现图像的大体特征。这个部分效率受图像大小影响并不明显。</p><p>未来展望：可导出分析结果；保持效率得到更精确的结果。</p><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p>做毕设的两个月中，用于学习图像处理和使用 JavaScript 实现花了不少时间。起初大概看了看《数字图像处理》..的目录、基础和色彩相关章节，有了一点点宏观的理解，后期更具体的理解大多来自于他人文章和《数字图像处理原理与实践：基于Visual C++开发》。实现中，比较深刻的是图像剪切，有几个 jQuery 实现的插件，然而还是强迫自己写了一个纯 JavaScript 的，但至今仍不完善，将来如若有一日能够见人，打算让其作为一个独立的组件存在。</p><p>图像处理的效率随着图像增大而剧降，很 sad，也是一个改善的重点。</p><p>未来展望：结合直方图，添加曲线；可调节亮度，对比度等。</p><h2 id="有话说"><a href="#有话说" class="headerlink" title="有话说"></a>有话说</h2><p>源码完全在 <a href="https://github.com/Ckitakishi/LightImage" target="_blank" rel="noopener">Github</a></p><p>可以在 heroku 上 <a href="https://lightimage.herokuapp.com" target="_blank" rel="noopener">Tye it</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LightImage 是我的毕业设计项目，但是至今暂时还是一个残次成品，仍需大力的改善。初衷是开发一款轻量级的图像处理工具，后续又扩展了简易的图像分析和像素画绘制等功能。&lt;/p&gt;
&lt;p&gt;项目主要基于 HTML5 中的 Canvas 开发，当提及 Canvas 的时候，常常还会提到 SVG。Canvas 只能通过脚本驱动，适合像素级的图形问题处理；相比较而言 SVG 的驱动方式更加灵活，XML、CSS等都可，所以处理图形是通过元素。对于本项目而言，Canvas 是不二的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="编程" scheme="http://ckitakishi.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="web" scheme="http://ckitakishi.com/tags/web/"/>
    
      <category term="图像" scheme="http://ckitakishi.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>说说过去这半年</title>
    <link href="http://ckitakishi.com/2015/07/31/%E8%AF%B4%E8%AF%B4%E8%BF%87%E5%8E%BB%E8%BF%99%E5%8D%8A%E5%B9%B4/"/>
    <id>http://ckitakishi.com/2015/07/31/说说过去这半年/</id>
    <published>2015-07-31T14:58:17.000Z</published>
    <updated>2017-10-07T15:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>过去这半年，说实话过的蛮不错。确定了工作，结束了实习，带着不舍顺利毕业，毕业旅行。每一件事都那么难忘。</p><a id="more"></a><p>年初，犹豫和纠结最终还是没能阻挡一个小小的梦想，决定去霓虹工作。大三以前还信誓旦旦的说过就算去日本也只可能是旅行，亲爱的日语老师们估计怎么也想不到当年那个日语下手的学生尽然要去工作了～</p><p>四月底，结束了八个月的实习，最想说的是感谢，身边的人都充满了正能量。最幸福的是开发主线由 iOS 重新回到了 web 前端开发，框架开发，新产品研发，案件对应…。</p><p>六月底，毕业设计 [<a href="https://lightimage.herokuapp.com" target="_blank" rel="noopener">lightimage</a>] 和学位授予为大学划上了句号，带着满满的祝福和好几十G的毕业照跟最爱的 DUT 说再见了。</p><p>七月，伴随着江南烟雨的毕业旅行，每天早晨醒来都会想又少了一天相伴，真的舍不得。同一个屋檐下生活了四年，你们给我带来了太多，一起努力一起玩耍互相吐槽互相打击…</p><p>窗外大雨滂沱，赶在七月的尾巴，流水账一样的梳理了这半年来的发生的事情和心情。我就要带着梦想重新起航啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去这半年，说实话过的蛮不错。确定了工作，结束了实习，带着不舍顺利毕业，毕业旅行。每一件事都那么难忘。&lt;/p&gt;
    
    </summary>
    
      <category term="浮生记" scheme="http://ckitakishi.com/categories/%E6%B5%AE%E7%94%9F%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://ckitakishi.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>念念不忘</title>
    <link href="http://ckitakishi.com/2014/10/28/%E5%BF%B5%E5%BF%B5%E4%B8%8D%E5%BF%98/"/>
    <id>http://ckitakishi.com/2014/10/28/念念不忘/</id>
    <published>2014-10-28T11:19:18.000Z</published>
    <updated>2015-08-01T09:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>大连的冬天如期而至，时光匆匆…实习也马上就要进入第三个月，依然想要去南方…<br>过去的两个月，重新投入到 web 前端开发的怀抱，有种好久不见，你依然美丽的感觉。但是问题依旧是有的，幸好也会感觉到自己确确实实在进步。工作之余的生活特别规律，每天和 Q 一起或蹭网，或乱逛，或购物，偶尔也约上迪迪一起吃喝玩乐。<br>今天开始了写 jQuery 插件的征途，这个还是下一篇再说吧。［：）…］</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大连的冬天如期而至，时光匆匆…实习也马上就要进入第三个月，依然想要去南方…&lt;br&gt;过去的两个月，重新投入到 web 前端开发的怀抱，有种好久不见，你依然美丽的感觉。但是问题依旧是有的，幸好也会感觉到自己确确实实在进步。工作之余的生活特别规律，每天和 Q 一起或蹭网，或乱逛，
      
    
    </summary>
    
      <category term="浮生记" scheme="http://ckitakishi.com/categories/%E6%B5%AE%E7%94%9F%E8%AE%B0/"/>
    
    
      <category term="思考" scheme="http://ckitakishi.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="生活" scheme="http://ckitakishi.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Dream Mark的前世今生</title>
    <link href="http://ckitakishi.com/2014/07/01/dream-mark%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://ckitakishi.com/2014/07/01/dream-mark的前世今生/</id>
    <published>2014-07-01T14:28:10.000Z</published>
    <updated>2017-10-07T15:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DreamMark-的前世"><a href="#DreamMark-的前世" class="headerlink" title="DreamMark 的前世"></a>DreamMark 的前世</h2><p>DreamMark的的简介永远都是 <em>Mark our dream.</em> </p><p>起初，这源于一次激烈的讨论。“生活并不平淡，可很多东西就是记不住”，“我们大概需要借助纸和笔”，“可是，铭心的自然忘不了，其它又记了干嘛”，差一点，就再也没有然后了。“不一样的，记住可以是为了记忆，也可以是提醒”，“做梦！哪有那么神奇。”，“嗯！那就做梦吧！”，“……”。</p><p>于是，我们决定 <em>mark our dream</em> 。让梦境和梦想，为记忆添上那么一点儿不同的东西。</p><a id="more"></a><h2 id="DreamMark-的今生"><a href="#DreamMark-的今生" class="headerlink" title="DreamMark 的今生"></a>DreamMark 的今生</h2><p>半个月，每天约 3 小时，我们完成了 DreamMark 最初版的开发。</p><p>DreamMark 支持两种模式：</p><blockquote><p>涂鸦 — 给你一个画板，你可以绘出你的梦<br>拼图 — 场景 + 人物 + 情节 + 其它 = 你的梦</p></blockquote><p>DreamMark 学会了走路，但还走的不漂亮。无论是设计还是代码，我们会努力做到更好。</p><h2 id="DreamMark-相关"><a href="#DreamMark-相关" class="headerlink" title="DreamMark 相关"></a>DreamMark 相关</h2><p>所有图片均由 <a href="http://chiakiq.com/" target="_blank" rel="noopener">晴</a> 原创。<br>使用 <a href="https://www.parse.com/" target="_blank" rel="noopener">Parse</a> 提供后台服务。<br>更新在 <a href="https://github.com/Ckitakishi/DreamMark" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DreamMark-的前世&quot;&gt;&lt;a href=&quot;#DreamMark-的前世&quot; class=&quot;headerlink&quot; title=&quot;DreamMark 的前世&quot;&gt;&lt;/a&gt;DreamMark 的前世&lt;/h2&gt;&lt;p&gt;DreamMark的的简介永远都是 &lt;em&gt;Mark our dream.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;起初，这源于一次激烈的讨论。“生活并不平淡，可很多东西就是记不住”，“我们大概需要借助纸和笔”，“可是，铭心的自然忘不了，其它又记了干嘛”，差一点，就再也没有然后了。“不一样的，记住可以是为了记忆，也可以是提醒”，“做梦！哪有那么神奇。”，“嗯！那就做梦吧！”，“……”。&lt;/p&gt;
&lt;p&gt;于是，我们决定 &lt;em&gt;mark our dream&lt;/em&gt; 。让梦境和梦想，为记忆添上那么一点儿不同的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://ckitakishi.com/tags/iOS/"/>
    
      <category term="编程" scheme="http://ckitakishi.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Meziriac的砝码问题</title>
    <link href="http://ckitakishi.com/2014/04/12/meziriac%E7%9A%84%E7%A0%9D%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://ckitakishi.com/2014/04/12/meziriac的砝码问题/</id>
    <published>2014-04-12T14:46:04.000Z</published>
    <updated>2017-10-07T15:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…"><a href="#在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…" class="headerlink" title="在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…"></a>在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…</h4><pre><code>题目大概是:一个商去买钻石，所有钻石都&lt;=40g，他只带四个砝码和一个天平，请问四个砝码分别是多重的？</code></pre><a id="more"></a><h4 id="在车上时，考虑了四个数字加减可能出现数据数量，超过40个妥妥的，嘿嘿，使用暴力穷举？不过那时只能靠想了，设四个数为a-b-c-d，其中组合的最大值a-b-c-d-40，最小是可能就是a-b-c-d-不能等于1，就假设等于2吧，然后求出四个数分别是，4，7，8，21。可惜在1-20中，16无法出现…-再一次感觉到自己弱爆了。"><a href="#在车上时，考虑了四个数字加减可能出现数据数量，超过40个妥妥的，嘿嘿，使用暴力穷举？不过那时只能靠想了，设四个数为a-b-c-d，其中组合的最大值a-b-c-d-40，最小是可能就是a-b-c-d-不能等于1，就假设等于2吧，然后求出四个数分别是，4，7，8，21。可惜在1-20中，16无法出现…-再一次感觉到自己弱爆了。" class="headerlink" title="在车上时，考虑了四个数字加减可能出现数据数量，超过40个妥妥的，嘿嘿，使用暴力穷举？不过那时只能靠想了，设四个数为a,b,c,d，其中组合的最大值a+b+c+d=40，最小是可能就是a-b-c-d,不能等于1，就假设等于2吧，然后求出四个数分别是，4，7，8，21。可惜在1-20中，16无法出现….再一次感觉到自己弱爆了。"></a>在车上时，考虑了四个数字加减可能出现数据数量，超过40个妥妥的，嘿嘿，使用暴力穷举？不过那时只能靠想了，设四个数为a,b,c,d，其中组合的最大值a+b+c+d=40，最小是可能就是a-b-c-d,不能等于1，就假设等于2吧，然后求出四个数分别是，4，7，8，21。可惜在1-20中，16无法出现….再一次感觉到自己弱爆了。</h4><h4 id="现在，除了穷举，还可以有以下方法。"><a href="#现在，除了穷举，还可以有以下方法。" class="headerlink" title="现在，除了穷举，还可以有以下方法。"></a>现在，除了穷举，还可以有以下方法。</h4><pre><code>方法一：可以考虑三进制，把0，1，2转化为-1，0，1就可以很好的表示砝码的问题了。方法二：（可以理解为由小及大么）1是1；1，3可以组成1-4；1，3，9可以组成1-13；1，3，9，27可以组成1-40。</code></pre><h4 id="觉得现在的思考能力真心还不如以前了，还是应该多思考些问题才好T-T。"><a href="#觉得现在的思考能力真心还不如以前了，还是应该多思考些问题才好T-T。" class="headerlink" title="觉得现在的思考能力真心还不如以前了，还是应该多思考些问题才好T_T。"></a>觉得现在的思考能力真心还不如以前了，还是应该多思考些问题才好T_T。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…&quot;&gt;&lt;a href=&quot;#在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…&quot; class=&quot;headerlink&quot; title=&quot;在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…&quot;&gt;&lt;/a&gt;在回学校的车上人超多，默默的在想砝码的那道题。下午那道题答的实在是…图样图森破…&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;题目大概是:
一个商去买钻石，所有钻石都&amp;lt;=40g，他只带四个砝码和一个天平，请问四个砝码分别是多重的？
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="求索集" scheme="http://ckitakishi.com/categories/%E6%B1%82%E7%B4%A2%E9%9B%86/"/>
    
    
      <category term="编程" scheme="http://ckitakishi.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数学" scheme="http://ckitakishi.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="思考" scheme="http://ckitakishi.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>诞生日</title>
    <link href="http://ckitakishi.com/2014/04/03/%E8%AF%9E%E7%94%9F%E6%97%A5/"/>
    <id>http://ckitakishi.com/2014/04/03/诞生日/</id>
    <published>2014-04-03T10:28:07.000Z</published>
    <updated>2015-08-01T09:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>人间四月天，转眼又一年。还没等到大连的莺飞草长，就已经迈过了二十一的坎，生日快乐~(*^^)v   –关于生日，记忆中大概只有美好吧~</p><p>小时候，每年生日都会拍一张照片，记录成长；小学时，生日是全班同学的聚会，一起玩整整一晚上，在烧烤摊high完才各回各家。中学时，每一年的生日都有父母相伴，生日礼物开始不再是文具；不得不提的高三，我们会为每一位同学庆祝生日，终生难忘。</p><a id="more"></a><p>今年生日前一直向<a href="chiakiq.com">晴</a>吐槽，说自己慢慢不年轻了……晴表示巨无语。有时候会为大学的某些阶段没有珍惜时光感到遗憾，尤其是在参加阿里的笔试后，凄惨的处女笔。。。发自内心的说，这是一个很珍贵的年纪，能够比过几年更快的更有精力的学习一些东西，也能够参透一些曾经不懂的东西。</p><p>感谢祝福我的大家，么么哒~爸妈今年送了一支LAMY Safari 和一块表，很喜欢，很惊喜。还有晴的礼物们，瞬间提升文艺程度！还有收到书，拜仁周边啦~~什么的~都很符合我的口味。</p><hr><p>不曾忘记初心，无论如何，我都会一直为之努力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人间四月天，转眼又一年。还没等到大连的莺飞草长，就已经迈过了二十一的坎，生日快乐~(*^^)v   –关于生日，记忆中大概只有美好吧~&lt;/p&gt;
&lt;p&gt;小时候，每年生日都会拍一张照片，记录成长；小学时，生日是全班同学的聚会，一起玩整整一晚上，在烧烤摊high完才各回各家。中学时，每一年的生日都有父母相伴，生日礼物开始不再是文具；不得不提的高三，我们会为每一位同学庆祝生日，终生难忘。&lt;/p&gt;
    
    </summary>
    
      <category term="浮生记" scheme="http://ckitakishi.com/categories/%E6%B5%AE%E7%94%9F%E8%AE%B0/"/>
    
    
      <category term="生活" scheme="http://ckitakishi.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="喜悦" scheme="http://ckitakishi.com/tags/%E5%96%9C%E6%82%A6/"/>
    
  </entry>
  
</feed>
