<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Ckitakishi.playground"/><link rel="canonical" href="ckitakishi.com/posts/TIL-%E5%B9%B4%E5%A4%8D%E4%B8%80%E5%B9%B4%E6%84%8F%E8%AF%86%E5%88%B0%E6%88%90%E9%95%BF%E7%9A%84%E5%9 ... E6%9C%88"/><meta name="twitter:url" content="ckitakishi.com/posts/TIL-%E5%B9%B4%E5%A4%8D%E4%B8%80%E5%B9%B4%E6%84%8F%E8%AF%86%E5%88%B0%E6%88%90%E9%95%BF%E7%9A%84%E5%9 ... E6%9C%88"/><meta name="og:url" content="ckitakishi.com/posts/TIL-%E5%B9%B4%E5%A4%8D%E4%B8%80%E5%B9%B4%E6%84%8F%E8%AF%86%E5%88%B0%E6%88%90%E9%95%BF%E7%9A%84%E5%9 ... E6%9C%88"/><title>[TIL] 年复一年意识到成长的四月 | Ckitakishi.playground</title><meta name="twitter:title" content="[TIL] 年复一年意识到成长的四月 | Ckitakishi.playground"/><meta name="og:title" content="[TIL] 年复一年意识到成长的四月 | Ckitakishi.playground"/><meta name="description" content="七月主题：Uniform Type Identifier，autoreleasepool, ZIPFoundation(ZIP64), CRC32 (Cyclic redundancy check), SQL - Prepared Statement, Attributes in Swift..."/><meta name="twitter:description" content="七月主题：Uniform Type Identifier，autoreleasepool, ZIPFoundation(ZIP64), CRC32 (Cyclic redundancy check), SQL - Prepared Statement, Attributes in Swift..."/><meta name="og:description" content="七月主题：Uniform Type Identifier，autoreleasepool, ZIPFoundation(ZIP64), CRC32 (Cyclic redundancy check), SQL - Prepared Statement, Attributes in Swift..."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Ckitakishi.playground"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Ckitakishi.playground</a><nav><ul><li><a href="/">Home</a></li><li><a href="/posts" class="selected">Writing</a></li><li><a href="https://github.com/Ckitakishi?tab=repositories">Project</a></li><li><a href="/tags/求索集/">求索集</a></li><li><a href="/tags/浮生记/">浮生记</a></li><li><a href="/feed.rss">RSS</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><p>记录日常开发中遇到的 1. 新知 2. 对旧知识的新认知 3. 重新唤起的记忆 4. review 中遇到的一些有趣的问题</p><h1>04/23</h1><hr><h2>UTI - Uniform Type Identifier</h2><p>同事在分享会中详细讲了 UTI，用过很多次，但大概一直都只懂三成吧，听完后对 UTI 的理解明显更系统化了一些XD</p><p>能一瞬间想起来的运用场景有：</p><ol><li>Share Extension</li><li>Drag and Drop</li><li>Pasteboard</li></ol><p>简单来说，对于文本类型而言，扩展名可以是 <code>.txt</code> 或 <code>.text</code>，而 MIME 类型是 <code>text/plain</code>，当我们要处理文本类型时，必须将以上所有类型全部视为对象，这是一件非常缺乏效率的事情，而 UTI 就是用来处理这个问题的，他将所有类型都统一为了 <code>public.text</code>，UTI 类型和其他所有类型相互兼容。</p><p>Ref：关于自定义 UTI 类型，UTI 类型的继承性 — <a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html">https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding<em>utis/understand</em>utis<em>conc/understand</em>utis_conc.html</a></p><h1>04/20</h1><hr><h2>autoreleasepool</h2><p>最近做了一点 Objective-C 转 Swift，在 Objective-C 中我们常常会需要使用 autoreleasepool，但并不意味着遇到 Swift 之后 <code>autoreleasepool</code> 就不再需要考虑。当 Swift 调用 Objective-C 代码，亦或是 Objective-C 调用被标记为 @objc 的 Swift 方法时，如果方法返回的是 autorelease 的值，那 Swift 也会保持这个值的 autorelease 特性。</p><p>在 Objective-C 中，有时候会在循环中写 <code>autoreleasepool</code> 来避免内存爆炸，因为循环的持续会导致没有机会自动释放内存。</p><h1>04/15</h1><hr><h2>ZIPFoundation</h2><p><a href="https://thomas.zoechling.me/journal/2017/07/ZIPFoundation.html">https://thomas.zoechling.me/journal/2017/07/ZIPFoundation.html</a></p><p>A ZIP compression framework don't based on any 3rd party framework. Almost all of the swift ZIP framework based on minizip.</p><p>尽管这个框架十分简洁甚至无法完全满足要求，但作者的这篇文章还是很值得一读，在设计框架时考虑的一些点很有参考价值。</p><h2>ZIP64</h2><p><a href="https://en.wikipedia.org/wiki/ZIP_(file_format">https://en.wikipedia.org/wiki/ZIP<em>(file</em>format)#ZIP64</a>#ZIP64)</p><p>标准 ZIP 有一些限制，例如不能容纳超过 65535 个文件（因为 eocd 中只有 2 bytes 用来存 entry 的信息。。），压缩文件大小不能超过 4G 之类，因此出现了 ZIP64 标准。</p><h1>04/13</h1><hr><h2>CRC32 (Cyclic redundancy check)</h2><p>ZIP 压缩中使用的校验方式是 CRC32，是 CRC（循环冗余校验）方法中的其中一种。</p><p>记忆中第一次知道 CRC 是在密码学的课本上，奇偶校验，50% 的出错概率，还有校验和，也有不小的出错可能性，此外就是 CRC 了，因为高效且检错力很高，被广泛用在存储，压缩等之中。CRC32 是 CRC 校验中最被广泛使用的之一，但他并不是完美的，即便篡改了内容，用 CRC32 进行校验依然可能会得到相同的值。</p><p>题外话，如何在各种语言中使用 CRC32：<a href="https://rosettacode.org/wiki/CRC-32#Swift">https://rosettacode.org/wiki/CRC-32#Swift</a>。Swift 的实现法可以说并不一定实用，他选择了直接调用 zlib 中的 crc32 方法w</p><h2>Strange Date Format</h2><p>e.g. 04/01, template = "Md"</p><p>en_US ⇒ 4/1</p><p>ja_JP ⇒ 4/1</p><p>en_JP ⇒ 04/01</p><blockquote><p><a href="https://stackoverflow.com/questions/67073224/get-a-unexpected-date-string-when-setting-template-to-md">https://stackoverflow.com/questions/67073224/get-a-unexpected-date-string-when-setting-template-to-md</a></p></blockquote><p>Still don‘t know why Apple making this design..But we could resolve this <em>unexpected problem</em> by:</p><pre><code>formatter.<span class="property">dateFormat</span> = <span class="type">DateFormatter</span>.<span class="call">dateFormat</span>(
    fromTemplate: <span class="string">" Md"</span>,
    options: <span class="number">0</span>,
    locale: <span class="type">Locale</span>(identifier: <span class="string">"en_JP"</span>)
)?
.<span class="call">replacingOccurrences</span>(of: <span class="string">"MM"</span>, with: <span class="string">"M"</span>)
.<span class="call">replacingOccurrences</span>(of: <span class="string">"dd"</span>, with: <span class="string">"d"</span>)
</code></pre><h1>04/12</h1><hr><h2>SQL - Prepared Statement</h2><blockquote><p>INSERT INTO products (name, price) VALUES (?, ?);</p></blockquote><p>通常这么做的优点是：</p><ol><li>防止 SQL 注入</li><li>效率更高，避免了多次解析相同结构的 SQL 语句</li><li>...</li></ol><h1>04/08</h1><hr><h2>Attributes in Swift</h2><p>分为两类，分别是：</p><pre><code><span class="number">1</span>. <span class="keyword">@attribute</span> name
<span class="number">2</span>. <span class="keyword">@attribute</span>(attribute arguments)
</code></pre><p>今天写了写 @inline，回忆了几个常用的：</p><h3>@inline 内联</h3><p>在编译的阶段用函数体去替换函数调用。优点是可以减少函数调用的开销，但作为交换，binary size 会略有增大。</p><ul><li>@inline(_always) 强制内联（不是 100%，也有例外）</li><li>@inline(never) 无论如何都不内联</li></ul><h3>@inlinable 可内联</h3><p>和 @inline 看起来很像，但有着本质上的区别。@inlinable 可以用在 public 和 internal 的方法，计算属性等之上，这样在模块外被进行编译的时候，就会进行内联优化。虽然可以被优化，但 internal 依然是不可以被访问的，另外，当且仅但 internal 被标记为 @usableFromInline 的时候才会被作为对象。如果只存在一个模块，并没有只用 @inlinable 的必要。</p><h3>@discardableResult 可忽略的返回值</h3><p>允许有返回值的方法不返回任何值</p><h3>@available</h3><p>是一个带有参数的 attribute，用于指定最低 swift 版本，platform 的版本之类，例如我们会写 @available(swift 99) 来避免被 swift 调用，@available(iOS 14.0) 来使用 14.0 最新的 API。</p><p>Ref. <a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#">https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#</a></p><h1>04/07</h1><hr><h2>Access Photo Library</h2><p>Plist</p><ul><li>NSPhotoLibraryAddUsageDescription</li><li>NSPhotoLibraryUsageDescription</li><li>NSCameraUsageDescription</li></ul><h2>Render a UIView to a UIImage</h2><pre><code><span class="keyword">let</span> renderer = <span class="type">UIGraphicsImageRenderer</span>(size: view.<span class="property">bounds</span>.<span class="property">size</span>)
<span class="keyword">let</span> image = renderer.<span class="call">image</span> { context <span class="keyword">in</span>
    view.<span class="call">drawHierarchy</span>(in: view.<span class="property">bounds</span>, afterScreenUpdates: <span class="keyword">true</span>)
}
</code></pre><h2>Take screenshot programmatically</h2><p><a href="https://developer.apple.com/library/archive/qa/qa1703/_index.html">https://developer.apple.com/library/archive/qa/qa1703/_index.html</a> (Outdated..)</p><h1>04/06</h1><hr><h2>Multi-cursor editing in Xcode</h2><ul><li>To add a new cursor, hold Control and SHIFT then click.</li><li>Hold Control and SHIFT then ↑ or ↓</li><li>Hold Option then drag cursor around.</li></ul><h2>Formatter</h2><p><a href="https://nshipster.com/formatter/">https://nshipster.com/formatter/</a></p><p>当不设置默认 template 的情况下，会按照各 <code>locale</code> 的默认模版来显示日期。</p><p>例如：</p><pre><code><span class="comment">// JP: 2021/03/01
// KR: 2021.3.1.</span>

<span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()
formatter.<span class="property">locale</span> = locale
formatter.<span class="property">calendar</span> = <span class="type">Calendar</span>.<span class="property">autoupdatingCurrent</span>
formatter.<span class="property">dateStyle</span> = .<span class="dotAccess">short</span>
formatter.<span class="property">timeStyle</span> = .<span class="dotAccess">none</span>
</code></pre><p>这应当被认为是一个好的实践，完全可以当且仅当必要的时候为 <code>formatter</code> 设置 template。</p><h2>Detect user takes a screenshot</h2><pre><code><span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">addObserver</span>(
    <span class="keyword">self</span>,
    selector: <span class="keyword">#selector</span>(xxxxxx),
    name: <span class="type">UIApplication</span>.<span class="property">userDidTakeScreenshotNotification</span>,
    object: <span class="keyword">nil</span>
)
</code></pre><p>根据文档可以知道，这个通知的 <code>userInfo</code> 中并不包含任何信息，一个有些令人绝望的消息。考虑两个方案来获得图片。</p><ol><li>从相册读取第一张照片，多少有些 workaround 的意味，并且需要相册权限。</li><li>重新截取图片，潜在的问题是截图和系统截图可能存在差异。</li></ol><h1>04/05</h1><hr><h2>Long polling</h2><p>长轮询，与轮询的区别在于，后者是 client 定期去拉取更新，经常会得到空 response；而长轮询会 hold 住连接，直到 server 有更新才会返回。看似一种 push 的方式，本质上还是 pull。</p><h1>04/02</h1><hr><h2>XCTUnwrap()</h2><p><a href="https://www.hackingwithswift.com/example-code/testing/how-to-check-and-unwrap-optionals-in-tests-using-xctunwrap">https://www.hackingwithswift.com/example-code/testing/how-to-check-and-unwrap-optionals-in-tests-using-xctunwrap</a></p><p>Easy to read than <code>guard</code> and <code>let</code>..</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/求索集">求索集</a></li><li><a href="/tags/ios">iOS</a></li><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/til">TIL</a></li></ul></article></div><footer><p>Copyright © 2014-2022 Ckitakishi 🥑 Powered by <a href="https://github.com/johnsundell/publish">Publish</a></p></footer></body></html>