<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Support: If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.  Source: MetaX on Github 初衷常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所">
<meta name="keywords" content="iOS,图像,摄影">
<meta property="og:type" content="article">
<meta property="og:title" content="关于 MetaX 的三言两语">
<meta property="og:url" content="http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/index.html">
<meta property="og:site_name" content="Ckitakishi.playground">
<meta property="og:description" content="Support: If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.  Source: MetaX on Github 初衷常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-05-07T15:21:47.183Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于 MetaX 的三言两语">
<meta name="twitter:description" content="Support: If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.  Source: MetaX on Github 初衷常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>关于 MetaX 的三言两语</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/Ckitakishi?tab=repositories">Projects</a></li>
         
          <li><a href="/categories/浮生记/">浮生记</a></li>
         
          <li><a href="/categories/求索集/">求索集</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/23/Memory-warning-大隐隐于市/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/03/14/回顾tryswift-2018/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&text=关于 MetaX 的三言两语"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&is_video=false&description=关于 MetaX 的三言两语"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于 MetaX 的三言两语&body=Check out this article: http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&name=关于 MetaX 的三言两语&description=&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Support:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/Ckitakishi/MetaX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MetaX on Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;初衷&quot;&gt;&lt;a href=&quot;#初衷&quot; class=&quot;headerlink&quot; title=&quot;初衷&quot;&gt;&lt;/a&gt;初衷&lt;/h2&gt;&lt;p&gt;常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所以就自己动手丰衣足食了。&lt;br&gt;作为一个总结，下文的主题是照片框架 PhotoKit 和简单的问题解决记录。&lt;/p&gt;
&lt;h2 id=&quot;关于照片框架-PhotoKit&quot;&gt;&lt;a href=&quot;#关于照片框架-PhotoKit&quot; class=&quot;headerlink&quot; title=&quot;关于照片框架 - PhotoKit&quot;&gt;&lt;/a&gt;关于照片框架 - PhotoKit&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;PhotoKit&lt;/strong&gt; 之前，AssetsLibrary 是被广泛使用的，由于并没有实际用过，就不再赘述。从 &lt;strong&gt;PhotoKit&lt;/strong&gt; 的文档就可以看出来，这是一个十分庞大的框架，包含了相当多的类。&lt;strong&gt;PhotoKit&lt;/strong&gt; 可以使得自己的应用与照片库以相同流程工作，此外性能也相当不错。&lt;/p&gt;
&lt;h3 id=&quot;从获取图像开始&quot;&gt;&lt;a href=&quot;#从获取图像开始&quot; class=&quot;headerlink&quot; title=&quot;从获取图像开始&quot;&gt;&lt;/a&gt;从获取图像开始&lt;/h3&gt;&lt;h4 id=&quot;相册取得&quot;&gt;&lt;a href=&quot;#相册取得&quot; class=&quot;headerlink&quot; title=&quot;相册取得&quot;&gt;&lt;/a&gt;相册取得&lt;/h4&gt;&lt;p&gt;如果以从相册列表选取照片这个流程为例来看，相册列表中的所有对象都是 &lt;code&gt;PHCollection&lt;/code&gt;，它是一个抽象父类，拥有两个子类： &lt;code&gt;PHAssetCollection&lt;/code&gt; 和 &lt;code&gt;PHCollectionList&lt;/code&gt;，前者表示相册，后者表示相册列表也就是文件夹。题外话，在 iOS 设备上创建文件夹几乎可以说是一个隐藏功能，点击追加按钮是相册，而长按则可以选择相册或文件夹。而获取相册的方法是使用上述几个类中的 fetch 方法，返回 &lt;code&gt;PHFetchResult&amp;lt;XXX&amp;gt;&lt;/code&gt;，可以用部分与 &lt;code&gt;Foundation&lt;/code&gt; 中集合类型相同的接口来处理这个结果，比如用 &lt;code&gt;enumerateObjects(_:)&lt;/code&gt; 来进行遍历。该方法默认会取回所有结果，但是可以通过使用 &lt;code&gt;PHFetchOptions&lt;/code&gt; 来做一些过滤或是排序处理。例如取回所有智能相册：&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&t=关于 MetaX 的三言两语"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#初衷"><span class="toc-number">1.</span> <span class="toc-text">初衷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于照片框架-PhotoKit"><span class="toc-number">2.</span> <span class="toc-text">关于照片框架 - PhotoKit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从获取图像开始"><span class="toc-number">2.1.</span> <span class="toc-text">从获取图像开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相册取得"><span class="toc-number">2.1.1.</span> <span class="toc-text">相册取得</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#照片取得"><span class="toc-number">2.1.2.</span> <span class="toc-text">照片取得</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存"><span class="toc-number">2.1.3.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改图像"><span class="toc-number">2.2.</span> <span class="toc-text">修改图像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#滤镜"><span class="toc-number">2.2.1.</span> <span class="toc-text">滤镜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metadata"><span class="toc-number">2.2.2.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEIF"><span class="toc-number">2.2.3.</span> <span class="toc-text">HEIF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监听变化"><span class="toc-number">2.3.</span> <span class="toc-text">监听变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地理位置检索"><span class="toc-number">2.4.</span> <span class="toc-text">地理位置检索</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        关于 MetaX 的三言两语
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">Ckitakishi.playground</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-04-29T11:47:04.000Z" itemprop="datePublished">2018-04-29</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Projects/">Projects</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/iOS/">iOS</a>, <a class="tag-link" href="/tags/图像/">图像</a>, <a class="tag-link" href="/tags/摄影/">摄影</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p><strong>Support:</strong></p>
<p>If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.</p>
</blockquote>
<p>Source: <a href="https://github.com/Ckitakishi/MetaX" target="_blank" rel="noopener">MetaX on Github</a></p>
<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所以就自己动手丰衣足食了。<br>作为一个总结，下文的主题是照片框架 PhotoKit 和简单的问题解决记录。</p>
<h2 id="关于照片框架-PhotoKit"><a href="#关于照片框架-PhotoKit" class="headerlink" title="关于照片框架 - PhotoKit"></a>关于照片框架 - PhotoKit</h2><p>在 <strong>PhotoKit</strong> 之前，AssetsLibrary 是被广泛使用的，由于并没有实际用过，就不再赘述。从 <strong>PhotoKit</strong> 的文档就可以看出来，这是一个十分庞大的框架，包含了相当多的类。<strong>PhotoKit</strong> 可以使得自己的应用与照片库以相同流程工作，此外性能也相当不错。</p>
<h3 id="从获取图像开始"><a href="#从获取图像开始" class="headerlink" title="从获取图像开始"></a>从获取图像开始</h3><h4 id="相册取得"><a href="#相册取得" class="headerlink" title="相册取得"></a>相册取得</h4><p>如果以从相册列表选取照片这个流程为例来看，相册列表中的所有对象都是 <code>PHCollection</code>，它是一个抽象父类，拥有两个子类： <code>PHAssetCollection</code> 和 <code>PHCollectionList</code>，前者表示相册，后者表示相册列表也就是文件夹。题外话，在 iOS 设备上创建文件夹几乎可以说是一个隐藏功能，点击追加按钮是相册，而长按则可以选择相册或文件夹。而获取相册的方法是使用上述几个类中的 fetch 方法，返回 <code>PHFetchResult&lt;XXX&gt;</code>，可以用部分与 <code>Foundation</code> 中集合类型相同的接口来处理这个结果，比如用 <code>enumerateObjects(_:)</code> 来进行遍历。该方法默认会取回所有结果，但是可以通过使用 <code>PHFetchOptions</code> 来做一些过滤或是排序处理。例如取回所有智能相册：</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = <span class="type">PHFetchOptions</span>()</span><br><span class="line">options.sortDescriptors = [<span class="type">NSSortDescriptor</span>(key: <span class="string">"creationDate"</span>, ascending: <span class="literal">false</span>)]</span><br><span class="line"><span class="keyword">let</span> smartAlbums: <span class="type">PHFetchResult</span>&lt;<span class="type">PHAssetCollection</span>&gt;?</span><br><span class="line">smartAlbums = <span class="type">PHAssetCollection</span>.fetchAssetCollections(with: .smartAlbum, subtype: .albumRegular, options: options)</span><br></pre></td></tr></table></figure>
<p>智能相册由系统按照图像类型自动生成，所以并不会出现文件夹。然而，如果以系统照片库来说，还有一类相册是用户自定义相册，处理这类相册的时候必须要注意区分文件夹与相册。我选择的处理方法是暴力地用一个递归将文件夹完全平铺展开作为首级相册。</p>
<p>另外，访问图片库需要请求用户权限，在权限未决定的情况下，第一次调用 fetch 方法的时候会自动请求权限。也可以通过 <code>PHPhotoLibrary</code> 的类方法 <code>requestAuthorization:</code> 显式地发起请求。如果被拒..绝..了，添加一个类似 404 页面的视图并设置一个按钮指向应用的设置页面是 (我认为) 比较优雅的做法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="type">UIApplicationOpenSettingsURLString</span>)</span><br><span class="line"><span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url!, options: [:], completionHandler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h4 id="照片取得"><a href="#照片取得" class="headerlink" title="照片取得"></a>照片取得</h4><p>照片的取得是一个层层递进的过程，在取得了相册之后，便可以尝试获取 <code>PHAsset</code> 对象，小标题说的比较狭隘一些，实际上 <code>PHAsset</code> 对象包含图像，视频，和 Live Photo。此时可以通过调用 <code>fetchAssets(in:options:)</code> 来取得一个类型为 <code>PHFetchResult&lt;PHAsset&gt;</code> 的资源集：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assetCollection = smartAlbums.object(at: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> fetchResult = <span class="type">PHAsset</span>.fetchAssets(<span class="keyword">in</span>: assetCollection, options: options)</span><br></pre></td></tr></table></figure>
<p>手握 <code>PHAsset</code>，几乎就拥有了一切。此刻 <code>PHImageManager</code> 该出场了，这是一个专门用于请求特定 asset 对应的媒体资源的类。以请求图片为例，其中最重要的一个方法是 <code>requestImage(for:targetSize:contentMode:options:resultHandler:)</code>，通过参数就会发现，请求的同时就可以确定图片的尺寸，并进行裁剪。</p>
<p>我们还能够为这个请求设定一个类型为 <code>PHImageRequestOptions</code> 的 option，借助它的 <code>isSynchronous</code> 属性可以决定以同步还是异步的方式来发起请求；而 <code>deliverryMode</code> 则是让你们能够在图像的加载时间和质量中做一个权衡或抉择，<code>.highQualityFormat</code> 不论耗时多久都会加载原尺寸图片，<code>.fastFormat</code> 会舍弃质量来快速加载图像，<code>.opportunistic</code> 约等于前两者的和，先 <code>.fastFormat</code> 后 <code>.highQualityFormat</code>，所以会发生两次请求，但是，如果 <code>isSynchronous = true</code>，那么请求一定是 <code>.highQualityFormat</code>；还有 <code>isNetworkAccessAllowed</code>，表示是否允许从 iCloud 下载图片，如果允许，那 <code>progressHandler</code> 也会被同时调用，于是我们可以将进度体现在 UI 上。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = <span class="type">PHImageRequestOptions</span>()</span><br><span class="line">options.deliveryMode = .opportunistic</span><br><span class="line"><span class="comment">// options.isSynchronous = true</span></span><br><span class="line">options.isNetworkAccessAllowed = <span class="literal">true</span></span><br><span class="line">options.progressHandler = &#123;(progress: <span class="type">Double</span>, <span class="number">_</span>, <span class="number">_</span>, <span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imageRequestId = <span class="type">PHImageManager</span>.<span class="keyword">default</span>().requestImage(<span class="keyword">for</span>: asset, targetSize: targetSize, contentMode: .aspectFit, options: options, resultHandler: &#123; image, info <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>到这里基本上一张图片的取得就完成了。不过，如果由于一些原因请求失败或者不完整呢？在上述代码中，<code>info</code> 便是一个包含了多条可以帮助我们判断结果的信息的字典。<code>PHImageResultIsInCloudKey</code> 可以知道图像是否需要从 iCloud 下载；<code>PHImageResultIsDegradedKey</code> 意味着当前的图像是否是低质量版本；以及 <code>PHImageErrorKey</code>，顾名思义是表示了错误信息，等等。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>最后值得一提的是图片取得的缓存机制。</p>
<p>通常，在获取一张具体的图片之前，我们会先获取整个相册的所有图片做成一个列表，比如一个如同系统图片库的 collectionView，为了性能考虑，有时候会需要提前将图片载入内存，而 <code>PHImageManager</code> 有一个子类 <code>PHImageCachingManager</code> 正好可以用来做这件事。</p>
<p><code>PHImageCachingManager</code> 有两个比较重要的方法，一个是开始缓存：<code>startCachingImages(for:targetSize:contentMode:options:)</code>，另一个是停止缓存，<code>stopCachingImages(for:targetSize:contentMode:options:)</code>，彻底停止缓存时候可以使用 <code>stopCachingImagesForAllAssets()</code>。接受的参数和上面提到了请求图像几乎一样一样，而事实上在取得缓存之后，再次使用 <code>requestImage</code> 取得独立图像的时候，如果参数相同，则会从缓存中获取。</p>
<p>那究竟是将所有图像资源都放入缓存以供不时之需呢，还是仅仅是缓存一部分呢？是一开始就缓存所有资源呢，还是一边滑动一边缓存呢？时机，范围等等都是非常重要而必须要考虑的问题。推荐参考一下 Apple 的示例代码 — <a href="https://developer.apple.com/library/content/samplecode/UsingPhotosFramework/Introduction/Intro.html" target="_blank" rel="noopener">Using Photos Framework</a>，虽然这个示例 bug 有点点多，但是缓存部分的设计还是很妙的～也因此借鉴了这个部分的实现。它的设计策略在于，载入画面及画面滚动两个时机更新缓存，而区域只包括以可见部分为中心，高度为两倍的部分 (例如：可见范围 [0, 0, 768, 1024] 对应缓存区域：[-512, 0, 768, 2048])，随着画面的滑动，不停调用 <code>startCachingImages</code> 与 <code>stopCachingImages</code>，该区域也会随之改变，就像一个滑动窗口一样。</p>
<h3 id="修改图像"><a href="#修改图像" class="headerlink" title="修改图像"></a>修改图像</h3><p>按照从上到下的顺序，有关图像的框架依次是：</p>
<ul>
<li>UIKit</li>
<li>CoreImage</li>
<li>CoreGraphics</li>
<li>ImageIO</li>
</ul>
<p>下面打算讨论两个维度的图片修改，滤镜和 Metadata。接着上一部分的流程继续往下来说，虽然实现滤镜其实又很多方法，但是若选择 <strong>Core Image</strong>，那么不论哪一种，都要先通过 PHAsset 的实例方法 <code>requestContentEditingInput(with:completionHandler:)</code> 来获取完整尺寸的 <code>CIImage</code> 图像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asset.requestContentEditingInput(with: options, completionHandler: &#123; contentEditingInput, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> imageURL = contentEditingInput?.fullSizeImageURL <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> ciImageOfURL = <span class="type">CIImage</span>(contentsOf: imageURL)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> ciImage = ciImageOfURL <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h4><p>在顺利取得 <code>CIImage</code> 之后，添加滤镜的流程大致如下。<strong>Core Image</strong> 提供了一些滤镜，如果需要自定的话，看一看 WWDC2014 Session 515 会非常有帮助。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对过去版本的管理</span></span><br><span class="line"><span class="keyword">let</span> adjustmentData = <span class="type">PHAdjustmentData</span>...</span><br><span class="line">                                                  </span><br><span class="line"><span class="keyword">let</span> contentEditingOutput = <span class="type">PHContentEditingOutput</span>(contentEditingInput: contentEditingInput)</span><br><span class="line">contentEditingOutput.adjustmentData = adjustmentData</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outputImage = ciImage</span><br><span class="line">    .applyingOrientation(input.fullSizeImageOrientation)</span><br><span class="line">    .applyingFilter(<span class="built_in">filter</span>, withInputParameters: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line"><span class="type">CIContext</span>().writeJPEGRepresentation(of: outputImage,</span><br><span class="line">                                    to: contentEditingOutput.renderedContentURL, </span><br><span class="line">                                    colorSpace: ciImage.colorSpace!,</span><br><span class="line">                                    options: [:])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认修改</span></span><br><span class="line"><span class="type">PHPhotoLibrary</span>.shared().performChanges(&#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">PHAssetChangeRequest</span>(<span class="keyword">for</span>: <span class="keyword">self</span>.asset)</span><br><span class="line">    request.contentEditingOutput = contentEditingOutput</span><br><span class="line">&#125;, completionHandler: &#123; success, error <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h4><p>有了 <code>CIImage</code>，读取 Metadata 只需要获取 <code>CIImage</code> 的 <code>properties</code> 属性即可。但是如果要写入，就需要基于相对底层的 <code>ImageIO</code> 框架来完成。</p>
<p>首先，我创建了临时存储，，虽然最初的想法是直接覆盖当前编辑中的图像，这个方案在模拟器竟然成功了，但是真实设备行不通。后来迫不得已选择了迂回的方法，覆盖 =&gt; 追加新图像 + (可选)删除旧图像。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = <span class="type">CIContext</span>(options:<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个临时存储</span></span><br><span class="line"><span class="keyword">var</span> tmpUrl = <span class="type">NSURL</span>.fileURL(withPath: <span class="type">NSTemporaryDirectory</span>() + imageURL.lastPathComponent)</span><br></pre></td></tr></table></figure>
<p>为了让新创建的图像保持与原始图像相同的类型，通过 <code>CGImageSource</code> 来获取。如果获取成功，就可以指定上面的临时 URL 作为位置，尝试创建 <code>CGImageDestination</code>，之所以说是尝试，是因为不得不考虑如果当前设备并不支持期待创建的类型，那么我们就会得到 <code>nil</code>。这个时候别无选择，只能够再试一次，在当前版本中，这个做法主要是为了解决 <strong>HEIF</strong> 格式在一些较有历史的设备上并不被支持而带来的问题，所以在失败的情况下，默认将目标类型设定为 <strong>JPEG</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 CIImage 创建 CGImage</span></span><br><span class="line"><span class="keyword">let</span> cgImage = context.createCGImage(ciImage, from: ciImage.extent)</span><br><span class="line"><span class="comment">// 根据 CGImageSource 来获取图片类型标识 (UTI)</span></span><br><span class="line"><span class="keyword">let</span> cgImageSource = <span class="type">CGImageSourceCreateWithURL</span>(imageURL <span class="keyword">as</span> <span class="type">CFURL</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> sourceType = <span class="type">CGImageSourceGetType</span>(cgImageSource!) <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试创建 CGImageDestination</span></span><br><span class="line"><span class="keyword">var</span> createdDestination: <span class="type">CGImageDestination?</span> = <span class="type">CGImageDestinationCreateWithURL</span>(tmpUrl <span class="keyword">as</span> <span class="type">CFURL</span>, sourceType</span><br><span class="line">    , <span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该版本暂定方案：无法创建的图像格式就存储为 JPEG</span></span><br><span class="line"><span class="keyword">if</span> createdDestination == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// media type is unsupported: delete temp file, create new one with extension [.JPG].</span></span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">try</span>? <span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: tmpUrl)</span><br><span class="line">    tmpUrl = <span class="type">NSURL</span>.fileURL(withPath: <span class="type">NSTemporaryDirectory</span>() + imageURL.deletingPathExtension().lastPathComponent + <span class="string">".JPG"</span>)</span><br><span class="line">    createdDestination = <span class="type">CGImageDestinationCreateWithURL</span>(tmpUrl <span class="keyword">as</span> <span class="type">CFURL</span>, <span class="string">"public.jpeg"</span> <span class="keyword">as</span> <span class="type">CFString</span></span><br><span class="line">        , <span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> destination = createdDestination <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若完成了 <code>CGImageDestination</code> 创建，就可以开始向这个目标添加图像了。在上一段代码中，创建时传入的第 3 个参数正是代表着图像的数量，因为只是单张图像，所以是自然是 1；该方法也可以用来创建 GIF。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 CGImageDestination 添加图像，以及该图像的 metadata。</span></span><br><span class="line"><span class="type">CGImageDestinationAddImage</span>(destination, cgImage!, newProps <span class="keyword">as</span> <span class="type">CFDictionary</span>)</span><br><span class="line"><span class="keyword">if</span> !<span class="type">CGImageDestinationFinalize</span>(destination) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，通过仍在临时存储位置的图像来创建一个新的 asset 追加请求，并将临时存储的图像移除即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PHPhotoLibrary</span>.shared().performChanges(&#123;</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">PHAssetChangeRequest</span>.creationRequestForAssetFromImage(atFileURL: tempURL)</span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">try</span>? <span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: tempURL)</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="HEIF"><a href="#HEIF" class="headerlink" title="HEIF"></a>HEIF</h4><p><strong>HEIF</strong> 是全新的图片格式，相应的还有视频的 <strong>HEVC</strong>。苹果表示在相同画质下大小能节约 50% 的存储空间。如果想要了解更多，推荐看一看 WWDC 2017 Session 511。</p>
<p>在实际运用中遇到了一个问题，如果我在相对较旧的设备上查看 <strong>.HEIC (HEIF)</strong> 的图片，并尝试去修改它，上面提到的 <code>CGImageDestination</code> 会得到一个 <code>nil</code> 对象。结果并不意外，毕竟这需要软件与硬件双方面的支持。但是具体来说究竟分界线在哪里呢？可以在 511 找到答案，而<a href="https://support.apple.com/en-us/HT207022" target="_blank" rel="noopener">这个支持页</a>也讲的很详细。基本条件就是运行 iOS 11 的 iPhone 7 等设备以及之后的新设备。</p>
<h3 id="监听变化"><a href="#监听变化" class="headerlink" title="监听变化"></a>监听变化</h3><p>万事俱备，只欠东风。但，如果此时系统的图片库发生了改变，又该怎么办？</p>
<p>只需要记住四步，就可以解决这个问题了：</p>
<ol>
<li>让当前的类遵循 <code>PHPhotoLibraryChangeObserver</code> 协议。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailInfoViewController</span>: <span class="title">PHPhotoLibraryChangeObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在视图即将出现时将当前的类作为观察者注册到 <code>PHPhotoLibrary</code> 共享对象上。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PHPhotoLibrary</span>.shared().register(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>实现 <code>PHPhotoLibraryChangeObserver</code> 协议的 <code>photoLibraryDidChange(_:)</code><br>方法。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">photoLibraryDidChange</span><span class="params">(<span class="number">_</span> changeInstance: PHChange)</span></span> &#123;</span><br><span class="line">    <span class="comment">// changeDetails 方法有接受不同参数的多个版本，可参照文档。</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> curAsset = asset, <span class="keyword">let</span> details = changeInstance.changeDetails(<span class="keyword">for</span>: curAsset) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    asset = details.objectAfterChanges</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>最后在 <code>deinit</code> 中解除监听。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="type">PHPhotoLibrary</span>.shared().unregisterChangeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 一些笔记</span><br><span class="line"></span><br><span class="line">### <span class="type">PromiseKit</span> <span class="number">6</span> </span><br><span class="line"></span><br><span class="line"><span class="type">PromiseKit</span> <span class="number">6</span> 对几个比较核心的点做出了修改。说实话，我觉得这个框架的文档可读性其实还有待提升。直接看源码及其中的注释反而是个很好的选择。</span><br><span class="line"></span><br><span class="line">其中一点是改变了核心初始化方法：</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="type">Promise</span> &#123; fulfill, reject <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line"><span class="type">Promise</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// seal.fulfill(foo)</span></span><br><span class="line">    <span class="comment">// seal.reject(error)</span></span><br><span class="line">    <span class="comment">// seal.resolve(foo, error)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一点是，将万能的 <code>then</code> 拆分为了 <code>then</code>, <code>done</code> 和 <code>map</code>。作者的解释是，以前 <code>then</code> 做很多事，但是由于依赖 Swift 根据上下文做推断，在用了多个 <code>then</code> 之后推断就会发生失败。而且很难判断错误发生在哪。所以就只能选择从比较高的层级就修复这个问题，于是有了现在的方案：</p>
<ul>
<li><code>then</code>：返回一个 promise。</li>
<li><code>done</code>：返回一个 Void promise (80% 的情况用在 promise 链中)。</li>
<li><code>map</code>：返回非 promise 值，比如一个单纯的值。</li>
</ul>
<h3 id="地理位置检索"><a href="#地理位置检索" class="headerlink" title="地理位置检索"></a>地理位置检索</h3><p>我需要的是一个根据关键字获取相关地点的一个检索，也就是常说的 POI 检索。因为需要比较简单，所以先考虑了 <strong>MapKit</strong> 的 <code>MKLocalSearch</code> 或者 <code>MKLocalSearchCompleter</code>。</p>
<p>前者常常会用在地图的检索，通过 <code>start(completionHandler:)</code> 可以取得 10 个结果，并且这个 limit 无法自定义，它在主线程工作，而且当发起新的请求时当前即使有正在进行的检索也不会被终止，如果不注意很可能会得到错误的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localSearchRequest = <span class="type">MKLocalSearchRequest</span>()</span><br><span class="line"><span class="keyword">let</span> newestLocation = locations.last! <span class="keyword">as</span> <span class="type">CLLocation</span></span><br><span class="line">localSearchRequest.region = <span class="type">MKCoordinateRegion</span>(center: newestLocation.coordinate, span: <span class="type">MKCoordinateSpanMake</span>(<span class="number">5.0</span>, <span class="number">5.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">MKLocalSearch</span>(request: localSearchRequest).start(completionHandler: &#123; (localSearchResponse, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> searchText == searchBar.text <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>所以这似乎并不是一个理想的选择。辅以后者的 <code>MKLocalSearchCompleter</code> 会更好一些：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completer = <span class="type">MKLocalSearchCompleter</span>()</span><br><span class="line">completer.queryFragment = searchText</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: MKLocalSearchCompleter Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LocationSearchViewController</span>: <span class="title">MKLocalSearchCompleterDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理检索结果</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">completerDidUpdateResults</span><span class="params">(<span class="number">_</span> completer: MKLocalSearchCompleter)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.resultDataSource = completer.results</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">completer</span><span class="params">(<span class="number">_</span> completer: MKLocalSearchCompleter, didFailWithError error: Error)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，检索结果列表就可以很简单的表示出来了。当需要取得各个位置的详细信息时，还是无法离开 <code>MKLocalSearch</code>，根据检索结果创建请求即可。</p>
<p>不过即使这样也还是有很多制限，比如近邻检索，尝试使用了 Foursquare，虽然这个问题得以解决，但是请求数量的限制又是新的需要考虑的问题，所以，要走的路还很长。另外，由于在中国无法检索海外地点，也无法逆向转换海外经纬度，要走的路不是很长，而是很长很长。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/Ckitakishi?tab=repositories">Projects</a></li>
         
          <li><a href="/categories/浮生记/">浮生记</a></li>
         
          <li><a href="/categories/求索集/">求索集</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#初衷"><span class="toc-number">1.</span> <span class="toc-text">初衷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于照片框架-PhotoKit"><span class="toc-number">2.</span> <span class="toc-text">关于照片框架 - PhotoKit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从获取图像开始"><span class="toc-number">2.1.</span> <span class="toc-text">从获取图像开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相册取得"><span class="toc-number">2.1.1.</span> <span class="toc-text">相册取得</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#照片取得"><span class="toc-number">2.1.2.</span> <span class="toc-text">照片取得</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存"><span class="toc-number">2.1.3.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改图像"><span class="toc-number">2.2.</span> <span class="toc-text">修改图像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#滤镜"><span class="toc-number">2.2.1.</span> <span class="toc-text">滤镜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metadata"><span class="toc-number">2.2.2.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEIF"><span class="toc-number">2.2.3.</span> <span class="toc-text">HEIF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监听变化"><span class="toc-number">2.3.</span> <span class="toc-text">监听变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地理位置检索"><span class="toc-number">2.4.</span> <span class="toc-text">地理位置检索</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&text=关于 MetaX 的三言两语"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&is_video=false&description=关于 MetaX 的三言两语"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于 MetaX 的三言两语&body=Check out this article: http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&title=关于 MetaX 的三言两语"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&name=关于 MetaX 的三言两语&description=&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Support:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/Ckitakishi/MetaX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MetaX on Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;初衷&quot;&gt;&lt;a href=&quot;#初衷&quot; class=&quot;headerlink&quot; title=&quot;初衷&quot;&gt;&lt;/a&gt;初衷&lt;/h2&gt;&lt;p&gt;常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所以就自己动手丰衣足食了。&lt;br&gt;作为一个总结，下文的主题是照片框架 PhotoKit 和简单的问题解决记录。&lt;/p&gt;
&lt;h2 id=&quot;关于照片框架-PhotoKit&quot;&gt;&lt;a href=&quot;#关于照片框架-PhotoKit&quot; class=&quot;headerlink&quot; title=&quot;关于照片框架 - PhotoKit&quot;&gt;&lt;/a&gt;关于照片框架 - PhotoKit&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;PhotoKit&lt;/strong&gt; 之前，AssetsLibrary 是被广泛使用的，由于并没有实际用过，就不再赘述。从 &lt;strong&gt;PhotoKit&lt;/strong&gt; 的文档就可以看出来，这是一个十分庞大的框架，包含了相当多的类。&lt;strong&gt;PhotoKit&lt;/strong&gt; 可以使得自己的应用与照片库以相同流程工作，此外性能也相当不错。&lt;/p&gt;
&lt;h3 id=&quot;从获取图像开始&quot;&gt;&lt;a href=&quot;#从获取图像开始&quot; class=&quot;headerlink&quot; title=&quot;从获取图像开始&quot;&gt;&lt;/a&gt;从获取图像开始&lt;/h3&gt;&lt;h4 id=&quot;相册取得&quot;&gt;&lt;a href=&quot;#相册取得&quot; class=&quot;headerlink&quot; title=&quot;相册取得&quot;&gt;&lt;/a&gt;相册取得&lt;/h4&gt;&lt;p&gt;如果以从相册列表选取照片这个流程为例来看，相册列表中的所有对象都是 &lt;code&gt;PHCollection&lt;/code&gt;，它是一个抽象父类，拥有两个子类： &lt;code&gt;PHAssetCollection&lt;/code&gt; 和 &lt;code&gt;PHCollectionList&lt;/code&gt;，前者表示相册，后者表示相册列表也就是文件夹。题外话，在 iOS 设备上创建文件夹几乎可以说是一个隐藏功能，点击追加按钮是相册，而长按则可以选择相册或文件夹。而获取相册的方法是使用上述几个类中的 fetch 方法，返回 &lt;code&gt;PHFetchResult&amp;lt;XXX&amp;gt;&lt;/code&gt;，可以用部分与 &lt;code&gt;Foundation&lt;/code&gt; 中集合类型相同的接口来处理这个结果，比如用 &lt;code&gt;enumerateObjects(_:)&lt;/code&gt; 来进行遍历。该方法默认会取回所有结果，但是可以通过使用 &lt;code&gt;PHFetchOptions&lt;/code&gt; 来做一些过滤或是排序处理。例如取回所有智能相册：&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://ckitakishi.com/2018/04/29/关于-MetaX-的三言两语/&t=关于 MetaX 的三言两语"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2014-2020
    Ckitakishi
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/Ckitakishi?tab=repositories">Projects</a></li>
         
          <li><a href="/categories/浮生记/">浮生记</a></li>
         
          <li><a href="/categories/求索集/">求索集</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-107870195-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'ckitakishi';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
