<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Ckitakishi</title><description>Ckitakishi 的个人博客，多为关于 iOS 开发的所得所感与浮生杂记。</description><link>ckitakishi.com</link><language>zh</language><lastBuildDate>Tue, 19 Mar 2024 00:29:04 +0900</lastBuildDate><pubDate>Tue, 19 Mar 2024 00:29:04 +0900</pubDate><ttl>250</ttl><atom:link href="ckitakishi.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">ckitakishi.com/posts/publish-theme-palette</guid><title>为 Publish 打造一款全新的主题</title><description>最近我将博客从 Hexo 迁移到了 Publish，整个过程十分顺利，以及 Publish 本身可玩度很高，唯一美中不足的是生态系统的成长度相对较低，主题和插件的数量并不多，不过也正因如此，懒惰的我才选择了从零开始实现一款简单易扩展的主题。本文我将会围绕如何开发一款 Publish 主题进行简单讨论和 tips 分享。</description><link>ckitakishi.com/posts/publish-theme-palette</link><pubDate>Mon, 21 Mar 2022 21:30:00 +0900</pubDate><content:encoded><![CDATA[<h1>为 Publish 打造一款全新的主题</h1><p>最近我将博客从 Hexo 迁移到了 Publish，整个过程十分顺利，以及 Publish 本身可玩度很高，唯一美中不足的是生态系统的成长度相对较低，主题和插件的数量并不多，不过也正因如此，懒惰的我才选择了从零开始实现一款简单易扩展的主题。本文我将会围绕如何开发一款 Publish 主题进行简单讨论和 tips 分享。</p><h2>关于 Publish</h2><p><a href="https://github.com/JohnSundell/Publish">Publish</a> 是一款由 John Sundell 开发的纯 Swift 实现的静态页面生成框架。如果你熟悉 Node.js 驱动的 Hexo，或是 Go 实现的 Hugo 等框架，应该会非常欣喜于 Publish 为我们带来了用 Swift 搭建一个静态站点的可能性。</p><p>我们都知道构建网页并不是 Swift 擅长的领域，实现一个这样的框架绝非一件易事，至少需要考虑如何生成 HTML，如何解析 Markdown 等等。事实上，Publish 本身更像是一个骨架，它依赖于其他几个功能强大的库，例如生成 HTML 和 RSS 是 <a href="https://github.com/johnsundell/plot">Plot</a> 的工作，而 Markdown 的解析则全靠 <a href="https://github.com/johnsundell/ink">Ink</a>，其余开源库也都是非常有用的轮子。你可以在 Package.swift 中找到 Publish 的所有的依赖：</p><pre><code><span class="comment">// Package.swift</span>
dependencies: [
    <span class="string">"Ink"</span>, <span class="string">"Plot"</span>, <span class="string">"Files"</span>, <span class="string">"Codextended"</span>, <span class="string">"ShellOut"</span>, <span class="string">"Sweep"</span>
]
</code></pre><p>从工程角度来看，Publish 同样是极其出色的，它由可复用的组件构成而非不可拆分的一个整体，有充足的测试，也有完备的注释，瞬间就可以生成 DocC。这一切完全是理想中的框架该有的形态。</p><h2>快速上手 Publish</h2><p>如果你已经拥有一个由 Publish 生成的站点，可以直接跳过这一章节。即便没有也完全不用担心，差的仅仅只是三五行命令，第一步，我们需要安装 Publish 的命令行工具，最简单的方法如下：</p><pre><code class="language-no-highlight">$ git clone https://github.com/JohnSundell/Publish.git
$ cd Publish
$ make
</code></pre><p>如果你更倾向于 Homebrew，也可以通过 <code>brew install publish</code> 来完成上述步骤。命令行工具默认提供了四个可用命令：</p><pre><code class="language-no-highlight">- new: Set up a new website in the current folder.
- generate: Generate the website in the current folder.
- run: Generate and run a localhost server on default port 8000
       for the website in the current folder. Use the "-p"
       or "--port" option for customizing the default port.
- deploy: Generate and deploy the website in the current
       folder, according to its deployment method.
</code></pre><p>第二步，在指定文件夹下执行 <code>publish new</code> 来完成剩下的配置。</p><pre><code class="language-no-highlight">$ mkdir MyWebsite
$ cd MyWebsite
$ publish new
</code></pre><p>准备就绪，接着执行 <code>publish run</code>，随后就可以在 <a href="http://localhost:8000，section">http://localhost:8000</a> 看到网站的初貌啦！</p><h2>自定义主题</h2><p>读到这里你或许会感到疑惑，接下来是要开始讲述如何写 CSS 了吗？尽管以前曾短暂与 Frontend 为伴，然而时过境迁，此刻的我是如此想拥有一本《面向 iOS 开发者的 CSS 指南》。</p><p>在接下来的章节中，CSS 是一个无法跳过的话题，除此之外，我还想分享一些个人在实践中的思考和收获。下文无数次提到的 PaletteTheme 在这里～: <a href="https://github.com/Ckitakishi/PaletteTheme">https://github.com/Ckitakishi/PaletteTheme</a>。</p><h3>用 Swift Package 管理主题</h3><p>在实际开始开发之前，首先需要考虑的是用何种方式管理主题，关注点在于今后的扩展性，版本迭代和可复用与否。</p><p>这样一来，直接基于上述的 MyWebsite 进行下一步开发就不再可行。一方面，如果主题属于站点的一部分，那不容易复用和难以进行版本管理就是它与生俱来的特点。另一方面，不太恰当的开端有一定几率会诱致更多不合理的实现，以下述代码为例，<code>section</code> 是各个站点自由定义的内容，因此主题并不该知道，在主题代码中为具体的站点元素提供服务是一种本末倒置：</p><pre><code><span class="comment">// 主题模版</span>
<span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Section</span>&lt;<span class="type">Site</span>&gt;,
                        context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: section, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="type">SiteHeader</span>(context: context, selectedSelectionID: section.<span class="property">id</span>)
            <span class="keyword">if</span> section.<span class="property">id</span> == xxx { 
                <span class="comment">// 特定 section 的式样</span>
            }
            ...
        }
    )
}
</code></pre><p>换个角度来说，将主题作为一个库进行管理会是一个更加合理的方向。而站点本身是一个 Swift Package，将主题也作为一个 Swift Package 来开发可是说是不二之选。</p><p>首先，让我们来创建一个新 Package (Xcode &gt; File &gt; New &gt; Package)，并在 <code>Package.swift</code> 的 <code>dependencies</code> 中追加 Publish。</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    name: <span class="string">"PaletteTheme"</span>,
    ...
    dependencies: [
        .<span class="call">package</span>(
            name: <span class="string">"Publish"</span>,
            url: <span class="string">"https://github.com/johnsundell/publish.git"</span>,
            from: <span class="string">"0.7.0"</span>
        ),
    ],
    ...
)
</code></pre><p>然后将刚创建的主题包作为本地依赖添加到 MyWebsite 中，这么做的理由是为了即时预览和调试主题。就像下面这样：</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    name: <span class="string">"MyWebsite"</span>,
    ...
    dependencies: [
        .<span class="call">package</span>(name: <span class="string">"Publish"</span>, url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.7.0"</span>),
        .<span class="call">package</span>(path: <span class="string">"../PaletteTheme"</span>), <span class="comment">// 本地依赖</span>
    ],
    targets: [
        .<span class="call">target</span>(
            name: <span class="string">"MyWebsite"</span>,
            dependencies: [<span class="string">"Publish"</span>, <span class="string">"PaletteTheme"</span>]
        )
    ]
)
</code></pre><h3>构建主题</h3><p>一切准备就绪，接下来就可以着手于主题的构建了。本着知其然也要知其所以然的精神，首先需要了解 <code>Website</code> 协议，它定义了一些站点 URL 和名字之类的基础属性，以及构建整个站点的 pipeline 等等，任何 Publish 的站点都需要遵循该协议，在 <code>Website.swift</code> 中可以找到更多细节。</p><pre><code><span class="keyword">public protocol</span> Website {
    <span class="comment">/// The enum type used to represent the website's section IDs.</span>
    <span class="keyword">associatedtype</span> SectionID: <span class="type">WebsiteSectionID</span>
    <span class="comment">/// The type that defines any custom metadata for the website.</span>
    <span class="keyword">associatedtype</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span>

    <span class="comment">/// The absolute URL that the website will be hosted at.</span>
    <span class="keyword">var</span> url: <span class="type">URL</span> { <span class="keyword">get</span> }
    <span class="comment">/// The name of the website.</span>
    <span class="keyword">var</span> name: <span class="type">String</span> { <span class="keyword">get</span> }
    ...
}
</code></pre><p><code>Website</code> 非常基础，为了在此基础上添加更多属性和功能，显而易见我们需要扩展 <code>Website</code>。这里我选择的方案是定义一个类型别名 <code>PaletteWebsite</code>，用它来表示同时遵循 <code>Website</code> 和主题自定义协议 <code>PaletteCustomizable</code> 的类型。当然了，条条大路通罗马，比如说定义一个同时继承于 <code>Website</code> 和 <code>PaletteCustomizable</code> 的新协议也是完全可行的。</p><pre><code><span class="comment">// 类型别名</span>
<span class="keyword">public typealias</span> PaletteWebsite = <span class="type">Website</span> &amp; <span class="type">PaletteCustomizable</span>

<span class="comment">// 协议</span>
<span class="keyword">public protocol</span> PaletteWebsite: <span class="type">Website</span>, <span class="type">PaletteCustomizable</span> { }
</code></pre><p>你大概已经猜到，<code>PaletteCustomizable</code> 正是定义了主题扩充属性的协议。如果 <code>Website</code> 被称为基础模块，那我们可以将 <code>PaletteCustomizable</code> 视为扩展模组，也就是说，如果你喜欢，可以定义无数个扩展模组来让事情变得更有趣（和复杂）。</p><pre><code><span class="keyword">public protocol</span> PaletteCustomizable {
    <span class="comment">/// The self-introduction that will be displayed on the home page. Support Markdown syntax.</span>
    <span class="keyword">var</span> aboutMe: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="comment">/// The `PalettePage`s that the website will include.</span>
    <span class="keyword">var</span> pages: [<span class="type">PalettePage</span>] { <span class="keyword">get</span> }
    <span class="comment">/// The path to profile icon.</span>
    <span class="keyword">var</span> profileIconPath: <span class="type">URLRepresentable</span>? { <span class="keyword">get</span> }
    ...
}

<span class="comment">/// Default implementation</span>
<span class="keyword">public extension</span> <span class="type">PaletteCustomizable</span> {
    <span class="keyword">var</span> profileIconPath: <span class="type">URLRepresentable</span>? { <span class="keyword">nil</span> }
    ...
}
</code></pre><p>到这里 <code>PaletteWebsite</code> 的大框架就差不多完成了，进展很令人开心，下一步则是要将它运用到主题上。再度回到 Publish 源码，其中有一个名为 <code>Theme</code> 的泛型结构体定义了 Publish 主题，这里需要留意的是初始化参数 <code>htmlFactory</code>，它的类型是一个同样支持泛型的协议 <code>HTMLFactory</code>:</p><pre><code><span class="comment">// Theme</span>
<span class="keyword">public struct</span> Theme&lt;Site: <span class="type">Website</span>&gt; {
    <span class="keyword">public init</span>&lt;T: <span class="type">HTMLFactory</span>&gt;(
        htmlFactory factory: <span class="type">T</span>,
        resourcePaths resources: <span class="type">Set</span>&lt;<span class="type">Path</span>&gt; = [],
        file: <span class="type">StaticString</span> = <span class="keyword">#file</span>
    ) <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Site</span> == <span class="type">Site</span> {
        ...
    }
}

<span class="comment">// HTMLFactory</span>
<span class="keyword">public protocol</span> HTMLFactory {
    <span class="keyword">associatedtype</span> Site: <span class="type">Website</span>
    ...
}
</code></pre><p>顾名思义，<code>HTMLFactory</code> 和 HTML 的生成息息相关，它定义了六个必须实现的方法，分别用于构建六种类型的页面，例如主页，section 页面，tag 一览画面等。接下来，我们需要依次实现这六个工厂方法，在 PaletteTheme 中我定义了一个名为 <code>PaletteThemeHTMLFactory</code> 的结构体来完成这件事。</p><p>在上文中曾经提到过我们将会使用 Plot 来生成 HTML 代码，和 HTML 一样，Plot 也是一个 DSL (领域特定语言)，毕竟 Plot 算是为 HTML/XML 而生，它们的写法可是说是如出一辙。如果你对 HTML 有些许了解，那看到下述 Plot 代码一定会很自然地联想到它对应的 HTML。</p><pre><code><span class="keyword">struct</span> PaletteThemeHTMLFactory&lt;Site: <span class="type">PaletteWebsite</span>&gt;: <span class="type">HTMLFactory</span> {
    <span class="comment">// 实现所有六个方法</span>
    ...
    <span class="keyword">func</span> makePageHTML(for page: <span class="type">Page</span>,
                      context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
        <span class="type">HTML</span>(
            .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
            .<span class="call">head</span>(for: page, on: context.<span class="property">site</span>),
            .<span class="call">body</span> {
                <span class="type">SiteHeader</span>(context: context, selectedSelectionID: <span class="keyword">nil</span>)
                <span class="type">Wrapper</span>(page.<span class="property">body</span>)
                <span class="type">SiteFooter</span>()
            }
        )
    }
    ...
}
</code></pre><p>尽管看起来相似，但是 Plot 在运用了 Swift 特点的基础上还提供了更灵活的玩法，例如类型安全，流程控制和组件化。其中最重要的非组件化莫属，提到组件化就必须知道两个概念，<code>Node</code> 和 <code>Component</code>。在版本 0.9.0 之前，Plot 只提供了基于 <code>Node</code> 的方式来构建组件，<code>Node</code> 可以代表元素和属性，上一段示例代码中的 <code>.lang</code>， <code>.head</code> 和 <code>.body</code> 就是三个 <code>Node</code>。而 <code>Component</code> 则是比 <code>Node</code> 更高层次的 API，例如上述的 <code>SiteHeader</code>， 根据文档推测，这个 API 的诞生是为了提供更接近于 SwiftUI 的写法，需要留意的一点是，<code>Component</code> 目前只可以被用于定义出现在 body 之内的元素，其他 HTML 元素和非 HTML 元素需要继续使用 <code>Node</code> 来生成。</p><p><code>Node</code> 较于 <code>Component</code> 在性能方面有细微的优势，但从偏好来说我个人更喜欢后者的写法。不过无论哪种都可以帮助我们达成目的，以及，我们可以非常自由地混用二者：</p><pre><code><span class="comment">// 将 Component 集成到基于 Node 的层次结构中</span>
<span class="keyword">func</span> newsArticlePage(for article: <span class="type">NewsComponent</span>) -&gt; <span class="type">HTML</span> {
    <span class="keyword">return</span> <span class="type">HTML</span>(.<span class="call">body</span>(
        .<span class="call">div</span>(
            .<span class="call">component</span>(article)
        )
    ))
}

<span class="comment">// 在 Component 内部使用基于 Node 的元素</span>
<span class="keyword">struct</span> Banner: <span class="type">Component</span> {
    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Div</span> {
            <span class="type">Node</span>.<span class="call">h2</span>(.<span class="call">text</span>(<span class="string">"title"</span>))
        }
        .<span class="call">class</span>(<span class="string">"banner"</span>)
    }
}
</code></pre><p>关于 Plot，以上内容只不过是皮毛，文档中列举了更丰富的功能和示例：<a href="https://github.com/JohnSundell/Plot">https://github.com/JohnSundell/Plot</a>。</p><p>最后，将遵循 <code>HTMLFactory</code> 协议的 <code>PaletteThemeHTMLFactory</code> 运用到主题上即可。</p><pre><code><span class="comment">// Theme extension</span>
<span class="keyword">public extension</span> <span class="type">Theme</span> <span class="keyword">where</span> <span class="type">Site</span>: <span class="type">PaletteWebsite</span> {
    <span class="keyword">static var</span> palette: <span class="type">Self</span> {
        <span class="type">Theme</span>(
            htmlFactory: <span class="type">PaletteThemeHTMLFactory</span>(),
            resourcePaths: [<span class="string">"Resources/styles.css"</span>]
        )
    }
}
</code></pre><h3>CSS 怎么写@@</h3><p>相信此刻你应该已经拥有了一个稍显乏味的 HTML 站点，正准备开始改造页面的布局和样式。</p><p>当我还在日常与前端为伴时就觉得 CSS 完全是看似简单，实践起来不仅坑很多且有时难以顾周全，仅仅是处理多浏览器兼容这一项就足够辛苦。基于这个原因，这次我基本放弃了自己从零开始写 CSS 的想法，转而寻找一个简单易上手，能够提供多浏览器支持，响应式设计，flex 和 grid 布局等的框架。</p><p>在我的认知中，有很多框架的核心理念是提供组件，例如 Bootstrap，用户可以简单的将组件拼在一起组成一个完整的页面。在我的计划中，对特别复杂的组件并不是很有需求，反而更倾向于细粒度的框架，因此最终选择了一个以 Utility-First 为理念的框架 -- Tailwind CSS。</p><p>你可以在 <a href="https://tailwindcss.com/docs/installation">Tailwind CSS 的文档</a> 中找到导入方法。这里要注意的是，Tailwind CSS 会通过扫描文件来搜寻正在使用的 class 以生成目标 CSS 文件，这个过程不仅对 HTML 和 JavaScript 有效，即便是 Swift 也完全没有问题，务必要正确配置 <code>tailwind.config.js</code> 文件：</p><pre><code class="language-no-highlight">module.exports = {
  content: ['../Sources/**/*.swift'],
  ...
}
</code></pre><p>此外，Tailwind CSS 官方提供了一个名为 typography 的插件，用于为无法控制的 HTML 添加默认式样，例如 Markdown。其配置方法如下：</p><pre><code class="language-no-highlight">module.exports = {
  ...
  plugins: [
    require('@tailwindcss/typography'),
  ],
}
</code></pre><p>如果想要修改默认的 typography 样式，可以参照 <a href="https://github.com/tailwindlabs/tailwindcss-typography/blob/34097e0b4ec0f3124cab4a28ff0e6f4da67a5f54/src/styles.js">styles.js</a> 文件并覆盖对应属性，例如将 <code>h1</code> 标签的默认字号改为 <code>1.875rem</code>：</p><pre><code class="language-no-highlight">module.exports = {
  ...
  theme: {
    extend: {
      typography: {
        DEFAULT: {
          css: {
            h1: {
              fontSize: '1.875rem',
            },
          },
        },
      },
    },
  },
}
</code></pre><h3>代码高亮</h3><p>Tailwind CSS 的排版插件为 Markdown 生成的 HTML 提供了默认式样，不过其中并不包括代码语法高亮。Publish 列举了三种高亮代码的工具，分别是 Splash，Pygments 和 highlight.js。它们的简介和详细安装方法都可以在 Publish 的 <a href="https://github.com/JohnSundell/Publish/tree/master/Documentation/HowTo/SyntaxHighlighting">HowTo 文档</a>中找到。</p><p>最终我选择了 Splash 为 PaletteTheme 的代码块加高亮，这是一个优秀的 Swift 原生代码高亮框架，同样出自 John Sundel 之手，说不上是缺憾，不过它只支持 Swift 代码，如果你是一名多栖开发者，那这未必是一个好的选择。Pygments 和 highlight.js 都拥有更全面的语言支持，但是对 Swift 的支持相对更弱一些。</p><p>以 Splash 为例，为了灵活性，框架本身并不包含任何颜色定义，因此还需要在 CSS 文件中追加自定义的颜色代码，如下所示：</p><pre><code class="language-no-highlight">// Monokai color scheme 
pre code .keyword {
    color: #f92672;
}

pre code .type {
    color: #a6e22e;
}
</code></pre><h2>尾声</h2><p>至此，一个全新的主题就大功告成啦，这是漫漫长路上的第一步，今后可以继续为它创造更丰富的功能和插件。目前 Publish 社区比较沉寂，很多人或许还对 Publish 是否是一款可用的博客生成框架持有怀态度，希望通过这篇文章，带给了你切实的帮助亦或是一个崭新的视角。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/markdown-syntax-preview</guid><title>Markdown Syntax Sample</title><description>A Sample of basic Markdown syntax.</description><link>ckitakishi.com/posts/markdown-syntax-preview</link><pubDate>Thu, 10 Feb 2022 23:10:00 +0900</pubDate><content:encoded><![CDATA[<h1>Markdown Syntax Sample</h1><blockquote><p>Reference: <a href="https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">Github - Basic writing and formatting syntax</a></p></blockquote><h2>Headings</h2><h1>H1</h1><h2>H2</h2><h3>H3</h3><h4>H4</h4><h5>H5</h5><h6>H6</h6><hr><h2>Styling text</h2><p><strong>Bold</strong></p><p><em>Italic</em></p><p><s>Strikethrough</s></p><p><strong>Bold and <em>nested italic</em></strong></p><p><strong><em>All bold and italic</em></strong></p><hr><h2>Quoting text</h2><blockquote><p>Text that is a quote</p></blockquote><hr><h2>Quoting code</h2><h3>Code block</h3><p>To format code or text into its own distinct block, use triple backticks.</p><pre><code><span class="keyword">let</span> attributes: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>] = [
    .<span class="dotAccess">font</span>: <span class="type">UIFont</span>.<span class="call">systemFont</span>(ofSize: <span class="number">12.0</span>, weight: .<span class="dotAccess">regular</span>),
    .<span class="dotAccess">foregroundColor</span>: <span class="type">UIColor</span>.<span class="property">gray</span>,
    .<span class="dotAccess">paragraphStyle</span>: paragraphStyle
]
</code></pre><h3>Inline code</h3><p>Inline code can be formatted by using a pair of backticks, just like: <code>.paragraphStyle</code></p><hr><h2>Links</h2><p>Check more information at <a href="https://github.com/Ckitakishi/PaletteTheme">PaletteTheme</a>.</p><hr><h2>Lists</h2><p>You can make an unordered list by preceding one or more lines of text with - or *.</p><ul><li>George Washington</li><li>John Adams</li><li>Thomas Jefferson</li></ul><p>To order your list, precede each line with a number.</p><ol><li>James Madison</li><li>James Monroe</li><li>John Quincy Adams</li></ol><h3>Nested Lists</h3><p>You can create a nested list by indenting one or more list items below another item</p><ol><li>First list item<ul><li>First nested list item<ul><li>Second nested list item</li></ul></li></ul></li></ol><hr><h2>Paragraphs</h2><p>You can create a new paragraph by leaving a blank line between lines of text.</p><hr><h2>Tables</h2><table><thead><tr><th>Column 1</th><th>Column 2</th><th>Column 3</th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td></tr><tr><td>A1</td><td>B1</td><td>C1</td></tr><tr><td>A2</td><td>B2</td><td>C2</td></tr><tr><td>A3</td><td>B3</td><td>C3</td></tr></tbody></table>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/til-june</guid><title>[TIL] 与西瓜为伴的六月</title><description>六月主题：虚真论断，WWDC</description><link>ckitakishi.com/posts/til-june</link><pubDate>Thu, 1 Jul 2021 18:46:00 +0900</pubDate><content:encoded><![CDATA[<h1>[TIL] 与西瓜为伴的六月</h1><h2>06/21</h2><h3>Vacuous truth 虚真论断</h3><pre><code>[].<span class="call">allSatisfy</span> { $0 &gt; <span class="number">0</span> }   <span class="comment">// 1</span>
[].<span class="call">allSatisfy</span> { $0 &lt;= <span class="number">0</span> }  <span class="comment">// 2</span>
</code></pre><p>请回答，上面两个表达式的值是什么？ 结果是，它们的值都是 <code>true</code>，不得不承认，这多少有一些违背人的直觉。</p><p>在 swift forums 上也有人对此表示了疑惑： <a href="https://forums.swift.org/t/unexpected-behaviour-of-allsatisfy/20136">https://forums.swift.org/t/unexpected-behaviour-of-allsatisfy/20136</a></p><blockquote><p>Everything is true of the elements of the empty set.</p></blockquote><p>事实上，其中蕴含了经典的逻辑悖论：实质蕴含悖论。如果转换为中文，就是一种“如果...那么...”的关系。例如：</p><ul><li>（维基百科中记载的经典案例）如果房间里没有手机，那么所有手机都是关机状态。</li><li>（不可能发生的事情）如果回到十年前，那么我要好好学习。</li></ul><p>如果 <code>p</code> 那么 <code>q</code> 被称为 <code>p</code> 与 <code>q</code> 的蕴含式，记作 <code>p → q</code>。其真值表如下：</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p → q</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">T</td><td align="center">F</td><td align="center">F</td></tr><tr><td align="center">F</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">F</td><td align="center">F</td><td align="center">T</td></tr></tbody></table><p>综上，当集合为空（<code>p == false</code>）时，无论 <code>q</code> 是什么条件它们的蕴含式都一定为真，这也就是需真论断。蕴含式的正确并不意味着生活中一些关系的合理性，将它当作一种既定的逻辑就可以。</p><hr><h2>06/xx</h2><p>做了自己认为应当有人去做的事情，深入学习了今年 WWDC 的 Accessibility 专题，并写了以下两篇文章：</p><ul><li><a href="https://xiaozhuanlan.com/topic/7392456081">为内容丰富的应用量身打造高效 VoiceOver 体验</a></li><li><a href="https://xiaozhuanlan.com/topic/7904561328">图表的无障碍支持进阶</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/til-may</guid><title>[TIL] 梅雨提早到來的五月</title><description>五月主题：byWordWrapping - 孤独的单词，fileSystemRepresentation, stat - st_size 是什么类型, lineHeight and lineSpacing...</description><link>ckitakishi.com/posts/til-may</link><pubDate>Tue, 1 Jun 2021 00:10:00 +0900</pubDate><content:encoded><![CDATA[<h1>[TIL] 梅雨提早到來的五月</h1><p>记录日常开发中遇到的</p><ol><li>新知</li><li>对旧知识的新认知</li><li>重新唤起的记忆</li><li>review 中遇到的一些有趣的问题</li></ol><h1>05/30</h1><h2>byWordWrapping - 孤独的单词</h2><p>有一段类似下面这样的代码，和一个字符串 “This message could not be delivered”，假设 label 的宽度正好会导致字符串在 delivered 前被截断。</p><pre><code>label.<span class="property">numberOfLines</span> = <span class="number">0</span>
label.<span class="property">lineBreakMode</span> = .<span class="dotAccess">byWordWrapping</span>
</code></pre><p>这时候，下面这样的换行方式是不会出现的：</p><pre><code><span class="type">This</span> message could not be
delivered
</code></pre><p>实际上得到的字符串是以下：</p><pre><code><span class="type">This</span> message could not 
be delivered
</code></pre><p>乍一看，多少让人有些摸不着头脑，然而这是一个 Apple 刻意而为之的设计，目的在于避免孤词寡行的出现。参考链接：</p><ul><li><a href="https://stackoverflow.com/questions/46200027/uilabel-wrong-word-wrap-in-ios-11">https://stackoverflow.com/questions/46200027/uilabel-wrong-word-wrap-in-ios-11</a></li></ul><p>个人认为这是一个有趣的设计，然而并没有任何途径可以禁止这种换行方式，这多少会带来一些不便，好在从 iOS 14 开始，终于可以通过设置 <code>lineBreakStrategy</code> 来避免这样的换行。</p><pre><code><span class="keyword">if #available</span>(iOS <span class="number">14.0</span>, *) {
    label.<span class="property">lineBreakStrategy</span> = []
}
</code></pre><hr><h1>05/27</h1><h2>fileSystemRepresentation</h2><p>最近依然在为 ZIPFoundation 做 zip64 的支持，当使用 <code>fopen</code> 打开指定路径的文件时，使用的是类似下述的代码。在 POSIX 系统中直接使用 <code>UTF8String</code> 并不是一个明智的办法，使用 <code>fileSystemRepresentation</code> 先将字符串转换成文件系统的规范形式然后用 <code>UTF-8</code> 编码会比较安全。</p><pre><code><span class="keyword">let</span> representation = <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">fileSystemRepresentation</span>(withPath: path)
<span class="keyword">let</span> file: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">FILE</span>&gt; = <span class="call">fopen</span>(representation, <span class="string">"r+b"</span>)
</code></pre><p>参考链接：</p><ol><li><a href="https://objccn.io/issue-9-2/">https://objccn.io/issue-9-2/</a></li><li><a href="https://github.com/ZipArchive/ZipArchive/issues/326">https://github.com/ZipArchive/ZipArchive/issues/326</a><ul><li>这其中提到一个真实发生的案例，在 iOS 10.2 中使用 <code>UTF8String</code> 来创建文件名，很有可能在 iOS 10.3 上无法打开。这其中的原因，大概率在于 10.2 的文件系统是 <code>HFS+</code>，而 10.3 是 <code>APFS</code>。</li></ul></li></ol><hr><h1>05/19</h1><h2>stat - st_size 是什么类型</h2><p>获取文件大小的方式：</p><ol><li>FileAttributeKey</li></ol><pre><code><span class="keyword">let</span> attr = <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">attributesOfItem</span>(atPath: filePath)
<span class="keyword">let</span> fileSize = attr[<span class="type">FileAttributeKey</span>.<span class="property">size</span>] <span class="keyword">as</span>? <span class="type">UInt64</span>
</code></pre><ol start="2"><li>stat</li></ol><pre><code><span class="keyword">let</span> representation = <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">fileSystemRepresentation</span>(withPath: filePath)
<span class="keyword">var</span> fileStat = <span class="call">stat</span>()
<span class="call">lstat</span>(representation, &amp;fileStat)
<span class="keyword">let</span> fileSize = fileStat.<span class="property">st_size</span>
</code></pre><ul><li>关于 <code>st_size</code> 的类型，根据 link1，它是 <code>off_t</code>；根据 link2，<code>off_t</code> 是 <code>__darwin_off_t</code> ；根据最后一个 link，可以知道其实是 <code>int64</code> 。必须要注意的是，尽管用于表示 size，它并非一个无符号的数。<ol><li><a href="https://opensource.apple.com/source/xnu/xnu-4570.41.2/bsd/sys/stat.h.auto.html">https://opensource.apple.com/source/xnu/xnu-4570.41.2/bsd/sys/stat.h.auto.html</a></li><li><a href="https://opensource.apple.com/source/xnu/xnu-2422.1.72/bsd/sys/_types/_off_t.h.auto.html">https://opensource.apple.com/source/xnu/xnu-2422.1.72/bsd/sys/<em>types/</em>off_t.h.auto.html</a></li><li><a href="https://opensource.apple.com/source/xnu/xnu-2782.30.5/bsd/sys/_types.h.auto.html">https://opensource.apple.com/source/xnu/xnu-2782.30.5/bsd/sys/_types.h.auto.html</a></li></ol></li></ul><hr><h1>05/14</h1><h2>AVPlayer</h2><p>一篇非常简明的阐述如何使用 <code>AVPlayer</code> 的文章：</p><p><a href="https://medium.com/free-code-camp/how-to-set-up-video-streaming-in-your-app-with-avplayer-7dc21bb82f3">https://medium.com/free-code-camp/how-to-set-up-video-streaming-in-your-app-with-avplayer-7dc21bb82f3</a></p><h2>HLS - HTTP Live Streaming</h2><p>HLS 是一个 Apple 定义的流传输协议，基于 HTTP 实现，我们会发现它的后缀是 <code>.m3u8</code>，也就是用 <code>UTF-8</code> 编码的 Unicode 版本 <code>M3U</code> 。对于视频技术知之甚少的我而言又要问，那 M3U 是什么，根据维基，M3U 文件是一种纯文本文件，可以指定一个或多个多媒体文件的位置。</p><p>关于 HLS 是什么，<code>m3u8</code> 的结构是什么样，文档中的图片非常清晰易懂：<a href="https://developer.apple.com/library/archive/referencelibrary/GettingStarted/AboutHTTPLiveStreaming/about/about.html">https://developer.apple.com/library/archive/referencelibrary/GettingStarted/AboutHTTPLiveStreaming/about/about.html</a></p><p>HLS 拥有高性能，高兼容性，作为代价，切片和查询导致了较高的延迟。2019 年，Apple 介绍了</p><p><a href="[https://developer.apple.com/videos/play/wwdc2019/502/](https://developer.apple.com/videos/play/wwdc2019/502/)">ILow-Latency HLS</a>。</p><hr><h1>05/13</h1><h2>lineHeight and lineSpacing</h2><p>无法通过 <code>UILabel</code> 的属性来直接设置行高，但是可以为 Attributed String 来设置这些值。</p><p>除了 lineSpacing，我们还可以使用 lineHeight 相关的几个属性，例如:</p><pre><code>minimumLineHeight
maximumLineHeight
lineHeightMultiple
</code></pre><p>但事实上 iOS 的行高和 CSS Flexbox 中以及通常认知中的行高并不完全相同。参见下图：</p><p>所以如果需要通常意义上的行高，可以通过设置 baselineOffset 来实现。</p><pre><code><span class="keyword">let</span> paragraphStyle = <span class="type">NSMutableParagraphStyle</span>()
paragraphStyle.<span class="property">lineHeightMultiple</span> = <span class="number">1.6</span>

label.<span class="property">attributedText</span> = <span class="type">NSAttributedString</span>(
    string: <span class="string">"......"</span>,
    attributes: [
        .<span class="dotAccess">baselineOffset</span>: ......,
        .<span class="dotAccess">paragraphStyle</span>: paragraphStyle
    ]
)
</code></pre><hr><h1>05/07</h1><h2>Apple's Compression Algorithms</h2><p>当讨论一个压缩算法的时候，压缩率和速度是最重要的两个维度。</p><p>Apple 自己的压缩框架也提供了多种算法:</p><blockquote><p>WWDC2015 Session 712</p></blockquote><p>Balanced: <code>zlib</code> and <code>lzfse</code> High compression, slow: <code>lzma</code> Low compression, fast: <code>lz4</code></p><hr><h1>05/06</h1><h2>setUp()/tearDown()</h2><ul><li>instance method: each test method</li><li>class method: all test methods</li></ul><h2>globallyUniqueString</h2><p>一般来说提到唯一标志符我们常常会先想到 <code>UUID</code> ，例如用下述方法来生成独一无二的字符串：</p><pre><code><span class="type">UUID</span>().<span class="property">uuidString</span>
</code></pre><p>但如果我们需要创建临时文件，那使用进程级别的唯一字符串也不失为一个好办法。其中包含了主机名，进程 ID，时间戳，来保证其唯一性。</p><pre><code><span class="type">ProcessInfo</span>.<span class="property">processInfo</span>.<span class="property">globallyUniqueString</span>
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/til-april</guid><title>[TIL] 年复一年意识到成长的四月</title><description>七月主题：Uniform Type Identifier，autoreleasepool, ZIPFoundation(ZIP64), CRC32 (Cyclic redundancy check), SQL - Prepared Statement, Attributes in Swift...</description><link>ckitakishi.com/posts/til-april</link><pubDate>Sat, 1 May 2021 19:29:00 +0900</pubDate><content:encoded><![CDATA[<h1>[TIL] 年复一年意识到成长的四月</h1><p>记录日常开发中遇到的 1. 新知 2. 对旧知识的新认知 3. 重新唤起的记忆 4. review 中遇到的一些有趣的问题</p><h2>04/23</h2><hr><h3>UTI - Uniform Type Identifier</h3><p>同事在分享会中详细讲了 UTI，用过很多次，但大概一直都只懂三成吧，听完后对 UTI 的理解明显更系统化了一些XD</p><p>能一瞬间想起来的运用场景有：</p><ol><li>Share Extension</li><li>Drag and Drop</li><li>Pasteboard</li></ol><p>简单来说，对于文本类型而言，扩展名可以是 <code>.txt</code> 或 <code>.text</code>，而 MIME 类型是 <code>text/plain</code>，当我们要处理文本类型时，必须将以上所有类型全部视为对象，这是一件非常缺乏效率的事情，而 UTI 就是用来处理这个问题的，他将所有类型都统一为了 <code>public.text</code>，UTI 类型和其他所有类型相互兼容。</p><p>Ref：关于自定义 UTI 类型，UTI 类型的继承性 — <a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html">https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding<em>utis/understand</em>utis<em>conc/understand</em>utis_conc.html</a></p><h2>04/20</h2><hr><h3>autoreleasepool</h3><p>最近做了一点 Objective-C 转 Swift，在 Objective-C 中我们常常会需要使用 autoreleasepool，但并不意味着遇到 Swift 之后 <code>autoreleasepool</code> 就不再需要考虑。当 Swift 调用 Objective-C 代码，亦或是 Objective-C 调用被标记为 @objc 的 Swift 方法时，如果方法返回的是 autorelease 的值，那 Swift 也会保持这个值的 autorelease 特性。</p><p>在 Objective-C 中，有时候会在循环中写 <code>autoreleasepool</code> 来避免内存爆炸，因为循环的持续会导致没有机会自动释放内存。</p><h2>04/15</h2><hr><h3>ZIPFoundation</h3><p><a href="https://thomas.zoechling.me/journal/2017/07/ZIPFoundation.html">https://thomas.zoechling.me/journal/2017/07/ZIPFoundation.html</a></p><p>A ZIP compression framework don't based on any 3rd party framework. Almost all of the swift ZIP framework based on minizip.</p><p>尽管这个框架十分简洁甚至无法完全满足要求，但作者的这篇文章还是很值得一读，在设计框架时考虑的一些点很有参考价值。</p><h3>ZIP64</h3><p><a href="https://en.wikipedia.org/wiki/ZIP_(file_format)#ZIP64">https://en.wikipedia.org/wiki/ZIP<em>(file</em>format)#ZIP64</a></p><p>标准 ZIP 有一些限制，例如不能容纳超过 65535 个文件（因为 eocd 中只有 2 bytes 用来存 entry 的信息。。），压缩文件大小不能超过 4G 之类，因此出现了 ZIP64 标准。</p><h2>04/13</h2><hr><h3>CRC32 (Cyclic redundancy check)</h3><p>ZIP 压缩中使用的校验方式是 CRC32，是 CRC（循环冗余校验）方法中的其中一种。</p><p>记忆中第一次知道 CRC 是在密码学的课本上，奇偶校验，50% 的出错概率，还有校验和，也有不小的出错可能性，此外就是 CRC 了，因为高效且检错力很高，被广泛用在存储，压缩等之中。CRC32 是 CRC 校验中最被广泛使用的之一，但他并不是完美的，即便篡改了内容，用 CRC32 进行校验依然可能会得到相同的值。</p><p>题外话，如何在各种语言中使用 CRC32：<a href="https://rosettacode.org/wiki/CRC-32#Swift">https://rosettacode.org/wiki/CRC-32#Swift</a>。Swift 的实现法可以说并不一定实用，他选择了直接调用 zlib 中的 crc32 方法w</p><h3>Strange Date Format</h3><p>e.g. 04/01, template = "Md"</p><p>en_US ⇒ 4/1</p><p>ja_JP ⇒ 4/1</p><p>en_JP ⇒ 04/01</p><blockquote><p><a href="https://stackoverflow.com/questions/67073224/get-a-unexpected-date-string-when-setting-template-to-md">https://stackoverflow.com/questions/67073224/get-a-unexpected-date-string-when-setting-template-to-md</a></p></blockquote><p>Still don‘t know why Apple making this design..But we could resolve this <em>unexpected problem</em> by:</p><pre><code>formatter.<span class="property">dateFormat</span> = <span class="type">DateFormatter</span>.<span class="call">dateFormat</span>(
    fromTemplate: <span class="string">" Md"</span>,
    options: <span class="number">0</span>,
    locale: <span class="type">Locale</span>(identifier: <span class="string">"en_JP"</span>)
)?
.<span class="call">replacingOccurrences</span>(of: <span class="string">"MM"</span>, with: <span class="string">"M"</span>)
.<span class="call">replacingOccurrences</span>(of: <span class="string">"dd"</span>, with: <span class="string">"d"</span>)
</code></pre><h2>04/12</h2><hr><h3>SQL - Prepared Statement</h3><blockquote><p>INSERT INTO products (name, price) VALUES (?, ?);</p></blockquote><p>通常这么做的优点是：</p><ol><li>防止 SQL 注入</li><li>效率更高，避免了多次解析相同结构的 SQL 语句</li><li>...</li></ol><h2>04/08</h2><hr><h3>Attributes in Swift</h3><p>分为两类，分别是：</p><pre><code><span class="number">1</span>. <span class="keyword">@attribute</span> name
<span class="number">2</span>. <span class="keyword">@attribute</span>(attribute arguments)
</code></pre><p>今天写了写 @inline，回忆了几个常用的：</p><h4>@inline 内联</h4><p>在编译的阶段用函数体去替换函数调用。优点是可以减少函数调用的开销，但作为交换，binary size 会略有增大。</p><ul><li>@inline(_always) 强制内联（不是 100%，也有例外）</li><li>@inline(never) 无论如何都不内联</li></ul><h4>@inlinable 可内联</h4><p>和 @inline 看起来很像，但有着本质上的区别。@inlinable 可以用在 public 和 internal 的方法，计算属性等之上，这样在模块外被进行编译的时候，就会进行内联优化。虽然可以被优化，但 internal 依然是不可以被访问的，另外，当且仅但 internal 被标记为 @usableFromInline 的时候才会被作为对象。如果只存在一个模块，并没有只用 @inlinable 的必要。</p><h4>@discardableResult 可忽略的返回值</h4><p>允许有返回值的方法不返回任何值</p><h4>@available</h4><p>是一个带有参数的 attribute，用于指定最低 swift 版本，platform 的版本之类，例如我们会写 @available(swift 99) 来避免被 swift 调用，@available(iOS 14.0) 来使用 14.0 最新的 API。</p><p>Ref. <a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#">https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#</a></p><h2>04/07</h2><hr><h3>Access Photo Library</h3><p>Plist</p><ul><li>NSPhotoLibraryAddUsageDescription</li><li>NSPhotoLibraryUsageDescription</li><li>NSCameraUsageDescription</li></ul><h3>Render a UIView to a UIImage</h3><pre><code><span class="keyword">let</span> renderer = <span class="type">UIGraphicsImageRenderer</span>(size: view.<span class="property">bounds</span>.<span class="property">size</span>)
<span class="keyword">let</span> image = renderer.<span class="call">image</span> { context <span class="keyword">in</span>
    view.<span class="call">drawHierarchy</span>(in: view.<span class="property">bounds</span>, afterScreenUpdates: <span class="keyword">true</span>)
}
</code></pre><h3>Take screenshot programmatically</h3><p><a href="https://developer.apple.com/library/archive/qa/qa1703/_index.html">https://developer.apple.com/library/archive/qa/qa1703/_index.html</a> (Outdated..)</p><h2>04/06</h2><hr><h3>Multi-cursor editing in Xcode</h3><ul><li>To add a new cursor, hold Control and SHIFT then click.</li><li>Hold Control and SHIFT then ↑ or ↓</li><li>Hold Option then drag cursor around.</li></ul><h3>Formatter</h3><p><a href="https://nshipster.com/formatter/">https://nshipster.com/formatter/</a></p><p>当不设置默认 template 的情况下，会按照各 <code>locale</code> 的默认模版来显示日期。</p><p>例如：</p><pre><code><span class="comment">// JP: 2021/03/01
// KR: 2021.3.1.</span>

<span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()
formatter.<span class="property">locale</span> = locale
formatter.<span class="property">calendar</span> = <span class="type">Calendar</span>.<span class="property">autoupdatingCurrent</span>
formatter.<span class="property">dateStyle</span> = .<span class="dotAccess">short</span>
formatter.<span class="property">timeStyle</span> = .<span class="dotAccess">none</span>
</code></pre><p>这应当被认为是一个好的实践，完全可以当且仅当必要的时候为 <code>formatter</code> 设置 template。</p><h3>Detect user takes a screenshot</h3><pre><code><span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">addObserver</span>(
    <span class="keyword">self</span>,
    selector: <span class="keyword">#selector</span>(xxxxxx),
    name: <span class="type">UIApplication</span>.<span class="property">userDidTakeScreenshotNotification</span>,
    object: <span class="keyword">nil</span>
)
</code></pre><p>根据文档可以知道，这个通知的 <code>userInfo</code> 中并不包含任何信息，一个有些令人绝望的消息。考虑两个方案来获得图片。</p><ol><li>从相册读取第一张照片，多少有些 workaround 的意味，并且需要相册权限。</li><li>重新截取图片，潜在的问题是截图和系统截图可能存在差异。</li></ol><h2>04/05</h2><hr><h3>Long polling</h3><p>长轮询，与轮询的区别在于，后者是 client 定期去拉取更新，经常会得到空 response；而长轮询会 hold 住连接，直到 server 有更新才会返回。看似一种 push 的方式，本质上还是 pull。</p><h2>04/02</h2><hr><h3>XCTUnwrap()</h3><p><a href="https://www.hackingwithswift.com/example-code/testing/how-to-check-and-unwrap-optionals-in-tests-using-xctunwrap">https://www.hackingwithswift.com/example-code/testing/how-to-check-and-unwrap-optionals-in-tests-using-xctunwrap</a></p><p>Easy to read than <code>guard</code> and <code>let</code>..</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/2020-year-end</guid><title>2020 最后一天我在想什么</title><description>2020 回顾 &amp; 2021 期许</description><link>ckitakishi.com/posts/2020-year-end</link><pubDate>Fri, 1 Jan 2021 21:43:00 +0900</pubDate><content:encoded><![CDATA[<h1>2020 最后一天我在想什么</h1><blockquote><p>2020.12.31 / 晴</p></blockquote><h2>2020</h2><p>毕业后的几年间，大多数的年末年始都在路上或者即将启程，15 的湘南，17 的北海道，18 的川渝，19 的北陆...在一个个普通的日子里写下珍贵的记忆，让它们有了特别的意义。下午走在街上，日落将近，赶紧随手拍了一张照片来记录 2020 最后的夕日，一瞬间有些恍惚，不确定明年的此刻我是否还会记得这一天。</p><p>关于 2020，大多数人的生活或多或少都受到了一些负面影响，猜想很多人都在心中默默想过，“如果没有疫情...”，“疫情过后...”。我亦是如此，一方面这几年多了一些烦恼和忧虑，再加之长期在家的压抑，有几个月真的不太快乐，切身领会了看似普通的日子其实难能可贵这个道理。好在并不会屈服于生活带来的苦痛，而且很多事都翻篇了，又开始对新的一年有了期待（笑</p><p>不过并非一切都那么糟糕，2020 也有几件值得浓墨重彩记下一笔的事情：</p><ul><li>春节回了趟家，因为疫情哪也没去，妥妥的在家陪了家人两星期，此刻想来甚是难得。</li><li>厨艺有了进步，尤其是晴同学，如今做某几品中华料理的水平可以说是惊为天人。</li><li>在适应了新的生活/工作节奏之后，WFH 的体验变得足够令人愉悦，再加上免于通勤，有了更多悠闲（做饭，洗碗）的时间。</li><li>告别舒适圈，10 月离开了奋斗两年的团队，多亏遇到了一群很棒的同事，过去两年竟然真的觉得工作开心。在新的团队得到了更好的 WLB，下一个阶段希望自己能更有勇气一些。</li><li>赶在东京疫情爆发前跟或许多年都不再见得到的朋友去了一趟轻井泽，打了雪仗，像孩童时期一样开心（尽管孩童时期见过的雪一只手都数得过来）。</li><li>学了几个月韩语，口语稍稍记住了一些，却写不出几个对的单词，我可能是个文盲了，有愧于一直跟我说 Good Job 的老师。</li><li>动森称得上 2020 对我影响最大的游戏，和朋友们在无数个不眠的夜晚一起钓鱼砍树，还有小动物们的陪伴，在出不了门的日子里感受这种由虚拟向真实转换的温暖。</li></ul><h2>2021</h2><p>前两天看到一个豆瓣话题：你最平静放松的时刻。我想这一刻大概就是吧，可以平静且坦白的思考自己对未来的期许，简言之：</p><ul><li>保持健康良好的心情，早睡</li><li>多跟亲友联络，多交朋友</li><li>投入时间做个人产品</li><li>投资未来，保持学习</li><li>点亮新技能树（上半年就是韩语了吧）</li><li>思考之余，表达和记录自己的想法</li><li>换驾照</li><li>保持对走街串巷，摄影，料理的热情</li></ul><p>害怕着写太多实现不了明年自己看着尴尬，却还是写了那么多😂</p><p>Anyway，希望每个人都能有得偿所愿的一年。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/nsattributedstring-pt-2</guid><title>安全且优雅地使用 NSAttributedString - Part.2</title><description>在上一篇中，我们讨论了如何安全且优雅地定义一个属性字符串。不过在实际的运用场景中，情况往往会更复杂一些。在 Part.2 中将会针对更优雅地使用 `NSAttributedString` 再向前迈进一步。</description><link>ckitakishi.com/posts/nsattributedstring-pt-2</link><pubDate>Sat, 27 Jun 2020 22:59:00 +0900</pubDate><content:encoded><![CDATA[<h1>安全且优雅地使用 NSAttributedString - Part.2</h1><p>在上一篇中，我们讨论了如何安全且优雅地定义一个属性字符串。不过在实际的运用场景中，情况往往会更复杂一些。</p><p>例如，当我们需要一个由很多属性不同的部分构成的完整字符串，或者是想要实现图文混排。这个时候，不可避免的需要将所有部分组装在一起，最基础的方法是创建 <code>NSMutableAttributedString</code> ，然后通过 <code>append(_:)</code> 方法来完成字符串的构建。简单易懂是它的有点，然而不知不觉中可能就会写出类似下面这样的代码：</p><pre><code><span class="keyword">let</span> mutableAttributedString = <span class="type">NSMutableAttributedString</span>(attributedString: str1)
mutableAttributedString.<span class="call">append</span>(str2)
mutableAttributedString.<span class="call">append</span>(str3)
mutableAttributedString.<span class="call">append</span>(str4)
...
</code></pre><p>这段代码多少有一些繁重感，也不够直观，有很大的优化余地。条条大路通罗马，也许一千个开发者就有一千种改善的思路，接下来想要讨论两种更优雅的方案，分别借力于枚举 (Enum) 和 字符串插值 (StringInterpolation)。</p><h2>枚举</h2><p>和前文类似，我们完全可以再次定义一个枚举来优化代码的可读性。根据自己的需求，定义一些常用的 case，只定义字符串实在是有一些孤独，我们可以再追加一个用于插图的 case：</p><pre><code><span class="keyword">enum</span> AttributedString {
    <span class="keyword">case</span> string(<span class="type">String</span>, [<span class="type">StringAttribute</span>]?)
    <span class="keyword">case</span> image(<span class="type">UIImage</span>, offsetX: <span class="type">CGFloat</span> = <span class="number">0.0</span>, offsetY: <span class="type">CGFloat</span> = <span class="number">0.0</span>, scale: <span class="type">CGFloat</span> = <span class="number">1.0</span>)
    
    <span class="keyword">static func</span> assemble(<span class="keyword">_</span> attrStrings: [<span class="type">AttributedString</span>]) -&gt; <span class="type">NSAttributedString</span> {
        <span class="keyword">let</span> mutableAttributedString = <span class="type">NSMutableAttributedString</span>(string: <span class="string">""</span>)
        attrStrings.<span class="call">forEach</span> { (attrString: <span class="type">AttributedString</span>) <span class="keyword">in
            switch</span> attrString {
            <span class="keyword">case</span> .<span class="dotAccess">string</span>(<span class="keyword">let</span> string, <span class="keyword">let</span> attributes):
                mutableAttributedString.<span class="call">append</span>(.<span class="keyword">init</span>(string: string, attributes: attributes?.<span class="property">attributesDictionary</span>))
            <span class="keyword">case</span> .<span class="dotAccess">image</span>(<span class="keyword">let</span> image, <span class="keyword">let</span> offsetX, <span class="keyword">let</span> offsetY, <span class="keyword">let</span> scale):
                mutableAttributedString.<span class="call">append</span>(.<span class="keyword">init</span>(image: image, offsetX: offsetX, offsetY: offsetY, scale: scale))
            }
        }
        <span class="keyword">return</span> mutableAttributedString
    }
}

<span class="keyword">extension</span> <span class="type">NSAttributedString</span> {
    <span class="keyword">convenience init</span>(image: <span class="type">UIImage</span>, offsetX: <span class="type">CGFloat</span>, offsetY: <span class="type">CGFloat</span>, scale: <span class="type">CGFloat</span> = <span class="number">1.0</span>) {
        <span class="keyword">let</span> attachment = <span class="type">NSTextAttachment</span>()
        
        <span class="keyword">let</span> size: <span class="type">CGSize</span> = {
            <span class="keyword">guard</span> scale != <span class="number">1.0</span> <span class="keyword">else</span> { <span class="keyword">return</span> image.<span class="property">size</span> }
            <span class="keyword">return</span> image.<span class="property">size</span>.<span class="call">applying</span>(<span class="type">CGAffineTransform</span>(scaleX: scale, y: scale))
        }()
        
        attachment.<span class="property">bounds</span> = .<span class="keyword">init</span>(origin: .<span class="keyword">init</span>(x: offsetX, y: offsetY), size: size)
        attachment.<span class="property">image</span> = image
        
        <span class="keyword">self</span>.<span class="keyword">init</span>(attachment: attachment)
    }
}
</code></pre><p>这样一来，即简单明了，还可以避免很多晦涩且重复的代码。</p><pre><code>xxxxxx.<span class="property">attributedText</span> = <span class="type">AttributedString</span>.<span class="call">assemble</span>([
    .<span class="call">image</span>(<span class="type">UIImage</span>(named: <span class="string">"stop"</span>) ?? <span class="type">UIImage</span>(), offsetX: <span class="number">0.0</span>, offsetY: -<span class="number">8.0</span>, scale: <span class="number">0.5</span>),
    .<span class="call">string</span>(<span class="string">"踟蹰不如"</span>, [ .<span class="call">foregroundColor</span>(.<span class="dotAccess">gray</span>) ]),
    .<span class="call">string</span>(<span class="string">"停止抱歉"</span>, [ .<span class="call">foregroundColor</span>(.<span class="dotAccess">orange</span>) ])
])
</code></pre><h2>字符串插值 (StringInterpolation)</h2><p>相较于枚举，借助字符串插值的方法不会那么直观。这是一个 Swift 5 的新特性，初见之时我其实并没有彻底感受到字符串插值的强大，私以为只是能够将一些字符串的共通处理写的更优雅，尽管这也足以令人欣喜。直到很久之后读了 <a href="https://nshipster.com/expressiblebystringinterpolation/">ExpressibleByStringInterpolation</a>，才真是理解了一些字符串插值为我们带来的便利。文中关于字符串插值初级使用所举的例子十分巧妙，很优雅的避开了 <code>DateFormatter</code> 格式定义的坑。但字符串插值的能力更多体现在自定义字符串插值类型中。</p><p>由于我们期待的插值类型是属性字符串，所以我们可以从定义结构体开始着手，首先为该结构体定义一个 <code>NSAttributedString</code> 类型的属性：</p><pre><code><span class="keyword">struct</span> AttributedString {
    <span class="keyword">var</span> attributedString: <span class="type">NSAttributedString</span>
}
</code></pre><p>此时需要了解两个协议：<code>ExpressibleByStringLiteral</code> 和 <code>ExpressibleByStringInterpolation</code>，后者继承于前者，二者分别有一个必须实现的初始化方法：</p><pre><code><span class="keyword">extension</span> <span class="type">AttributedString</span>: <span class="type">ExpressibleByStringLiteral</span> {
    <span class="keyword">init</span>(stringLiteral: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">attributedString</span> = <span class="type">NSAttributedString</span>(string: stringLiteral)
    }
}

<span class="comment">// ExpressibleByStringInterpolation inherits from ExpressibleByStringLiteral</span>
<span class="keyword">extension</span> <span class="type">AttributedString</span>: <span class="type">ExpressibleByStringInterpolation</span> {
    <span class="keyword">init</span>(stringInterpolation: <span class="type">StringInterpolation</span>) {
        <span class="keyword">self</span>.<span class="property">attributedString</span> = <span class="type">NSAttributedString</span>(attributedString: stringInterpolation.<span class="property">attributedString</span>)
    }
}
</code></pre><p>字面量部分只需要初始化方法即可，插值的情况下自然会复杂一些，从初始化方法接受的参数是一个关联类型就可以看出来。<code>StringInterpolation</code> 才真正在负责在处理插值。它的工作原理是将各个组成部分通过一系列 append 方法组装起来，再作为参数传给上面的初始化方法 <code>init(stringInterpolation:)</code>。<code>appendLiteral(_:)</code> 的职责是处理普通的字符串字面量，名为 <code>appendInterpolation</code> 的方法们则是承担了处理类型五花八门的插值的任务。</p><p>在我们的例子中，就分别为字符串及其属性，图片定义了不同的 <code>appendInterpolation</code> 方法：</p><pre><code><span class="keyword">extension</span> <span class="type">AttributedString</span>: <span class="type">ExpressibleByStringInterpolation</span> {
    <span class="comment">// Custom String Interpolation Type</span>
    <span class="keyword">struct</span> StringInterpolation: <span class="type">StringInterpolationProtocol</span> {
        <span class="keyword">var</span> attributedString: <span class="type">NSMutableAttributedString</span>
        
        <span class="keyword">init</span>(literalCapacity: <span class="type">Int</span>, interpolationCount: <span class="type">Int</span>) {
            <span class="keyword">self</span>.<span class="property">attributedString</span> = <span class="type">NSMutableAttributedString</span>()
        }

        <span class="keyword">mutating func</span> appendLiteral(<span class="keyword">_</span> literal: <span class="type">String</span>) {
            <span class="keyword">let</span> attrString = <span class="type">NSAttributedString</span>(string: literal)
            <span class="keyword">self</span>.<span class="property">attributedString</span>.<span class="call">append</span>(attrString)
        }
        
        <span class="keyword">mutating func</span> appendInterpolation(<span class="keyword">_</span> string: <span class="type">String</span>, stringAttributes: [<span class="type">StringAttribute</span>]) {
            <span class="keyword">let</span> attrString = <span class="type">NSAttributedString</span>(string: string,
                                                stringAttributes: stringAttributes)
            <span class="keyword">self</span>.<span class="property">attributedString</span>.<span class="call">append</span>(attrString)
        }
        
        <span class="comment">// for UIImage</span>
        <span class="keyword">mutating func</span> appendInterpolation(image: <span class="type">UIImage</span>, offsetX: <span class="type">CGFloat</span>, offsetY: <span class="type">CGFloat</span>, scale: <span class="type">CGFloat</span> = <span class="number">1.0</span>) {
            <span class="keyword">let</span> attachment = <span class="type">NSTextAttachment</span>()
            
            <span class="keyword">let</span> size: <span class="type">CGSize</span> = {
                <span class="keyword">guard</span> scale != <span class="number">1.0</span> <span class="keyword">else</span> { <span class="keyword">return</span> image.<span class="property">size</span> }
                <span class="keyword">return</span> image.<span class="property">size</span>.<span class="call">applying</span>(<span class="type">CGAffineTransform</span>(scaleX: scale, y: scale))
            }()
            
            attachment.<span class="property">bounds</span> = .<span class="keyword">init</span>(origin: .<span class="keyword">init</span>(x: offsetX, y: offsetY), size: size)
            attachment.<span class="property">image</span> = image
        
            <span class="keyword">self</span>.<span class="property">attributedString</span>.<span class="call">append</span>(<span class="type">NSAttributedString</span>(attachment: attachment))
        }
    }
}
</code></pre><p>关于 <code>appendLiteral(_:)</code> 方法，有一点不得不说，如果想要在其中做除了 append 之外的事，务必要万分小心，除了显然可见的字面量之外，空格，换行，甚至是字符串前后的不可见部分都会受到其影响。</p><p>严格意义上我们已经完成了用字符串插值的方法来组装属性字符串，实在是有些令人激动！不如趁热打铁，顺手添加两个便利方法，一定程度上能够再提升一点点灵活度。</p><pre><code><span class="keyword">struct</span> AttributedString {
    <span class="keyword">var</span> attributedString: <span class="type">NSAttributedString</span>
    
    <span class="keyword">mutating func</span> append(<span class="keyword">_</span> newStr: <span class="type">AttributedString</span>) {
        <span class="keyword">let</span> mutableAttributedString = <span class="type">NSMutableAttributedString</span>(attributedString: attributedString)
        mutableAttributedString.<span class="call">append</span>(newStr.<span class="property">attributedString</span>)
        <span class="keyword">self</span>.<span class="property">attributedString</span> = mutableAttributedString
    }
    
    <span class="keyword">mutating func</span> append(contentsOf newStrs: [<span class="type">AttributedString</span>]) {
        <span class="keyword">let</span> mutableAttributedString = <span class="type">NSMutableAttributedString</span>(attributedString: attributedString)
        newStrs.<span class="call">forEach</span> { str <span class="keyword">in</span>
            mutableAttributedString.<span class="call">append</span>(str.<span class="property">attributedString</span>)
        }
        <span class="keyword">self</span>.<span class="property">attributedString</span> = mutableAttributedString
    }
}
</code></pre><p>到这里，组装属性字符串的过程变得优雅且灵活了一些。</p><pre><code><span class="keyword">var</span> attrString1: <span class="type">AttributedString</span> = <span class="string">"""</span>
\(<span class="string">"踟蹰不如", stringAttributes: [ .foregroundColor(.systemGray), .font(.systemFont(ofSize: 14.0)) ])</span>
\(<span class="string">"停止抱歉", stringAttributes: [ .foregroundColor(.systemGray2), .font(.systemFont(ofSize: 14.0)) ])
"""</span>

<span class="keyword">let</span> attrString2: <span class="type">AttributedString</span> = <span class="string">"""</span>
\(image<span class="string">: UIImage(named: "stop") ?? UIImage(), offsetX: 0.0, offsetY: 0.0, scale: 0.5)</span>
\(<span class="string">"再过秋天", stringAttributes: [ .foregroundColor(.systemGray3), .font(.systemFont(ofSize: 14.0)) ])</span>
\(<span class="string">"烂了蜿蜒", stringAttributes: [ .foregroundColor(.systemGray4), .font(.systemFont(ofSize: 14.0)) ])
"""</span>

attrString1.<span class="call">append</span>(attrString2)

xxxxxlabel.<span class="property">attributedText</span> = attrString1.<span class="property">attributedString</span>
</code></pre><h2>尾声</h2><p>我想很多人对属性字符串的感情应该是爱恨交织的，希望这两篇文章能为它拉回几张的票...😂</p><blockquote><p>Source Code: https://github.com/Ckitakishi/PlayWithAttributedString</p></blockquote>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/nsattributedstring-pt-1</guid><title>安全且优雅地使用 NSAttributedString - Part.1</title><description>Swift 拥有可选类型且类型安全，这些特性帮助开发者避免了很多麻烦问题。然而即便如此，在 `NSAttributedString` 的运用中同样存在着的潜在不安全因素，在 Part.1 中将会围绕如何更安全地使用 `NSAttributedString` 展开讨论。</description><link>ckitakishi.com/posts/nsattributedstring-pt-1</link><pubDate>Sat, 6 Jun 2020 14:28:00 +0900</pubDate><content:encoded><![CDATA[<h1>安全且优雅地使用 NSAttributedString - Part.1</h1><p>Swift 拥有可选类型且类型安全，这些特性帮助开发者避免了很多麻烦问题。</p><p>然而当涉及到字符串的时候，还是或多或少存在一些瑕疵。例如引用资源文件，图片文字等，一旦拼写错误，是没有办法在编译之前知道的，又或者是继续在代码中引用已经被删除的资源，也不容易被察觉。为了解决这个问题，一些知名的库应运而生，像是 <a href="https://github.com/mac-cain13/R.swift">R.swift</a>, <a href="https://github.com/SwiftGen/SwiftGen">SwiftGen</a> 之类。解决方案的其中一个核心是使得资源引用这个过程变得类型安全，以此来克服潜在的不明了性，例如：</p><pre><code><span class="comment">// normal</span>
<span class="keyword">let</span> icon = <span class="type">UIImage</span>(named: <span class="string">"settings-icon"</span>)

<span class="comment">// R.swift</span>
<span class="keyword">let</span> icon = <span class="type">R</span>.<span class="property">image</span>.<span class="call">settingsIcon</span>()
</code></pre><p>不过这次想讨论的并不是上述问题，而是在 <code>NSAttributedString</code> 的运用中同样存在着的潜在不安全因素。从我的日常体验来说，<code>NSAttributedString</code> 在无数情境之下都会被我们想起，无论是富文本支持还是图文混排，又或者是想实现一个 markdown 组件等等。</p><p>虽然我认为从 Objective-C 到 Swift，在安全问题上已经是迈进了一大步。以下面的代码为例，以往写 Objective-C 的时候，会注意避免一个预期外的 <code>nil</code> 被作为 <code>str</code> 参数传入，而引起不必要的崩溃。</p><pre><code>- (instancetype)initWithString:(<span class="type">NSString</span> *)str
</code></pre><p>对于 Swift 而言，事情会变得简单很多，可选值的声明让我们更容易做出正确的判断。</p><pre><code><span class="keyword">init</span>(string str: <span class="type">String</span>)
</code></pre><p>即便如此，关于潜在的不安全因素依然有很多话可以说，例如下面这个极其简单的例子：</p><pre><code><span class="keyword">let</span> paragraphStyle = <span class="type">NSMutableParagraphStyle</span>()
paragraphStyle.<span class="property">lineSpacing</span> = <span class="number">1.0</span>
paragraphStyle.<span class="property">lineBreakMode</span> = .<span class="dotAccess">byTruncatingTail</span>
paragraphStyle.<span class="property">alignment</span> = .<span class="dotAccess">center</span>

xxxxxx.<span class="property">attributedText</span> = <span class="type">NSAttributedString</span>(
    string: <span class="string">"卮言春天 破碎秋千"</span>,
    attributes: [
        .<span class="dotAccess">font</span>: <span class="type">UIFont</span>.<span class="call">systemFont</span>(ofSize: <span class="number">12.0</span>, weight: .<span class="dotAccess">regular</span>),
        .<span class="dotAccess">foregroundColor</span>: <span class="type">UIColor</span>.<span class="property">gray</span>,
        .<span class="dotAccess">paragraphStyle</span>: paragraphStyle
])
</code></pre><p>看完这段代码，心中应该会很容易浮现几个直击灵魂的问题：</p><ol><li>为什么为 <code>foregroundColor</code> 设置值的时候不能够省略 <code>UIColor</code>？</li><li>如果传入的不是 <code>UIColor</code> 会发生什么事情吗？</li><li><code>paragraphStyle</code> 的初始化和赋值是不是可以写的更 <code>swifty</code>？</li></ol><p>第一个问题比较简单，看值类型各式各样五花八门就会知道这大概是 <code>Any</code>，如果将 <code>attributes</code> 的初始化分离出来，这个原因会更加一目了然。</p><pre><code><span class="keyword">let</span> attributes: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>] = [
    .<span class="dotAccess">font</span>: <span class="type">UIFont</span>.<span class="call">systemFont</span>(ofSize: <span class="number">12.0</span>, weight: .<span class="dotAccess">regular</span>),
    .<span class="dotAccess">foregroundColor</span>: <span class="type">UIColor</span>.<span class="property">gray</span>,
    .<span class="dotAccess">paragraphStyle</span>: paragraphStyle
]
</code></pre><p>第二个问题完全是第一问的副作用。对于会不会发生什么事，答案是会。曾经一时失神，为 <code>paragraphStyle</code> 传入了一个 <code>CGColor</code> 的值，最可怕的在于中文和日语都可以顺利呈现出所期待的颜色，但切换成英语后应用直接就崩溃了。若遭遇这个问题，我想为了探寻原因也还是需要花一点点时间的。</p><p>为了消解这不安全感，估计大家都会想要做点什么。要么是为 <code>attributes</code> 写一段类型检查的代码通过输出 log 来避免意外，或者是封装 <code>NSAttributedString</code> 以实现类型安全。方案一略显单薄，但上述最致命的问题二是可以被圆满解决的，唯一的缺憾是在编译后才能知道结果。综上所述，不如就来实现方案二。</p><p>比较直接的想法应该是避免 <code>Any</code> 的存在，这样一来，不妨索性抛弃字典，使各个属性成为一个相对独立的存在，可以选择创建一些函数然后链式调用，但更容易浮现在脑海中的应该是用枚举去做这件事：</p><pre><code><span class="keyword">enum</span> StringAttribute {
    <span class="keyword">case</span> font(<span class="type">UIFont</span>)
    <span class="keyword">case</span> foregroundColor(<span class="type">UIColor</span>)
    <span class="keyword">case</span> underlineColor(<span class="type">UIColor</span>?) <span class="comment">// The default value is nil</span>
    <span class="keyword">case</span> kern(<span class="type">CGFloat</span>)
    <span class="comment">// ...</span>
}
</code></pre><p>在定义了上述枚举之后，基本上类型不安全的问题就得到了解决。不过作为换取类型安全的代价，需要多一道工序把 <code>StringAttribute</code> 转回 <code>[NSAttributedString.Key: Any]</code>：</p><pre><code><span class="keyword">extension</span> <span class="type">NSAttributedString</span> {
    <span class="keyword">convenience init</span>(string str: <span class="type">String</span>, stringAttributes attrs: [<span class="type">StringAttribute</span>]) {
        <span class="keyword">self</span>.<span class="keyword">init</span>(string: str, attributes: attrs.<span class="property">attributesDictionary</span>)
    }
}

<span class="keyword">enum</span> StringAttribute {
    <span class="keyword">case</span> font(<span class="type">UIFont</span>)
    <span class="keyword">case</span> foregroundColor(<span class="type">UIColor</span>)
    <span class="keyword">case</span> underlineColor(<span class="type">UIColor</span>?) <span class="comment">// The default value is nil</span>
    <span class="keyword">case</span> kern(<span class="type">CGFloat</span>)
    <span class="comment">// ...</span>
    
    <span class="keyword">var</span> keyAndValue: (<span class="type">NSAttributedString</span>.<span class="type">Key</span>, <span class="type">Any</span>?) {
        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">font</span>(<span class="keyword">let</span> value):
            <span class="keyword">return</span> (.<span class="dotAccess">font</span>, value)
        <span class="keyword">case</span> .<span class="dotAccess">foregroundColor</span>(<span class="keyword">let</span> value):
            <span class="keyword">return</span> (.<span class="dotAccess">foregroundColor</span>, value)
        <span class="keyword">case</span> .<span class="dotAccess">underlineColor</span>(<span class="keyword">let</span> optionalValue):
            <span class="keyword">return</span> (.<span class="dotAccess">underlineColor</span>, optionalValue)
        <span class="keyword">case</span> .<span class="dotAccess">kern</span>(<span class="keyword">let</span> value):
            <span class="keyword">return</span> (.<span class="dotAccess">kern</span>, value <span class="keyword">as</span> <span class="type">NSNumber</span>)
        }
        <span class="comment">// ...</span>
    }
}

<span class="keyword">extension</span> <span class="type">Array</span> <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">StringAttribute</span> {
    <span class="comment">// StringAttribute =&gt; [NSAttributedString.Key: Any]</span>
    <span class="keyword">var</span> attributesDictionary: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>] {
        <span class="keyword">var</span> attributesDict: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>] = [:]
        
        <span class="keyword">self</span>.<span class="call">forEach</span> { attribute <span class="keyword">in
            let</span> (key, value) = attribute.<span class="property">keyAndValue</span>
            attributesDict[key] = value
        }
        
        <span class="keyword">return</span> attributesDict
    }
}
</code></pre><p>到这里就大功告成了！我们可以尝试把上面的代码改写一下：</p><pre><code><span class="keyword">let</span> attributes: [<span class="type">StringAttribute</span>] = [
    .<span class="call">font</span>(.<span class="call">systemFont</span>(ofSize: <span class="number">12.0</span>, weight: .<span class="dotAccess">regular</span>)),
    .<span class="call">foregroundColor</span>(.<span class="dotAccess">gray</span>),
    .<span class="call">paragraphStyle</span>(paragraphStyle)
]
</code></pre><p>如果完整实现了 <code>StringAttribute</code> 的话，一定会留意到 <code>NSAttributedString</code> 中有一个相对特殊的属性：<code>.paragraphStyle</code>。使用它之前需要先完成一系列的初始化赋值，正是上面代码块中出现的 <code>paragraphStyle</code>。作为一个代码风格优化的可选项，这里我选择用与 <code>StringAttribute</code> 相似的手段来封装 <code>NSMutableParagraphStyle</code>。</p><pre><code><span class="keyword">enum</span> ParagraphAttribute {
    <span class="keyword">case</span> alignment(<span class="type">NSTextAlignment</span>)
    <span class="keyword">case</span> lineSpacing(<span class="type">CGFloat</span>)
    <span class="keyword">case</span> lineBreakMode(<span class="type">NSLineBreakMode</span>)
}

<span class="keyword">enum</span> StringAttribute {
    <span class="keyword">case</span> paragraphStyle([<span class="type">ParagraphAttribute</span>])
    
    <span class="keyword">var</span> keyAndValue: (<span class="type">NSAttributedString</span>.<span class="type">Key</span>, <span class="type">Any</span>?) {
        <span class="keyword">switch self</span> {
        <span class="keyword">case</span> .<span class="dotAccess">paragraphStyle</span>(<span class="keyword">let</span> value):
            <span class="keyword">return</span> (.<span class="dotAccess">paragraphStyle</span>, <span class="keyword">self</span>.<span class="call">configureParagraphStyle</span>(value))
        }
    }
    
    <span class="comment">// [ParagraphAttribute] =&gt; NSMutableParagraphStyle</span>
    <span class="keyword">private func</span> configureParagraphStyle(<span class="keyword">_</span> attributes: [<span class="type">ParagraphAttribute</span>]) -&gt; <span class="type">NSMutableParagraphStyle</span> {
        
        <span class="keyword">let</span> paragraphStyle = <span class="type">NSMutableParagraphStyle</span>()

        attributes.<span class="call">forEach</span> {
            <span class="keyword">switch</span> $0 {
            <span class="keyword">case</span> .<span class="dotAccess">alignment</span>(<span class="keyword">let</span> value):
                paragraphStyle.<span class="property">alignment</span> = value
            <span class="keyword">case</span> .<span class="dotAccess">lineSpacing</span>(<span class="keyword">let</span> value):
                paragraphStyle.<span class="property">lineSpacing</span> = value
            <span class="keyword">case</span> .<span class="dotAccess">lineBreakMode</span>(<span class="keyword">let</span> value):
                paragraphStyle.<span class="property">lineBreakMode</span> = value
            }
        }
        
        <span class="keyword">return</span> paragraphStyle
    }
}
</code></pre><p>于是，最初的代码就可以用一种更 <code>Swifty</code> 的方式来重写了。 代码风格各有所爱，就我个人来说，安全与优雅的代码着实令人感动：P</p><pre><code>xxxxxx.<span class="property">attributedText</span> = <span class="type">NSAttributedString</span>(
    string: <span class="string">"卮言春天 破碎秋千"</span>,
    stringAttributes: [
        .<span class="call">font</span>(.<span class="call">systemFont</span>(ofSize: <span class="number">12.0</span>, weight: .<span class="dotAccess">regular</span>)),
        .<span class="call">foregroundColor</span>(.<span class="dotAccess">gray</span>),
	      .<span class="call">paragraphStyle</span>([
	          .<span class="call">lineSpacing</span>(<span class="number">1.0</span>),
	          .<span class="call">lineBreakMode</span>(.<span class="dotAccess">byTruncatingTail</span>),
	          .<span class="call">alignment</span>(.<span class="dotAccess">center</span>)
	      ])

])
</code></pre><p>至此，我们就拥有了一个类型安全的 <code>NSAttributedString</code> 初始化方法。不过条条大路通罗马，伴随着 <code>SwiftUI</code> 的诞生，Swift 5.1 中新增加了 <code>Function Builder</code>，用它来达成我们最初的目标也不失为一个好方法。读一读这篇 <a href="https://medium.com/@carson.katri/create-your-first-function-builder-in-5-minutes-b4a717390671">Create Your First Function Builder in 10 Minutes</a> 应该会有不少启发。</p><h2>TBC</h2><p>(下一篇计划讲一讲在其它一些场景中，如何更优雅地使用 <code>NSAttributedString</code>)</p><blockquote><p>Source Code: https://github.com/Ckitakishi/PlayWithAttributedString</p></blockquote>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/memory-warning</guid><title>Memory warning: 大隐隐于市</title><description>对 memory warning (内存警告) 的处理是一个在开发中极其容易被忽略的问题，究其原因，最重要莫过于 warning 并不那么容易发生，开发中尤其如此。即使发生了，在我们分析崩溃日志的时候，也未必能够明察与之是否有关，再进一步说，就算知道了十有八九是 memory warning 导致了崩溃，有时候要准确定位根源仍需耗费一番功夫。</description><link>ckitakishi.com/posts/memory-warning</link><pubDate>Sat, 23 Feb 2019 12:32:00 +0900</pubDate><content:encoded><![CDATA[<h1>Memory warning: 大隐隐于市</h1><p>对 memory warning (内存警告) 的处理是一个在开发中极其容易被忽略的问题，究其原因，最重要莫过于 warning 并不那么容易发生<s>，开发中尤其如此</s>。即使发生了，在我们分析崩溃日志的时候，也未必能够明察与之是否有关，再进一步说，就算知道了十有八九是 memory warning 导致了崩溃，有时候要准确定位根源仍需耗费一番功夫。</p><h2>常见原因</h2><p>由内存原因导致的崩溃类型多不胜数，不过在这里只打算讨论内存不足导致应用被强制终结这一种。比较常见的是下述几种：</p><ul><li>自然消耗，处理媒体资源尤其容易消耗内存。<ul><li>未处理 memory warning</li><li>对 memory warning 的处理不正确</li><li>memory leak (内存泄漏)，确切来说 memory leak 不是直接原因，而是一个加速器。</li></ul></li></ul><h2>实例</h2><p>之所以认识到这个问题的重要性，是因为最近在看崩溃日志的时候，发现有很多个原因近似，但发生场所不太相同的崩溃，不过总体来说发生率只有 0.0X%。因为夹杂着一些 RxSwift 的代码，真正发生崩溃的位置变得很难判断，真实原因更是扑朔迷离。所谓家家有本难念的经，相似的，短短代码都有说不尽的故事，所以就事论事，来说说到底发生了什么。</p><p>首先，我们有一个封装了 <code>UICollectionView</code> 的 <code>UIViewController</code>，也就是 <code>BaseCollectionViewController</code>，在其中定义了一个可以“保证”不是 <code>nil</code> 且不为 <code>weak</code> 的 <code>collectionVIew</code>：</p><pre><code><span class="comment">// BaseCollectionViewController.swift</span>
<span class="keyword">fileprivate(set) var</span> collectionView: <span class="type">UICollectionView</span>!
<span class="comment">// ...</span>
<span class="keyword">override func</span> didReceiveMemoryWarning() {
    <span class="keyword">if</span> isViewLoaded &amp;&amp; view.<span class="property">window</span> == <span class="keyword">nil</span> &amp;&amp; collectionView.<span class="call">isDescendant</span>(of: view) {
        collectionView.<span class="call">removeFromSuperview</span>()
        collectionView.<span class="property">delegate</span> = <span class="keyword">nil</span>
        collectionView.<span class="property">dataSource</span> = <span class="keyword">nil</span>
        collectionView = <span class="keyword">nil</span>
    }
    <span class="keyword">super</span>.<span class="call">didReceiveMemoryWarning</span>()
}

<span class="keyword">override func</span> loadView() {
    <span class="keyword">super</span>.<span class="call">loadView</span>()
    <span class="comment">// init collectionView in code</span>
}
</code></pre><p>此外，还拥有一个继承自 <code>BaseCollectionViewController</code> 的 <code>XXViewController</code>：</p><pre><code><span class="comment">// XXViewController</span>
<span class="keyword">class</span> XXViewController: <span class="type">BaseCollectionViewController</span> {
    <span class="keyword">override func</span> didReceiveMemoryWarning() {
        <span class="keyword">if</span> isViewLoaded &amp;&amp; view.<span class="property">window</span> == <span class="keyword">nil</span> {
            <span class="comment">// ...</span>
        }
        <span class="keyword">super</span>.<span class="call">didReceiveMemoryWarning</span>()
    }

    <span class="keyword">private func</span> reloadData() {
        <span class="comment">// fetch data from server then reload collection view
        // ...</span>
        collectionView.<span class="call">reloadData</span>()
    }
}
</code></pre><p>实际的运用情景是，在 <code>XXViewController</code> 中存在 pop 一个新 ViewController 的情况，这个时候，<code>XXViewController</code> 需要重新获取数据来刷新页面并更新 <code>collectionView</code> 的 <code>contentOffset</code>。按道理来说，刷新数据在下一次 view will appear 的时候进行会更保险，但是由于我们会在更早的阶段就更新 <code>contentOffset</code>，bug 就这样不幸地产生了。</p><p>当新 <code>ViewController</code> 位于最顶端的时候，<code>XXViewController</code> 就不再被 window 所持有。由于它继承自 <code>BaseCollectionViewController</code>，<code>didReceiveMemoryWarning</code> 发生时 <code>collectionView</code> 会在不知不觉中被置为 <code>nil</code>，如果这一切发生在 <code>collectionView.reloadData()</code> 之前，那噩梦就诞生了。</p><p>这个时候，或许会反思 controller view 之间的继承关系到底合理么，调整 <code>contentOffset</code> 不可见到底合理么，<code>collectionView = nil</code> 到底有没有意义。我认为这些都是合理的着手点，对于这类问题，找到原因其实就已经解决了 80% 了。</p><h2>实践</h2><p>未雨绸缪这句话在这里非常适用，提前去思考一些问题有助于我们规避 memory warning 带来的麻烦：</p><ul><li>当接收到 memery warning 时我们该做什么？</li><li>view controller 不被 window 持有的时候需要做什么？</li><li>当一个 view controller 被恢复的时候，<code>loadView</code>, <code>viewDidLoad</code> 会默认被调用，但是自定义的 <code>init</code> 方法们就不一定了，这样仍能顺利完成初始化吗？</li><li>是否存在显著的内存泄漏？</li></ul><p>当这些问题都梳理清楚的时候，也就大大减少了后顾之忧。</p><p>除了上面提到过的 <code>didReceiveMemoryWarning</code>，还有一个比较常用的方法： <code>applicationDidReceiveMemoryWarning</code>，后者是 App delegate 的方法，所以我认为可以用来管理一些全局对象，或是缓存之类的。除此之外，还可以在必要的时候监听名为 <code>UIApplicationDidReceiveMemoryWarningNotification</code> 的通知来做一些特殊的处理。</p><h2>触发 memory warning</h2><p>那么，当准备就绪的时候，我们就可以通过触发 memory warning 来进行测试了。</p><ol><li>模拟器 --&gt; Debug --&gt; Simulate Memory Warning (<code>Shift + Command + M</code>): 模拟器调试选项，结合断点模拟 warning</li><li><code>UIApplication.shared.perform(Selector(("_performMemoryWarning")))</code>: 在代码中指定位置触发 warning</li></ol><h2>最后</h2><p>内存管理着实不是一个简单的问题，上述内容不过浮于浅表。如果想要稍微再多了解一点，推荐看一看 WWDC 2018 的 <a href="https://developer.apple.com/videos/play/wwdc2018/416/">Session 416</a> ，有很多内容刷新了我的既存认知...</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/metax</guid><title>关于 MetaX 的三言两语</title><description>常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所以就自己动手丰衣足食了。 作为一个总结，下文的主题是照片框架 PhotoKit 和简单的问题解决记录。</description><link>ckitakishi.com/posts/metax</link><pubDate>Sun, 29 Apr 2018 20:47:00 +0900</pubDate><content:encoded><![CDATA[<blockquote><p><strong>Support:</strong> If you have any question or comment for MetaX, please do not hesitate to contact me via the ways on the bottom left of this page.</p></blockquote><p>Source: <a href="https://github.com/Ckitakishi/MetaX">MetaX on Github</a></p><h1>关于 MetaX 的三言两语</h1><h2>初衷</h2><p>常常把相机中的照片传到手机里，但是比较麻烦的一点是没有地理信息，所以就自己动手丰衣足食了。 作为一个总结，下文的主题是照片框架 PhotoKit 和简单的问题解决记录。</p><h2>关于照片框架 - PhotoKit</h2><p>在 <strong>PhotoKit</strong> 之前，AssetsLibrary 是被广泛使用的，由于并没有实际用过，就不再赘述。从 <strong>PhotoKit</strong> 的文档就可以看出来，这是一个十分庞大的框架，包含了相当多的类。<strong>PhotoKit</strong> 可以使得自己的应用与照片库以相同流程工作，此外性能也相当不错。</p><h3>从获取图像开始</h3><h4>相册取得</h4><p>如果以从相册列表选取照片这个流程为例来看，相册列表中的所有对象都是 <code>PHCollection</code>，它是一个抽象父类，拥有两个子类： <code>PHAssetCollection</code> 和 <code>PHCollectionList</code>，前者表示相册，后者表示相册列表也就是文件夹。题外话，在 iOS 设备上创建文件夹几乎可以说是一个隐藏功能，点击追加按钮是相册，而长按则可以选择相册或文件夹。而获取相册的方法是使用上述几个类中的 fetch 方法，返回 <code>PHFetchResult&lt;XXX&gt;</code>，可以用部分与 <code>Foundation</code> 中集合类型相同的接口来处理这个结果，比如用 <code>enumerateObjects(_:)</code> 来进行遍历。该方法默认会取回所有结果，但是可以通过使用 <code>PHFetchOptions</code> 来做一些过滤或是排序处理。例如取回所有智能相册：</p><!--more-->

```swift
let options = PHFetchOptions()
options.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: false)]
let smartAlbums: PHFetchResult<PHAssetCollection>?
smartAlbums = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .albumRegular, options: options)
```

智能相册由系统按照图像类型自动生成，所以并不会出现文件夹。然而，如果以系统照片库来说，还有一类相册是用户自定义相册，处理这类相册的时候必须要注意区分文件夹与相册。我选择的处理方法是暴力地用一个递归将文件夹完全平铺展开作为首级相册。

另外，访问图片库需要请求用户权限，在权限未决定的情况下，第一次调用 fetch 方法的时候会自动请求权限。也可以通过 `PHPhotoLibrary` 的类方法 `requestAuthorization:` 显式地发起请求。如果被拒..绝..了，添加一个类似 404 页面的视图并设置一个按钮指向应用的设置页面是 (我认为) 比较优雅的做法：

```swift
let url = URL(string: UIApplicationOpenSettingsURLString)
UIApplication.shared.open(url!, options: [:], completionHandler: nil)
```

#### 照片取得 

照片的取得是一个层层递进的过程，在取得了相册之后，便可以尝试获取 `PHAsset` 对象，小标题说的比较狭隘一些，实际上 `PHAsset` 对象包含图像，视频，和 Live Photo。此时可以通过调用 `fetchAssets(in:options:)` 来取得一个类型为 `PHFetchResult<PHAsset>` 的资源集：

```swift
let assetCollection = smartAlbums.object(at: 0)
let fetchResult = PHAsset.fetchAssets(in: assetCollection, options: options)
```

手握 `PHAsset`，几乎就拥有了一切。此刻 `PHImageManager` 该出场了，这是一个专门用于请求特定 asset 对应的媒体资源的类。以请求图片为例，其中最重要的一个方法是 `requestImage(for:targetSize:contentMode:options:resultHandler:)`，通过参数就会发现，请求的同时就可以确定图片的尺寸，并进行裁剪。

我们还能够为这个请求设定一个类型为 `PHImageRequestOptions` 的 option，借助它的 `isSynchronous` 属性可以决定以同步还是异步的方式来发起请求；而 `deliverryMode` 则是让你们能够在图像的加载时间和质量中做一个权衡或抉择，`.highQualityFormat` 不论耗时多久都会加载原尺寸图片，`.fastFormat` 会舍弃质量来快速加载图像，`.opportunistic` 约等于前两者的和，先 `.fastFormat` 后 `.highQualityFormat`，所以会发生两次请求，但是，如果 `isSynchronous = true`，那么请求一定是 `.highQualityFormat`；还有 `isNetworkAccessAllowed`，表示是否允许从 iCloud 下载图片，如果允许，那 `progressHandler` 也会被同时调用，于是我们可以将进度体现在 UI 上。

```swift
let options = PHImageRequestOptions()
options.deliveryMode = .opportunistic
// options.isSynchronous = true
options.isNetworkAccessAllowed = true
options.progressHandler = {(progress: Double, _, _, _) in
    DispatchQueue.main.async {
        ...
    }
}

imageRequestId = PHImageManager.default().requestImage(for: asset, targetSize: targetSize, contentMode: .aspectFit, options: options, resultHandler: { image, info in
    ...
})
```

到这里基本上一张图片的取得就完成了。不过，如果由于一些原因请求失败或者不完整呢？在上述代码中，`info` 便是一个包含了多条可以帮助我们判断结果的信息的字典。`PHImageResultIsInCloudKey` 可以知道图像是否需要从 iCloud 下载；`PHImageResultIsDegradedKey` 意味着当前的图像是否是低质量版本；以及 `PHImageErrorKey`，顾名思义是表示了错误信息，等等。

#### 缓存 

最后值得一提的是图片取得的缓存机制。

通常，在获取一张具体的图片之前，我们会先获取整个相册的所有图片做成一个列表，比如一个如同系统图片库的 collectionView，为了性能考虑，有时候会需要提前将图片载入内存，而 `PHImageManager` 有一个子类 `PHImageCachingManager` 正好可以用来做这件事。

`PHImageCachingManager` 有两个比较重要的方法，一个是开始缓存：`startCachingImages(for:targetSize:contentMode:options:)`，另一个是停止缓存，`stopCachingImages(for:targetSize:contentMode:options:)`，彻底停止缓存时候可以使用 `stopCachingImagesForAllAssets()`。接受的参数和上面提到了请求图像几乎一样一样，而事实上在取得缓存之后，再次使用 `requestImage` 取得独立图像的时候，如果参数相同，则会从缓存中获取。

那究竟是将所有图像资源都放入缓存以供不时之需呢，还是仅仅是缓存一部分呢？是一开始就缓存所有资源呢，还是一边滑动一边缓存呢？时机，范围等等都是非常重要而必须要考虑的问题。推荐参考一下 Apple 的示例代码 --- [Using Photos Framework](https://developer.apple.com/library/content/samplecode/UsingPhotosFramework/Introduction/Intro.html)，虽然这个示例 bug 有点点多，但是缓存部分的设计还是很妙的～也因此借鉴了这个部分的实现。它的设计策略在于，载入画面及画面滚动两个时机更新缓存，而区域只包括以可见部分为中心，高度为两倍的部分 (例如：可见范围 [0, 0, 768, 1024] 对应缓存区域：[-512, 0, 768, 2048])，随着画面的滑动，不停调用 `startCachingImages` 与 `stopCachingImages`，该区域也会随之改变，就像一个滑动窗口一样。

### 修改图像

按照从上到下的顺序，有关图像的框架依次是：

 - UIKit
 - CoreImage
 - CoreGraphics
 - ImageIO

下面打算讨论两个维度的图片修改，滤镜和 Metadata。接着上一部分的流程继续往下来说，虽然实现滤镜其实又很多方法，但是若选择 **Core Image**，那么不论哪一种，都要先通过 PHAsset 的实例方法 `requestContentEditingInput(with:completionHandler:)` 来获取完整尺寸的 `CIImage` 图像：

```swift
asset.requestContentEditingInput(with: options, completionHandler: { contentEditingInput, _ in
    guard let imageURL = contentEditingInput?.fullSizeImageURL else {
        // error
        return
    }
    
    let ciImageOfURL = CIImage(contentsOf: imageURL)
    guard let ciImage = ciImageOfURL else {
        ...
        return
    }
}
```

#### 滤镜

在顺利取得 `CIImage` 之后，添加滤镜的流程大致如下。**Core Image** 提供了一些滤镜，如果需要自定的话，看一看 WWDC2014 Session 515 会非常有帮助。

```swift
// 对过去版本的管理
let adjustmentData = PHAdjustmentData...
                                                  
let contentEditingOutput = PHContentEditingOutput(contentEditingInput: contentEditingInput)
contentEditingOutput.adjustmentData = adjustmentData

let outputImage = ciImage
    .applyingOrientation(input.fullSizeImageOrientation)
    .applyingFilter(filter, withInputParameters: nil)
    
CIContext().writeJPEGRepresentation(of: outputImage,
                                    to: contentEditingOutput.renderedContentURL, 
                                    colorSpace: ciImage.colorSpace!,
                                    options: [:])

// 确认修改
PHPhotoLibrary.shared().performChanges({
    let request = PHAssetChangeRequest(for: self.asset)
    request.contentEditingOutput = contentEditingOutput
}, completionHandler: { success, error in
    ...
})
```

#### Metadata

有了 `CIImage`，读取 Metadata 只需要获取 `CIImage` 的 `properties` 属性即可。但是如果要写入，就需要基于相对底层的 `ImageIO` 框架来完成。

首先，我创建了临时存储，，虽然最初的想法是直接覆盖当前编辑中的图像，这个方案在模拟器竟然成功了，但是真实设备行不通。后来迫不得已选择了迂回的方法，覆盖 => 追加新图像 + (可选)删除旧图像。

```swift
let context = CIContext(options:nil)

// 创建一个临时存储
var tmpUrl = NSURL.fileURL(withPath: NSTemporaryDirectory() + imageURL.lastPathComponent)
```

为了让新创建的图像保持与原始图像相同的类型，通过 `CGImageSource` 来获取。如果获取成功，就可以指定上面的临时 URL 作为位置，尝试创建 `CGImageDestination`，之所以说是尝试，是因为不得不考虑如果当前设备并不支持期待创建的类型，那么我们就会得到 `nil`。这个时候别无选择，只能够再试一次，在当前版本中，这个做法主要是为了解决 **HEIF** 格式在一些较有历史的设备上并不被支持而带来的问题，所以在失败的情况下，默认将目标类型设定为 **JPEG**：

```swift
// 从 CIImage 创建 CGImage
let cgImage = context.createCGImage(ciImage, from: ciImage.extent)
// 根据 CGImageSource 来获取图片类型标识 (UTI)
let cgImageSource = CGImageSourceCreateWithURL(imageURL as CFURL, nil)
guard let sourceType = CGImageSourceGetType(cgImageSource!) else {
    ...
    return
}
// 尝试创建 CGImageDestination
var createdDestination: CGImageDestination? = CGImageDestinationCreateWithURL(tmpUrl as CFURL, sourceType
    , 1, nil)

// 该版本暂定方案：无法创建的图像格式就存储为 JPEG
if createdDestination == nil {
    // media type is unsupported: delete temp file, create new one with extension [.JPG].
    let _ = try? FileManager.default.removeItem(at: tmpUrl)
    tmpUrl = NSURL.fileURL(withPath: NSTemporaryDirectory() + imageURL.deletingPathExtension().lastPathComponent + ".JPG")
    createdDestination = CGImageDestinationCreateWithURL(tmpUrl as CFURL, "public.jpeg" as CFString
        , 1, nil)
}

guard let destination = createdDestination else {
    ...
    return
}
```

若完成了 `CGImageDestination` 创建，就可以开始向这个目标添加图像了。在上一段代码中，创建时传入的第 3 个参数正是代表着图像的数量，因为只是单张图像，所以是自然是 1；该方法也可以用来创建 GIF。

```swift
// 向 CGImageDestination 添加图像，以及该图像的 metadata。
CGImageDestinationAddImage(destination, cgImage!, newProps as CFDictionary)
if !CGImageDestinationFinalize(destination) {
    ...
} else {
    ...
}
```

最后，通过仍在临时存储位置的图像来创建一个新的 asset 追加请求，并将临时存储的图像移除即可：

```swift
PHPhotoLibrary.shared().performChanges({
    let request = PHAssetChangeRequest.creationRequestForAssetFromImage(atFileURL: tempURL)
    let _ = try? FileManager.default.removeItem(at: tempURL)
    ...
})
```

#### HEIF

**HEIF** 是全新的图片格式，相应的还有视频的 **HEVC**。苹果表示在相同画质下大小能节约 50% 的存储空间。如果想要了解更多，推荐看一看 WWDC 2017 Session 511。

在实际运用中遇到了一个问题，如果我在相对较旧的设备上查看 **.HEIC (HEIF)** 的图片，并尝试去修改它，上面提到的 `CGImageDestination` 会得到一个 `nil` 对象。结果并不意外，毕竟这需要软件与硬件双方面的支持。但是具体来说究竟分界线在哪里呢？可以在 511 找到答案，而[这个支持页](https://support.apple.com/en-us/HT207022)也讲的很详细。基本条件就是运行 iOS 11 的 iPhone 7 等设备以及之后的新设备。

### 监听变化

万事俱备，只欠东风。但，如果此时系统的图片库发生了改变，又该怎么办？

只需要记住四步，就可以解决这个问题了：

1. 让当前的类遵循 `PHPhotoLibraryChangeObserver` 协议。

```swift
extension DetailInfoViewController: PHPhotoLibraryChangeObserver {

}
```

2. 在视图即将出现时将当前的类作为观察者注册到 `PHPhotoLibrary` 共享对象上。

```swift
PHPhotoLibrary.shared().register(self)
```

3. 实现 `PHPhotoLibraryChangeObserver` 协议的 `photoLibraryDidChange(_:)`
 方法。
 
```swift
func photoLibraryDidChange(_ changeInstance: PHChange) {
    // changeDetails 方法有接受不同参数的多个版本，可参照文档。
    guard let curAsset = asset, let details = changeInstance.changeDetails(for: curAsset) else {
        return
    }
    asset = details.objectAfterChanges
    ...
}    
```

4. 最后在 `deinit` 中解除监听。

```swift
deinit {
    PHPhotoLibrary.shared().unregisterChangeObserver(self)
}
``` 

## 一些笔记

### PromiseKit 6 

PromiseKit 6 对几个比较核心的点做出了修改。说实话，我觉得这个框架的文档可读性其实还有待提升。直接看源码及其中的注释反而是个很好的选择。

其中一点是改变了核心初始化方法：

```swift
// 之前
Promise { fulfill, reject in
    // ...
}

// 现在
Promise { seal in
    // seal.fulfill(foo)
    // seal.reject(error)
    // seal.resolve(foo, error)
}
```

还有一点是，将万能的 `then` 拆分为了 `then`, `done` 和 `map`。作者的解释是，以前 `then` 做很多事，但是由于依赖 Swift 根据上下文做推断，在用了多个 `then` 之后推断就会发生失败。而且很难判断错误发生在哪。所以就只能选择从比较高的层级就修复这个问题，于是有了现在的方案：

- `then`：返回一个 promise。
- `done`：返回一个 Void promise (80% 的情况用在 promise 链中)。
- `map`：返回非 promise 值，比如一个单纯的值。

### 地理位置检索

我需要的是一个根据关键字获取相关地点的一个检索，也就是常说的 POI 检索。因为需要比较简单，所以先考虑了 **MapKit** 的 `MKLocalSearch` 或者 `MKLocalSearchCompleter`。

前者常常会用在地图的检索，通过 `start(completionHandler:)` 可以取得 10 个结果，并且这个 limit 无法自定义，它在主线程工作，而且当发起新的请求时当前即使有正在进行的检索也不会被终止，如果不注意很可能会得到错误的结果：

```swift
let localSearchRequest = MKLocalSearchRequest()
let newestLocation = locations.last! as CLLocation
localSearchRequest.region = MKCoordinateRegion(center: newestLocation.coordinate, span: MKCoordinateSpanMake(5.0, 5.0))

MKLocalSearch(request: localSearchRequest).start(completionHandler: { (localSearchResponse, error) -> Void in
    guard searchText == searchBar.text else {
        return
    }
    ...
})
```

所以这似乎并不是一个理想的选择。辅以后者的 `MKLocalSearchCompleter` 会更好一些：

```swift
let completer = MKLocalSearchCompleter()
completer.queryFragment = searchText

// MARK: MKLocalSearchCompleter Delegate
extension LocationSearchViewController: MKLocalSearchCompleterDelegate {

    // 处理检索结果
    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {
        self.resultDataSource = completer.results
        ...
    }
    // 处理错误
    func completer(_ completer: MKLocalSearchCompleter, didFailWithError error: Error) {
        ...
    }
}
```

这样一来，检索结果列表就可以很简单的表示出来了。当需要取得各个位置的详细信息时，还是无法离开 `MKLocalSearch`，根据检索结果创建请求即可。

不过即使这样也还是有很多制限，比如近邻检索，尝试使用了 Foursquare，虽然这个问题得以解决，但是请求数量的限制又是新的需要考虑的问题，所以，要走的路还很长。另外，由于在中国无法检索海外地点，也无法逆向转换海外经纬度，要走的路不是很长，而是很长很长。
]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/tryswift-2018</guid><title>回顾 Try!Swift Tokyo 2018</title><description>拖延症很可怕，过了快两周终于开始着手写 Try!Swift Tokyo 2018 的感想。受到了前同事的影响，今年的大会我是做为志愿者参加的，玩得很开心，然而只听到了一半的演讲T.T。所以之后会从听众和志愿者两个角度来简短的写一写让我印象深刻的一些事儿。</description><link>ckitakishi.com/posts/tryswift-2018</link><pubDate>Wed, 14 Mar 2018 19:37:00 +0900</pubDate><content:encoded><![CDATA[<h1>回顾 Try!Swift Tokyo 2018</h1><p>拖延症很可怕，过了快两周终于开始着手写 Try!Swift Tokyo 2018 的感想。受到了前同事的影响，今年的大会我是做为志愿者参加的，玩得很开心，然而只听到了一半的演讲T.T。所以之后会从听众和志愿者两个角度来简短的写一写让我印象深刻的一些事儿。</p><img src="ckitakishi.com/images/tryswift1.jpg" alt="集合写真"/><blockquote><p><a href="https://www.tryswift.co/events/2018/tokyo/jp">Try!Swift 官网</a></p></blockquote><p>久闻不如一见，各种机缘巧合终于和<a href="https://onevcat.com">喵神</a>碰面了，一路学习 iOS 可能读的最多的就是喵神写的文章了，真的是受益匪浅。虽然因为比较忙只聊了一会儿还都是杂谈www，但是有种成就达成的激动感(`･∀･)</p><p>第一天早晨还遇到了 <a href="http://smoozapp.com/">Smooz</a> 的创始人 Kato 桑，人很和善且健谈，回忆起第一次知道 Smooz 是 16 年的年初，那时候还在测试阶段，只有 iOS 版本，也还没有成立公司运营，类似于独立开发者项目。Smooz 拥有类似 web 浏览器的多 tab 置顶让人眼前一亮，各种手势的便利性也增色不少，另外颜色还相当可爱。当时 (很失礼地) 暗自想会不会渐渐又成为一个换肤浏览器？事实胜于一切，后来 Smooz 获得了 App Store Best of 2016，现在常常可以在电车上看到用户，总之是一款很不一样的移动端浏览器，值得一试。</p><h2>听众视角</h2><p>缺席了几场想听的演讲，像是 Charlse for iOS..泪目。下面所写的大多是临场感受。</p><blockquote><p>这是一份日语的<a href="https://qiita.com/ozwio/items/71fb765b48905d6a2193">资料总结</a>。</p></blockquote><h3>代码优化：Optimizing Swift code for separation of concerns and simplicity</h3><p>代码的优化是一个老生常谈的话题，不过有些东西越老越能凸显它的价值所在。我个人对这个话题比较感兴趣，一方面是如讲者所说：代码通常读比写更多；还有一个原因就是团队合作，简洁明确再重要不过了。听完这个“最佳编程实践”之后，我觉得对于我这样段位不高的开发者来说还是颇有收获的，也许今后能把代码写的更 Swifty 一些？。另外，扩展给 Swift 带来的便利在这些例子中也是体现的淋漓尽致。</p><p>很多例子都深有同感，比如说下面这种模型：</p><pre><code><span class="comment">// before</span>
api.<span class="call">requestReplies</span>(postID: <span class="number">4815162342</span>) { [<span class="keyword">weak self</span>] result <span class="keyword">in
   switch</span> result {
   <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> replies):
     <span class="keyword">var</span> filteredReplies: [<span class="type">Reply</span>] = []
     <span class="keyword">for</span> reply <span class="keyword">in</span> replies {
       <span class="keyword">if</span> !user.<span class="call">isBlocking</span>(reply.<span class="property">author</span>) {
         filteredReplies.<span class="call">append</span>(reply)
       }
     }

     <span class="keyword">self</span>?.<span class="property">replies</span> = filteredReplies
   <span class="keyword">case</span> .<span class="dotAccess">failure</span>:
       <span class="comment">// ...</span>
   }
}
</code></pre><p>作为一个写 Objective-C 多于 Swift 的人，私以为这样的写法在大家的 Objc 代码中可是说是十分常见了～即使能优化，感觉也只能加入一个 <code>filter</code> 写成下面这样？</p><pre><code><span class="type">NSArray</span> *filteredArray = [replies filteredArrayUsingPredicate:[<span class="type">NSPredicate</span> predicateWithBlock:^<span class="type">BOOL</span>(<span class="type">Reply</span> *reply, <span class="type">NSDictionary</span> *bindings) {
    <span class="keyword">return</span> [user isBlocking:reply.<span class="property">author</span>];
}]];
</code></pre><p>讲者提到的 Swift 优化方案是：1. 将核心逻辑抽象出来作为一个 Collection 的扩展；2. 活用 <code>var</code> 和 <code>filter</code>。这样一来，代码的“信噪比”会得到不少提升，写法也比较优雅：</p><pre><code><span class="comment">// After</span>
<span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">Reply</span> {
  <span class="keyword">var</span> filteringBlockedContent: [<span class="type">Reply</span>] {
    <span class="keyword">return</span> <span class="call">filter</span> { !user.<span class="call">isBlocking</span>($0.<span class="property">author</span>) }
  }
}

api.<span class="call">requestReplies</span>(postID: <span class="number">4815162342</span>) { [<span class="keyword">weak self</span>] result <span class="keyword">in
   switch</span> result {
   <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> replies):
     <span class="keyword">self</span>?.<span class="property">replies</span> = replies.<span class="property">filteringBlockedContent</span>
   <span class="keyword">case</span> .<span class="dotAccess">failure</span>:
       <span class="comment">// ...</span>
   }
}
</code></pre><p>真心希望以后写的代码都是 "After"。</p><blockquote><p>更多例子在<a href="https://github.com/JaviSoto/Talks/tree/master/TrySwiftTokyo2018">这里</a></p></blockquote><h3>SwiftNIO</h3><p>还在演讲前大家一起聊天时就推测这可能是当日最火？毕竟能在 WWDC 以外和 Apple 工程师交流的机会少之又少，因此还为 Q&amp;A 环节增派了志愿者～而发表的内容也没有让人失望，，在介绍了一些有关异步，以及 IO 事件的发生其实可能并没有我们想的那么频繁之后，表示不如打造一个 Swift 版的 Netty 来让性能得到一个飞跃吧，于是 SwiftNIO 就诞生了。后来的内容陷入了一种云里雾里，还是暂且先跳过吧😂。在意料之外的是最后直接宣布了 SwiftNIO 的开源。随着它的开源，服务器端 Swift 算是又迈出了重要一步。</p><p>最近有人担心 Norman 会不会因为 SwiftNIO 的开源而导致维护 Netty 的时间变少，他表示不用担心噢大家，我已经同时维护它们超过一年了～</p><blockquote><p>前两天视频已经公开了：<a href="https://www.youtube.com/watch?v=QJ3WG9kRLMo&feature=youtu.be">Youtube Link</a></p></blockquote><h3>用 Swift 进行游戏开发👾</h3><p>演讲者 <a href="https://twitter.com/giginet">giginet</a> 去年是 Lightning Talk，发表了用 SprireKit 在 AppleWatch 上开发超级玛丽的种种，并在此后的 Hackthon 中开发了一个 Touch Bar 小游戏，花样挖掘苹果家设备的潜能，很会玩。</p><p>今年再次卷土重来，上来就表示其实 Xcode 是一个游戏开发工具，并展示了在 Xcode 里绘制的世界地图…言归正传，开始着重介绍了一下 SprireKit 和 GameplayKit 的基本用法和示例。最后再把 SprireKit 与 Unity 进行了一波比较，几乎在所有平台全军覆没的 SprireKit 在 WatchOS 独占了一块阵地。。所以 Swift 开发者们都行动起来吧！</p><p>虽然开了很多玩笑，不过如果想着手游戏开发，也许还真可以用 Swift 一试呢？</p><blockquote><p>资料: <a href="https://speakerdeck.com/giginet/-11">https://speakerdeck.com/giginet/-11</a></p></blockquote><h3>算法可视化：Using Swift to Visualize Algorithms</h3><p>没有听到演讲前以为会是一个借算法可视化来介绍 Swift 在图形绘制上的优势之类的。比较意外真正的核心主题是贝塞尔曲线。这个演讲在现场得到了相当好的反响，大概凭借的是讲解比较清晰易懂，像是给定任意点如何绘制，多阶贝塞尔曲线如何绘制都能从中找到答案。如果对动画有兴趣但不了解贝塞尔曲线的绘制方法不妨看一看～</p><blockquote><p>资料: <a href="https://speakerdeck.com/subdigital/bezier-curves">https://speakerdeck.com/subdigital/bezier-curves</a></p></blockquote><h3>Open Source Swift Workshop</h3><p>最后一天有几场 workshop，我只去了 Open Source Swift Workshop (By <a href="https://twitter.com/din0sr">Nicholas Maccharoli</a> &amp; <a href="https://twitter.com/ikesyo">ikesyo</a>)。大概可以概括为 “如何通过改 bug 或优化为 Swift 贡献力量”。应该有很多人都想过，除了用 Swift 写代码，我们是不是能做的更多呢。现实的残酷在于，实际上手有时候并不是那么容易，也许是需要一个契机，也许是需要一个人引导。而这个 workshop 便成为了一个很好的机会，结束后有不止一个人提了 pr...</p><p>鉴于自身学识浅薄，当天向 ikesyo 桑请教了最初该如何着手，作为入门我觉得很细致很清晰：</p><ol start="0"><li>build 最新的 Swift 源码。</li><li><a href="https://bugs.swift.org">https://bugs.swift.org</a> ：在这里会有很多待解决的 issue, 属于 Compiler, LLDB for Swift, Package Manager, Standard Library 等模块，第一次上手选择自己相对了解的会比较好，例如：Standard Library 和 Foundation。正确使用 Filter 也有助于找到适合自己的 issue，比如说检索带有入门级标签的 Standard Library 或 Foundation issue: <code>labels = StarterBug AND status = Open AND component in ("Standard Library", Foundation)</code>。</li><li><a href="https://forums.swift.org/">https://forums.swift.org</a> ：在这里和大家愉快的讨论问题。</li><li>也可以通过从源码中查找 <code>FIXME</code>, <code>TODO</code> 这些关键字来查找可以改进的地方，这其中甚至有一些是文本层面的修正～</li></ol><p><strong>扩展阅读：</strong></p><ul><li>https://swift.org/compiler-stdlib/#compiler-architecture</li><li>https://swift.org/community/</li><li>https://academy.realm.io/posts/tryswift-jesse-squires-contributing-open-source-swift/</li><li>https://www.uraimo.com/2016/02/09/a-short-swift-gyb-tutorial/</li><li>https://www.youtube.com/watch?v=e18uipMmEoo</li></ul><h2>志愿者视角</h2><p>今年的参会人数包括 Sponsor 和 Speaker 达到了 800 人，来自日本以外的参加者也超过了 200 人，志愿者的数量约为 30 人。阴差阳错，我主要担当的是 global support，引导演讲者与同传事前会面，按时上台，之后 Q&amp;A。很有意思的一个细节是，英语同声译日语其实很痛苦，因为日语真的很啰嗦，尤其是这种场合基本都是敬语，英语 10 个音节日语可能需要 20 个，每次同传们都会千叮咛万嘱咐演讲者慢一点再慢一点😂，事后再吐槽“你怎么越讲越快呢～～”。很大的收获是意识到了自己的语言是有多么差。。。</p><p>这次有一个很特殊的志愿者，80 多岁了仍然在学习写代码，有自己的主页及上架应用，听说之后觉得唯有敬佩，没能直接交流真是太遗憾了。有时候休会时间会看到一些人盒饭放一边，坐在走廊和墙边就噼里啪啦写代码，由衷的觉得：能如此热爱一件事真是太好了！</p><p>日本很多 iOS 活跃的企业都作为 Sponsor 有自己的展区，（主要还是为了招聘，到处看被塞了好几份介绍）。像是 Yahoo Japan 的 live coding 得到了很好的反响。于企业于个人这都是一个不错的机会。</p><p>P.S. Party 的蛋糕真的是太可爱了...</p><img src="ckitakishi.com/images/tryswift2.jpg" alt="Cake"/><h2>写在最后</h2><p>于我而言，大概就是意识到了自己在很多方面都还差很远的事实，不管是技术还是日语英语。前路漫漫，继续加油。明年再见。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/2018-new-year</guid><title>想要坚持下去的2018</title><description>2018 回顾 &amp; 2019 期许</description><link>ckitakishi.com/posts/2018-new-year</link><pubDate>Mon, 8 Jan 2018 21:30:00 +0900</pubDate><content:encoded><![CDATA[<h1>想要坚持下去的2018</h1><p>前两天终于看了电视剧版《火花》，久久无法释怀。很喜欢的一幕是 sparks 的谢幕演出，不再为了迎合潮流而讲段子，泪流满面说反话，哭着笑，笑着哭，最后的绽放啊。坚持与努力是因为还有梦想，可妥协与放弃并不是结束，还能平凡的活着，就总还会有平凡的奇迹。</p><h2>==== 题外话的分割线 ====</h2><p>过去这一年，常常感觉好无奈。坚持运动，很大程度保持健康饮食，可身体状况却意外的差。可是除了坚持下去还能有什么办法呢？工作内容没有太大的变化，依然担当着几个应用的开发，只不过多了和客户的接洽，然鹅我这样的渣日语什么时候才能和客户谈笑风生啊。没有什么惊喜，不过感性的用心情来评价的话，其实真的也不太坏，还是很容易感动很容易开心。</p><p>2018 年最想要的在一些事情上坚持下去，纵然也许什么也改变不了，哈哈。颤抖着立个 flag 吧：</p><ul><li>日语和英语进阶</li><li>和更多人交流和沟通</li><li>在 test 和 project manage 方面有进步，分享知识，拥抱开源</li><li>拍不错的照片，做好吃的饭，坚持运动，去旅行</li><li>读 24 本书</li><li>上架 2～3 个小应用</li><li>换工作</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/objc-macro</guid><title>实践：Objective-C的宏定义</title><description>宏定义在 Objective-C 中可以说是被广泛使用。就实际来说，目前组内对 Enum, Singeleton, Log 等都使用了宏来进行定义。究其原因，一部分是为了为了减少重复代码，提升开发体验，还有一部分来源于对条件编译的需求。</description><link>ckitakishi.com/posts/objc-macro</link><pubDate>Thu, 30 Nov 2017 22:17:00 +0900</pubDate><content:encoded><![CDATA[<blockquote><p>之前某一周的 LT 话题。</p></blockquote><h1>实践：Objective-C的宏定义</h1><p>宏定义在 Objective-C 中可以说是被广泛使用。就实际来说，目前组内对 Enum, Singeleton, Log 等都使用了宏来进行定义。究其原因，一部分是为了为了减少重复代码，提升开发体验，还有一部分来源于对条件编译的需求。</p><p>最早知道宏定义是在 C 语言课本上，然后就是笔试时候的各种宏展开。但是直到投入项目开发之后才算是稍微理解了一些宏的强大与脆弱。所以很想简单谈一谈 Objective-C 的宏定义实践。</p><h2>关于宏</h2><p>宏属于 C 预处理的一部分，C++，Objective-C 也一样通用。宏分为两种，对象宏 (<strong>Object-like</strong>) 和函数宏 (<strong>Function-like</strong>)。顾名思义，对象宏类似于数据对象，函数宏类似于函数调用。</p><pre><code><span class="comment">// Object-like</span>
#define <span class="type">HEIGHT</span> <span class="number">60</span>

<span class="comment">// Function-like</span>
#define <span class="type">MIN</span>(a, b) a &lt; b ? a : b
</code></pre><p>函数宏看起来可以说是相当便利，而且执行效率还非常高。但是在实际运用中很多时候并不推荐使用，比如当出现自增自减运算时，上面的最小值就可能会发生错误，你不能说它是陷阱，毕竟宏的强项并不是复杂的逻辑运算。但是艺高人胆大，如果能玩得转用一用也无妨~</p><p>扩展阅读：<a href="https://gcc.gnu.org/onlinedocs/cpp/index.html#SEC_Contents">The C Preprocessor</a></p><h2>实践</h2><h3>单例的宏定义：</h3><p>使用了条件编译 <code>#ifndef</code>，推荐这种写法，尤其是在定义 cell 的高度时最好这么做，防止多重定义。 这是一个函数宏。</p><pre><code>#ifndef <span class="type">Singleton_h</span>
#define <span class="type">Singleton_h</span>

#define <span class="type">SINGLETON_IMPL</span>( classname )\
+ (classname *)sharedInstance\
{\
<span class="keyword">static</span> dispatch_once_t onceToken;\
<span class="keyword">static</span> classname *_sharedInstance = <span class="keyword">nil</span>;\
<span class="call">dispatch_once</span>(&amp;onceToken, ^{\
_sharedInstance = [[[<span class="keyword">self class</span>] alloc] <span class="keyword">init</span>];\
});\
<span class="keyword">return</span> _sharedInstance;\
}

#define <span class="type">SINGLETON_DEFINE</span>( classname )\
+ (classname *)sharedInstance;

<span class="preprocessing">#endif</span>
</code></pre><p>利用例：</p><pre><code><span class="type">ClassName</span>.<span class="property">h</span>
<span class="type">SINGLETON_DEFINE</span>(<span class="type">ClassName</span>)

<span class="type">ClassName</span>.<span class="property">m</span>
<span class="type">SINGLETON_IMPL</span>(<span class="type">ClassName</span>)

<span class="type">OtherClass</span>:
[<span class="type">ClassName</span> sharedInstance].property
</code></pre><h3>2. enum的宏定义：</h3><pre><code>#ifndef <span class="type">APP_ENUM</span>
#define <span class="type">APP_ENUM</span>( name_ ) \
typedef <span class="keyword">enum</span> name_ : <span class="type">NSInteger</span> name_; \
<span class="keyword">enum</span> name_ : <span class="type">NSInteger</span>
<span class="preprocessing">#endif</span>
</code></pre><p>利用例：</p><pre><code><span class="type">APP_ENUM</span>( <span class="type">EnumName</span> ) {
    <span class="type">EnumNameA</span>,
    <span class="type">EnumNameB</span>
};
</code></pre><h3>3. LOG的宏定义：</h3><p>当且仅当版本为开发版或内部测试版时输出 log。这里的 <code>__PRETTY_FUNCTION__</code>, <code>__LINE__</code> 都是 C 中已定义的函数宏，分别表示函数和行数。</p><pre><code>#ifdef <span class="type">DEBUG</span>
#define <span class="type">LOG</span>(<span class="type">A</span>, ...) <span class="type">NSLog</span>(<span class="keyword">@"DEBUG</span>: %s:%d:%<span class="string">@", __PRETTY_FUNCTION__,__LINE__,[NSString stringWithFormat:A, ## __VA_ARGS__]);</span>
#elif defined <span class="type">ALPHA</span>
#define <span class="type">LOG</span>(<span class="type">A</span>, ...) <span class="type">NSLog</span>(<span class="keyword">@"ALPHA</span>: %s:%d:%<span class="string">@", __PRETTY_FUNCTION__,__LINE__,[NSString stringWithFormat:A, ## __VA_ARGS__]);</span>
<span class="preprocessing">#else</span>
#define <span class="type">LOG</span>(...)
<span class="preprocessing">#endif</span>
</code></pre><p>利用例：</p><pre><code><span class="type">LOG</span>(<span class="string">@"test");</span>
</code></pre><p>出力：</p><p>[Time] [App Name] [Build Configuration] [File Name + Method] [Line Number] log</p><pre><code><span class="number">2017</span>-<span class="number">11</span>-<span class="number">27 09</span>:<span class="number">35</span>:<span class="number">19.099</span> <span class="type">AppName</span>[<span class="number">59272</span>:<span class="number">2201737</span>] <span class="type">DEBUG</span>: -[<span class="type">ClassName</span> method]:<span class="number">330</span>: test
</code></pre><h3>4. TODO&amp;FIX 的宏定义：</h3><p>参考自 <a href="http://blog.sunnyxx.com/2015/03/01/todo-macro/">todo-macro</a>，很有意思的一篇文章，通过宏定义将 <code>#pragma message ("msg")</code> 进行扩展而作为 TODO 使用：</p><pre><code>#define <span class="type">STRINGIFY</span>(<span class="type">S</span>) #S
#define <span class="type">DEFER_STRINGIFY</span>(<span class="type">S</span>) <span class="type">STRINGIFY</span>(<span class="type">S</span>)
#define <span class="type">PRAGMA_MESSAGE</span>(<span class="type">MSG</span>) <span class="type">_Pragma</span>(<span class="type">STRINGIFY</span>(<span class="call">message</span>(<span class="type">MSG</span>)))
#define <span class="type">FORMATTED_MESSAGE</span>(<span class="type">MSG</span>) <span class="string">"[TODO-"</span> <span class="type">DEFER_STRINGIFY</span>(<span class="type">__COUNTER__</span>) <span class="string">"]"</span> <span class="type">MSG</span> <span class="string">" Line:"</span> <span class="type">DEFER_STRINGIFY</span>(<span class="type">__LINE__</span>)

#define <span class="type">TODO</span>(<span class="type">MSG</span>) <span class="type">PRAGMA_MESSAGE</span>(<span class="type">FORMATTED_MESSAGE</span>(<span class="type">MSG</span>))
</code></pre><p>利用例：</p><pre><code><span class="keyword">@TODO</span>(<span class="string">"test code 1"</span>)
<span class="keyword">@TODO</span>(<span class="string">"test code 2"</span>)
</code></pre><h2>杂谈</h2><p>当要使用宏时，务必要考虑有没有必要，合不合理，会不会有副作用。举个例子来说：当需要定义一个常量时，宏完全可以，但是更好的选择是使用 <code>const</code> 关键字。借助宏来定义常量最大的痛点就是不包含类型信息，<code>const</code> 不仅弥补了类型信息缺失的问题，而且在访问控制权限这块也表现地更好。</p><p>最后还想提一句 <code>typedef</code>，人们常常会拿它和 <code>#define</code> 相比较，看起来用法很相似，其实本质上有蛮大区别，<code>typedef</code> 是在编译期间进行处理的关键字。用途上来说，<code>typedef</code> 更多是用于创建类型别名，上述 Enum 的宏定义中为枚举指定别名就依赖于 <code>typedef</code>。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/storyboard-or-xib</guid><title>Storyboard 和 Xib 的“抉择”</title><description>比起手写 UI，“拖控件”的 Storyboard 和 Xib 似乎一直都更投我所好。不过即使是 Storyboard 和 Xib 之间，似乎也还是多多少少有一些纷争。</description><link>ckitakishi.com/posts/storyboard-or-xib</link><pubDate>Sun, 24 Sep 2017 22:33:00 +0900</pubDate><content:encoded><![CDATA[<h1>Storyboard 和 Xib 的“抉择”</h1><blockquote><p>近期开始进行一个新项目的原型制作及其结构设计，打算把一些心路历程记录下来，随便先给它取个名字叫做：<strong>P-OOP</strong>。</p></blockquote><p>比起手写 UI，“拖控件”的 Storyboard 和 Xib 似乎一直都更投我所好。不过即使是 Storyboard 和 Xib 之间，似乎也还是多多少少有一些纷争。</p><h2>Storyboard &amp; Xib</h2><p>公司 (年久失修) 的 iOS Guidelines 中写着一句话：</p><blockquote><p>进行源码管理时 Storyboard 极易导致冲突，团队开发时，各画面与各组件尽可能使用 Xib 进行实现。</p></blockquote><p>对此我一直抱着赞否两论的观点。在实际工作时，同一 Storyboard 中存在大量 ViewController 十分容易冲突是一个不争的事实，掉进这个坑的人有可能还进行过 xml 修正。但是这个锅 Storyboard 不背。一部分人可能因此选择了弃 Storyboard 从 Xib 之路，我也一度徘徊是否这才是正道。但是很显然的是，Storyboard 从一开始就不是为了代替 Xib 而来。</p><p>除了 UI 设置的相似部分以外，Storyboard 更重视画面之间的关联和迁移，而 Xib 作为通用组件的模版应该是不二的选择。</p><p>在 P-OOP 中，将会存在大量的 dialog，尽管可以很容易的使用 Present Modally 来实现，不过为了保持系列产品的风格一致性，需要考虑如何以比较好的方式来实现共通的 header 和 footer 样式。考虑过很多方案，比如：</p><ol><li>将 footer 和 header 集成在同一个 view 中，并添加一个 content view，最终在某 controlelr view 中将上述 view 与实际从另一个 xib 中载入的 content view 组合，完成组装。但是存在一个比较显著的缺点，实际可见的 controller view 所呈现的内容并不是很直观，果然还是必须看代码才能梳理清楚。</li><li>将 footer 和 header 以及一个 content view 集成在同一个 controller view 中。在代码中按照要求载入 content，代理方法之类变得容易管理了一些，但是更糟糕的是这个 controller 的代码终将成为垃圾场的。。。那加入继承呢？有些小题大做？</li></ol><p>果然简洁才是最高的，将 footer 和 header 完全独立为两个 view，按需载入。结合 @IBInspectable 和 @IBDesignable 可以说是比较完美了，从画面设计到迁移等都很清晰。不足一提的小缺点是使用时候的 auto layout 的设置可能存在一些重复操作 (比如 Auto Layout 之类的)，若考虑 Model 除了 form sheet 以外可以是 full screen，后者需要在顶部额外预留 20px，这样一来反而变得巧妙了。</p><p>也许过几天自己的想法又发生了细微变化，但简洁清晰无论何时都不会太坏。</p><h2>心得</h2><h3>Storyboard Reference</h3><p>Storyboard 容易引发冲突，这句话在 Storyboard Reference 面前是不成立的。</p><p><strong>Storyboard Reference</strong> 第一次出现在 Xcode 7，可以从组件库中找到它，并自行进行配置和关联，十分简单，无需赘述。即使是一个已经完成且十分繁杂的 Storyboard，也可以选中想要分离的 Storyboard，通过 <strong>Editor -&gt; Refactor to Storyboard</strong> 来实现。比如，使用了两个 Container View，默认情况下此时画面中存在三个 controller，对其进行分离之后，变成了这样：</p><img src="ckitakishi.com/images/Storyboard_reference.png" alt="Storyboard Reference"/><h3>Loadable Nib</h3><p>将 Xib 组件的载入协议化，其中一个目的是为了类型安全，另一个目的是为了减少重复代码。</p><pre><code><span class="keyword">protocol</span> Loadable: <span class="keyword">class</span> {
    <span class="keyword">static var</span> nibName: <span class="type">String</span> { <span class="keyword">get</span> }
}

<span class="keyword">extension</span> <span class="type">Loadable</span> {
    <span class="keyword">static var</span> nibName: <span class="type">String</span> { <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="type">Self</span>.<span class="keyword">self</span>) }
}
</code></pre><p>对 <code>UIView</code> 进行扩展，要求被载入的 view 遵循 <code>Loadable</code> 协议：</p><pre><code><span class="keyword">extension</span> <span class="type">UIView</span> {
    <span class="keyword">func</span> instantiateFromNib&lt;T: <span class="type">UIView</span>&gt;(<span class="keyword">_</span>:<span class="type">T</span>.<span class="type">Type</span>) -&gt; <span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Loadable</span> {
        <span class="keyword">if let</span> nib = <span class="type">UINib</span>(nibName: <span class="type">T</span>.<span class="property">nibName</span>, bundle: <span class="keyword">nil</span>).<span class="call">instantiate</span>(withOwner: <span class="keyword">nil</span>, options: <span class="keyword">nil</span>).<span class="property">first</span> <span class="keyword">as</span>? <span class="type">T</span> {
            <span class="keyword">return</span> nib
        } <span class="keyword">else</span> {
            <span class="call">fatalError</span>(<span class="string">"Nib</span> \(<span class="type">T</span>.<span class="property">nibName</span>) <span class="string">is not exist ?!"</span>)
        }
    }
    
    <span class="keyword">func</span> instantiateFromNibOwner&lt;T: <span class="type">UIView</span>&gt;(<span class="keyword">_</span>:<span class="type">T</span>.<span class="type">Type</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Loadable</span> {
        <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(for: <span class="call">type</span>(of: <span class="keyword">self</span>))
        <span class="keyword">if let</span> nib = <span class="type">UINib</span>(nibName: <span class="type">T</span>.<span class="property">nibName</span>, bundle: bundle).<span class="call">instantiate</span>(withOwner: <span class="keyword">self</span>, options: <span class="keyword">nil</span>).<span class="property">first</span> <span class="keyword">as</span>? <span class="type">UIView</span> {
            nib.<span class="property">frame</span> = <span class="keyword">self</span>.<span class="property">bounds</span>
            nib.<span class="property">autoresizingMask</span> = [.<span class="dotAccess">flexibleWidth</span>, .<span class="dotAccess">flexibleHeight</span>]
            <span class="keyword">self</span>.<span class="call">addSubview</span>(nib)
        } <span class="keyword">else</span> {
            <span class="call">fatalError</span>(<span class="string">"Nib</span> \(<span class="type">T</span>.<span class="property">nibName</span>) <span class="string">is not exist ?!"</span>)
        }
    }
}
</code></pre><p>简洁的初始化：</p><pre><code><span class="keyword">let</span> view:<span class="type">ClassName</span> = <span class="keyword">self</span>.<span class="call">instantiateFromNib</span>(<span class="type">ClassName</span>.<span class="keyword">self</span>)
<span class="keyword">self</span>.<span class="call">instantiateFromNibOwner</span>(<span class="type">ClassName</span>.<span class="keyword">self</span>)
</code></pre><p>后来发现一个名为 <a href="https://github.com/AliSoftware/Reusable">Reusable</a> 的库，其中除了这一部分的实现之外，还有对 Cell 甚至是 Storyboard 和 ViewController 的重用，十分强大。</p><p>回到这一部分的实现，略有区别的地方在于：</p><ol><li><em>Reusable</em> 在初始化 nib 的时候选择了扩展协议。</li><li>在 <em>File's Owner</em> 的情况下，<em>Reusable</em> 使用了 Auto Layout。由于我们的 <strong>P-OOP</strong> 项目对应的设备尺寸不多，所以像是部分弹出框就没有对应 Auto Layout，所以就直接从 frame 的尺寸下手了。。</li></ol><blockquote><p>追记：把这部分实现和例子提了出来放在了 <a href="https://github.com/Ckitakishi/LoadableNib">Github</a> 上～</p></blockquote><h3>@IBDesignable 和 @IBInspectable</h3><p><strong>@IBDesignable</strong> 可以用于视图的实时渲染，<strong>@IBInspectable</strong> 可以用于定义运行时属性。</p><p>举个例子来说：首先在定义一个 <code>DialogHeaderView</code>，标记为 <code>@IBDesignable</code>，将它的 <code>headerTitle</code> 属性设置为 <code>@IBInspectable</code>：</p><pre><code><span class="keyword">@IBDesignable class</span> DialogHeaderView: <span class="type">UIView</span> {

    <span class="keyword">@IBInspectable var</span> headerTitle: <span class="type">String</span> = <span class="string">""</span> {
        <span class="keyword">didSet</span> {
            navigationBar.<span class="property">topItem</span>?.<span class="property">title</span> = <span class="keyword">self</span>.<span class="property">headerTitle</span>
        }
    }
    ...   
}
</code></pre><p>然后向目标视图添加一个 UIView，并将类定义为 <code>DialogHeaderView</code>，此时在 <em>Attribuite Inspector</em> 中可以直接设置属性：</p><img src="ckitakishi.com/images/IB1.png" alt="IB1"/><p>之后即会反映在运行时属性栏中：</p><img src="ckitakishi.com/images/IB2.png" alt="IB2"/><p>不过构建失败的时候还是挺多的，不妨通过 <strong>Editor -&gt; Debug Selected Views</strong> 来调试一下选中的视图。</p><h3>类型安全</h3><p>除了定义上面的 <code>Loadable</code> 协议，在类型安全这个问题上还可以进一步再做一些工作。</p><p>存在 Storyboard，Segue 的定义也就会有存在，由于 identifier 的定义是字符串，防不胜防，不匹配的情况还是会时而发生。这时候使用 <a href="https://github.com/mac-cain13/R.swift">R.swift</a> 就能够完全解消这个担忧了。</p><p><em>R.swift</em> 被广泛使用于解决类型安全的问题，图片、字体、本地化等等都受益于此。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/thread-sanitizer</guid><title>Thread Sanitizer</title><description>使用 Thread Sanitizer 来解决实际遇到的数据竞争问题。</description><link>ckitakishi.com/posts/thread-sanitizer</link><pubDate>Sat, 13 May 2017 14:39:00 +0900</pubDate><content:encoded><![CDATA[<h1>Thread Sanitizer</h1><p><em>作为一项惯例，周五早晨，组内每个人都要进行三分钟的 LT，将自己感兴趣的话题分享给大家。</em></p><p>之前在修正并优化应用内线程管理的时候用了 <strong>Thread Sanitizer</strong> 功能，于是以此为机给大家简单介绍了一下。更多详细的内容，可以看一看 2016 WWDC 的 <a href="https://developer.apple.com/videos/play/wwdc2016/412/">Session 412</a>。线程问题发生的时候一般还是挺焦虑的，因为时间敏感，有时候再现很困难，自然就不易调适。<strong>TSan</strong> 能够发现一些问题，诸如 Keynote 里提到的：</p><blockquote><p>Use of uninitialized mutexesThread leaks (missing pthred_join)Unsafe calls in signal handlers (ex:malloc)Unlock from wrong threadData races</p></blockquote><p>因为在实际中遇到过，而且感觉发生概率相对较高，所以只展开说一下最后一项：数据竞争。数据竞争发生的基本条件是多个线程在同时访问同一块内存，并且其中至少又一个线程正在进行的是写操作。实际中常常表现为数据不整合，亦或是应用崩溃。比如下面这个例子：</p><pre><code>[context performBlock:^{
    <span class="keyword">if</span> (result &amp;&amp; context) {
        result = [<span class="keyword">self</span> persistentSaveContext:context]; <span class="comment">// 1</span>
    }
}];
<span class="keyword">return</span> result; <span class="comment">// 2</span>
</code></pre><p><code>result</code> 在 1 和 2 两个地方发生了竞争。在 1 进行写操作之前，有可能处于不同线程的 2 早已经返回了，这样数据就发生了不整合。</p><p>有很多方法可以解决这个问题，比如说：由异步操作变为同步操作，或是改变写操作的时间点。这里采取了第一个方案，使用同样用途的同步方法 <code>performBlockAndWait</code> 来取代 <code>performBlock</code>，这样以来，数据竞争的问题也就自然而然解决了。</p><pre><code>[context performBlockAndWait:^{
    <span class="keyword">if</span> (result &amp;&amp; context) {
        result = [<span class="keyword">self</span> persistentSaveContext:context]; <span class="comment">// 1</span>
    }
}];
<span class="keyword">return</span> result; <span class="comment">// 2</span>
</code></pre><p>由于 <strong>TSan</strong> 是统合在编译器 (Clang) 层面的，所以当使用 Swift 来编写服务器代码的时候，完全可以在命令行中使用它：</p><img src="ckitakishi.com/images/datarace.png" alt="Tsan command"/><p>P.S.目前 <strong>TSan</strong> 只支持 64bit 的模拟器及 macOS 自身。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/swift-app-crash</guid><title>Swift App: 一个意料之外的崩溃理由</title><description>应用功能本身十分简单，开发测试阶段也比较顺利，几乎没有发生崩溃。然而在更替证书之后，真机测试应用时却陷入了无限崩溃的境地。</description><link>ckitakishi.com/posts/swift-app-crash</link><pubDate>Mon, 13 Feb 2017 23:10:00 +0900</pubDate><content:encoded><![CDATA[<h1>Swift App: 一个意料之外的崩溃理由</h1><p>这是一个发生在去年年底的故事。背景是一个新规 Swift 应用处于准备发布阶段，证书由开发测试用更替为发布用， 这是两份 Team 不同的企业版证书。</p><p>应用功能本身十分简单，开发测试阶段也比较顺利，几乎没有发生崩溃。然而在更替证书之后，真机测试应用时却陷入了无限崩溃的境地。</p><p>Log 类似下面这样：</p><pre><code>dyld: <span class="type">Library</span> not loaded: <span class="keyword">@rpath</span>/libswiftCore.<span class="property">dylib</span>
  <span class="type">Referenced</span> from: ...
  <span class="type">Reason</span>: no suitable image found.  <span class="type">Did</span> find:
  ...
</code></pre><p>有很多原因会导致提示这个错误，作为 Trouble Shooting 记录下来：</p><ul><li>可能存在缓存，<strong>Clean</strong> 工程</li><li>很多时候该问题发生在 Swift 与 Objective-C 混编的时候，所以需要检查 <em>Building Setting</em> 中 <em>Embeedded Content Contains Swift Code</em> 的设置是否已经为 <strong>YES</strong>。</li><li>依然是配置，检查 <em>Building Setting</em> 中的 <em>Runpath Search Paths</em> 是否合适，通常是：<strong>@executable_path/Frameworks</strong>。</li><li>重置证书 (注销再新建) 。</li></ul><p>实际的生产过程中，首先 check 了前三项，最终强烈怀疑是证书问题。关于 “libswiftCore.dylib 崩溃“这个话题，很容易能看到这篇 <a href="https://developer.apple.com/library/content/qa/qa1886/_index.html">Q&amp;A</a>，其中提到要运行 Swift 应用必须使用 iOS 8 Released 之后创建的证书。对比手中的两份证书，除了 Team 不同之外，最大的差别在于创建时间，分别为 2016 年夏天，和 2014 年夏天。所以更新证书之后，问题也幸运地解决了。</p><p>关于 libswiftCore.dylib 文件还想再多说几句，看名字就能够猜到是 Swift 动态库，具体说来它其实是 Swift 的运行时库，但是该文件和证书有什么关系呢？原因在于目前 Swift 的版本升级还不稳定，如果将这些运行时库直接放到系统中，很可能会导致每次 Swift 升级都导致应用不再能够使用，而作为这个问题的解决方案，Apple 选择将运行时库打包进应用中，这样就保证了开发与应用的 Swift 版本一致。由于 libswiftCore.dylib 属于应用的一部分，所以也是需要签名的，而像上一段所说，能够为 Swift 的运行时库签名的证书必须创建于 iOS 8 Released 之后。这一切，都是为了提高 Swift 的兼容性，关于兼容性，强烈推荐这条 <a href="http://swifter.tips/compatibility/">Tip</a>。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/2016-year-end</guid><title>重新启程的 2016</title><description>转眼一月都已过半...如果说 2015 于我而言是承前启后的一年，那 2016 大概算是重新启程的一年</description><link>ckitakishi.com/posts/2016-year-end</link><pubDate>Sat, 14 Jan 2017 19:23:00 +0900</pubDate><content:encoded><![CDATA[<h1>重新启程的 2016</h1><p>转眼一月都已过半...如果说 2015 于我而言是承前启后的一年，那 2016 大概算是重新启程的一年。</p><h2>第一个完整的工作年</h2><p>2016 是我的第一个完整工作年，有吐不完的槽，也有说不尽的感谢。</p><p>远离家乡，薪水不可观，事多，责任重，没有靠谱的工作搭档，无数次质疑自己为什么不早点做个了断，但是无法否认自己在成长，也得到了一定程度上的回报。曾一夜无眠的想过，好多事，时候未到。</p><p>年初，工作重心正式从前端转回 iOS，充满了期待。然而如果知道注定我会一个人孤独奋斗一整年，我还会这么想么～没有答案。从比 0 多一点的基础开始，搞了好多事儿，被嘲笑过日语说的烂，被以经验不足为由甩过锅...很喜欢一个词，「賛否両論」，本意是赞成与反对并存，不分优劣。我并不害怕被反对，被嘲笑（反正没人能在我的 bgm 里打败我哈哈哈，只怕 10 年后还像某些人一样活在自己的嘴里，活在自己的 yy 中（摊手。</p><p>一年的勤勉工作换来了「奨励賞」，开心，但是更期待优秀的团队，优秀的自己。</p><h2>认真的生活</h2><p>这一年来对时间管理还是没有什么清晰的概念，很遗憾，很遗憾。</p><p>做了一些时间投入与金钱回报并不是那么成正比事，但是于我而言绝对是这一年最棒的事情之一。能够有幸参与《函数式 Swift》的翻译，于我而言绝不是能够衡量的财富，和优秀的人一起，总会想把事情做的更好一点。</p><p>认识了一群爱读书的人，文学素养浅薄的我，也算是读了一些书。</p><p>生活过得挺不错，（觉得）做饭进阶啦，游泳进阶啦，拍照也进阶啦～</p><h2>新年愿望</h2><p>为开源社区贡献力量 合适的时机换工作</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/swift-longest-common-prefix</guid><title>Swift 的字符串前后缀匹配</title><description>之前修改了项目中一个 increment search 的组件，最近刚好又看到下题，于是想说一说前后缀匹配的事</description><link>ckitakishi.com/posts/swift-longest-common-prefix</link><pubDate>Wed, 9 Nov 2016 00:18:00 +0900</pubDate><content:encoded><![CDATA[<h1>Swift 的字符串前后缀匹配</h1><p>之前修改了项目中一个 increment search 的组件，最近刚好又看到下题，于是想说一说前后缀匹配的事。</p><p><a href="https://leetcode.com/problems/longest-common-prefix/">14. Longest Common Prefix</a></p><p>这是一个给定字符串数组，求所有字符串最长公有前缀的问题。</p><p>直接用 <code>O(1)</code> 的额外空间来存储一个最长公有前缀，一次遍历后返回前缀字符串。这个想法自然到不需要多加解释，然而这么一写竟然击败了 100% 的 Swift 提交结果...</p><p>所以不得不提一下十分高效的 <code>hasPrefix(_:)</code> 方法，它接受一个 <code>String</code> 类型的参数并返回 <code>Bool</code> 值，这里字符串大小写敏感，且基于 Unicode 标准等价。此外，与之对应用于比较后缀字符串的方法是 <code>hasSuffix(_:)</code>。</p><pre><code><span class="comment">// Unicode 标准等价</span>
<span class="keyword">let</span> composedCafe = <span class="string">"Café"</span>
<span class="keyword">let</span> decomposedCafe = <span class="string">"Cafe\u{0301}"</span>
<span class="call">print</span>(cafe.<span class="call">hasPrefix</span>(composedCafe))
<span class="comment">// Prints "true"</span>
<span class="call">print</span>(cafe.<span class="call">hasPrefix</span>(decomposedCafe))
<span class="comment">// Prints "true"</span>
</code></pre><p><a href="https://github.com/Ckitakishi/Daily/blob/master/LeetCode14_LongestCommonPrefix.swift"></a><br><br><br><br><br><br></p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/watch-dog</guid><title>iOS 的看门狗机制</title><description>错误代码 “8badf00d”</description><link>ckitakishi.com/posts/watch-dog</link><pubDate>Wed, 17 Aug 2016 23:34:00 +0900</pubDate><content:encoded><![CDATA[<h1>iOS 的看门狗机制</h1><h2>背景</h2><p>当应用的网络状况极差 (100% Loss) 时完全无法启动，一直崩溃。彻底切断网络连接正常启动，调试模式状态下等待时间非常久，但可以启动，并伴随 UI 微卡。强烈的预感这是线程阻塞。前一段时间被 Core Data Concurrency 折腾的够呛，看见线程问题就略有些心慌。</p><h2>原因</h2><p>首先看了 crash log，一如猜测，的确是卡在了主线程；意料之外的是，无数次闪退只留下了一份崩溃日志，如下所示：</p><img src="ckitakishi.com/images/watchdog.png" alt="WatchDog"/><p>第一次见，读了一些资料大概才算是明白了这是怎么一回事。为了避免应用陷入错误状态导致界面无响应，Apple 设计了看门狗 (WatchDog) 机制。一旦超时，强制杀死进程。在不同的生命周期，触发看门狗机制的超时时间有所不同：</p><table><thead><tr><th>生命周期</th><th>超时时间</th></tr></thead><tbody><tr><td>启动 Launch</td><td>20 s</td></tr><tr><td>恢复 Resume</td><td>10 s</td></tr><tr><td>悬挂 Suspend</td><td>10 s</td></tr><tr><td>退出 Quit</td><td>6 s</td></tr><tr><td>后台 Background</td><td>10 min</td></tr></tbody></table><p>首先说一说异常编码，也是寓意颇深。<code>8badf00d</code>= ate bad food，大概是在说看门狗吃了坏的食物所以暴走了？！异常记录则表示这并不是一次崩溃（邪魅一笑：强制退出而已）。信息一栏指出时间限制为 20 s。结合应用业务来看，表层原因在于：每次启动应用，首先进行一次模版同步，在此之前需要检测登录状况，通过 RunLoop 反复尝试直到收到响应为止。然而不幸的是，这一些都发生在主线程。</p><p>同步网络请求，主线程，超长超时时间，满足这三点，一定场景下几乎必然会触发看门狗机制。</p><h2>对策</h2><p>合理解决方案：</p><ol><li>异步网络请求：优点很多，最重要的是可以让你无忧无虑安全地访问网络，而无需担心线程。</li><li>在非主线程中使用同步网络请求：如果异步运行你的网络代码比登天还难的话(也许你的应用是一个基于同步网络请求的大型移植项目)，退而求次，你也可以在次级线程中运行同步代码，也可以避免触发看门狗机制。</li></ol><p>此外，一部分情况下，例如这次遇到登录和模版同步时触发看门狗，事实上，即使在运用到模版时再次请求也是勉强可行的，因此姑且先跳过网络请求也可以。此时，还以使用一种我认为是相对比较差的方案：</p><ol start="3"><li>通过 RunLoop 来操控一切，一旦超过既定的超时时间，就提示用户重试或者暂时先跳过网络请求。</li></ol><p>应用的网络部分基于公司的通用框架，因此优先考虑在非主线程中进行网络请求来避免触发看门狗。</p><p>至于调试模式下为什么可以正常启动应用，完全是因为该模式下看门狗机制处于禁用状态。</p><p>此外，除了网络操作，I/O 读写文件和大规模运算等耗时任务也极有可能触发看门狗机制。合理处理线程，优化耗时任务，很大程度能避免不佳用户体验。</p><h2>参考：</h2><ol><li><a href="https://developer.apple.com/library/ios/qa/qa1693/_index.html">主线程上的同步网络请求</a></li><li><a href="https://developer.apple.com/library/ios/qa/qa1592/_index.html">调试模式不发生崩溃</a></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/okinawa-2015</guid><title>沖縄三日</title><description>期待已久的冲绳之行和不那么期待的马拉松如此而至。</description><link>ckitakishi.com/posts/okinawa-2015</link><pubDate>Tue, 8 Dec 2015 22:56:00 +0900</pubDate><content:encoded><![CDATA[<h1>沖縄三日</h1><p>期待已久的冲绳之行和不那么期待的马拉松如此而至。出发的早晨阳光特别温暖，モノレール窗子上映出身影，好暖～</p><p>到达当晚和晴儿一起吃了冲绳そば，终于吃到本土的了（笑...</p><img src="ckitakishi.com/images/soba.jpg" alt="沖縄ぞば"/><p>为了这次的马拉松的平安..从 7 月渐渐开始了不科学的练习，第一次早晨出去跑了 2km 就累成狗，恢复了好几天。8 月底参加了昆马 10km，幸运的达成！来日后，跑过小道，跑过荒川沿岸，跑过皇居，慢慢喜欢上了跑步的感觉。</p><p>每一次跑都是坚持再坚持，也许跟自己说过一万遍再，没有完赛好遗憾...也许是练习不足，也许是 FREE 4.0 FLYKNIT 并不太适合超长距离...不管怎么说，对得起自己了。</p><p>当日，起初天高气爽，后来风雨大作。一路上吃，跑，吃，跑，冲绳黑糖是真的很好吃。赛程最后阶段，遇到热心的大叔带我跑了一段，一直跟我说坚持跑还能赶得上哟～然而弱爆了的我还是在最终［还剩 1km］的地方听到了结束的信号。运动场入口的的志愿者们夹道给了我们［最后的击掌］，6:15，今天跑了这么久～</p><img src="ckitakishi.com/images/marathon.jpg" alt="那覇マラソン"/><p>赛后第二天，逛水族馆，看海。词穷的我只说得出一个形容词：美。</p><p>来馆必看的ジンベエザメ，后来才知是鲸鲨。一瞬间感到自己的渺小。</p><img src="ckitakishi.com/images/aquarium.jpg" alt="美ら海水族館"/><p>三面环海的岛上，自己拍婚纱照的情侣。</p><img src="ckitakishi.com/images/sea.jpg" alt="海"/><p>曾经的参天大树，如今又是另一种风韵。一起，任海风吹～</p><img src="ckitakishi.com/images/sea2.jpg" alt="海"/><p>于我而言，这三天又是一场洗礼，只想一生努力，一生被爱。用一句广告语作结吧，<strong>「苦しいけど、幸せ」</strong>。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/lightimagemd</guid><title>轻图像工具－LightImage</title><description>LightImage 是我的毕业设计项目，但是至今暂时还是一个残次成品，仍需大力的改善。初衷是开发一款轻量级的图像处理工具，后续又扩展了简易的图像分析和像素画绘制等功能。</description><link>ckitakishi.com/posts/lightimagemd</link><pubDate>Sat, 1 Aug 2015 16:58:00 +0900</pubDate><content:encoded><![CDATA[<h1>轻图像工具－LightImage</h1><p>LightImage 是我的毕业设计项目，但是至今暂时还是一个残次成品，仍需大力的改善。初衷是开发一款轻量级的图像处理工具，后续又扩展了简易的图像分析和像素画绘制等功能。</p><p>项目主要基于 HTML5 中的 Canvas 开发，当提及 Canvas 的时候，常常还会提到 SVG。Canvas 只能通过脚本驱动，适合像素级的图形问题处理；相比较而言 SVG 的驱动方式更加灵活，XML、CSS等都可，所以处理图形是通过元素。对于本项目而言，Canvas 是不二的选择。</p><p>项目使用了框架 Vue.js，结合曾经完成的一个数据量较大的应用来看，很优雅，很轻量，很灵活，调试也很棒，不过也遇到一些需要仔细思考的问题，生命周期，路由，页面重载等等。</p><p>答辩完后就一直想把一个多月开发过程中的心得和遇到的有意思的问题总结一下，还好之前有在 trello 上记录。下面想从三个部分来说一说～</p><h2>绘画</h2><p>关于这个部分，细节的部分集中于事件处理，例如笔迹离开和进入画布需要绑定 mouseleave 和 mouseenter 事件。想要说一说的是，这里添加了我很喜欢的像素画绘制，通过倍率来模拟不同格子数的像素画布，尝试过使用单个像素放大但并适用。在这里不得不提给我带来深刻影响的像素动画作品们 <a href="http://1041uuu.tumblr.com/">1041uuu</a>。</p><p>未来展望：使用栈保存笔画，完成撤销前进；提供自定义像素数量；以及允许添加多张画布组成动画。</p><h2>图像分析</h2><p>这个部分也许名不副实？（笑。起初只是想做一个图像的色彩分析，统计色彩的出现频率。依据 rgb 色彩模型，则有256^3种色彩，非常大的数字，于是将相近的色彩归位一类，由大及小最终选定了 6^3 种色彩。使用一个长度为 256 的数组存储出现次数，色彩一一对应下标 0-255，并可反向由下标推导颜色以便在页面渲染。</p><p>后来增添了灰度直方图及均衡化的直方图来表现图像的大体特征。这个部分效率受图像大小影响并不明显。</p><p>未来展望：可导出分析结果；保持效率得到更精确的结果。</p><h2>图像处理</h2><p>做毕设的两个月中，用于学习图像处理和使用 JavaScript 实现花了不少时间。起初大概看了看《数字图像处理》..的目录、基础和色彩相关章节，有了一点点宏观的理解，后期更具体的理解大多来自于他人文章和《数字图像处理原理与实践：基于Visual C++开发》。实现中，比较深刻的是图像剪切，有几个 jQuery 实现的插件，然而还是强迫自己写了一个纯 JavaScript 的，但至今仍不完善，将来如若有一日能够见人，打算让其作为一个独立的组件存在。</p><p>图像处理的效率随着图像增大而剧降，很 sad，也是一个改善的重点。</p><p>未来展望：结合直方图，添加曲线；可调节亮度，对比度等。</p><h2>有话说</h2><p>源码完全在 <a href="https://github.com/Ckitakishi/LightImage">Github</a></p><p>可以在 heroku 上 <a href="https://lightimage.herokuapp.com">Try it</a></p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/2015-07</guid><title>说说过去这半年</title><description>过去这半年，说实话过的蛮不错。确定了工作，结束了实习，带着不舍顺利毕业，毕业旅行。每一件事都那么难忘。</description><link>ckitakishi.com/posts/2015-07</link><pubDate>Fri, 31 Jul 2015 23:58:00 +0900</pubDate><content:encoded><![CDATA[<h1>说说过去这半年</h1><p>过去这半年，说实话过的蛮不错。确定了工作，结束了实习，带着不舍顺利毕业，毕业旅行。每一件事都那么难忘。</p><p>年初，犹豫和纠结最终还是没能阻挡一个小小的梦想，决定去霓虹工作。大三以前还信誓旦旦的说过就算去日本也只可能是旅行，亲爱的日语老师们估计怎么也想不到当年那个日语下手的学生尽然要去工作了～</p><p>四月底，结束了八个月的实习，最想说的是感谢，身边的人都充满了正能量。最幸福的是开发主线由 iOS 重新回到了 web 前端开发，框架开发，新产品研发，案件对应...。</p><p>六月底，毕业设计 [<a href="https://lightimage.herokuapp.com">lightimage</a>] 和学位授予为大学划上了句号，带着满满的祝福和好几十G的毕业照跟最爱的 DUT 说再见了。</p><p>七月，伴随着江南烟雨的毕业旅行，每天早晨醒来都会想又少了一天相伴，真的舍不得。同一个屋檐下生活了四年，你们给我带来了太多，一起努力一起玩耍互相吐槽互相打击...</p><p>窗外大雨滂沱，赶在七月的尾巴，流水账一样的梳理了这半年来的发生的事情和心情。我就要带着梦想重新起航啦～</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/dream-mark</guid><title>Dream Mark的前世今生</title><description>Dream Mark 是一款图片合成 App （Note: 练手项目）</description><link>ckitakishi.com/posts/dream-mark</link><pubDate>Tue, 1 Jul 2014 23:28:00 +0900</pubDate><content:encoded><![CDATA[<h1>Dream Mark的前世今生</h1><h2>DreamMark 的前世</h2><p>DreamMark的的简介永远都是 <em>Mark our dream.</em></p><p>起初，这源于一次激烈的讨论。“生活并不平淡，可很多东西就是记不住”，“我们大概需要借助纸和笔”，“可是，铭心的自然忘不了，其它又记了干嘛”，差一点，就再也没有然后了。“不一样的，记住可以是为了记忆，也可以是提醒”，“做梦！哪有那么神奇。”，“嗯！那就做梦吧！”，“......”。</p><p>于是，我们决定 <em>mark our dream</em> 。让梦境和梦想，为记忆添上那么一点儿不同的东西。</p><h2>DreamMark 的今生</h2><p>半个月，每天约 3 小时，我们完成了 DreamMark 最初版的开发。</p><p>DreamMark 支持两种模式：</p><pre><code>&gt; 涂鸦 --- 给你一个画板，你可以绘出你的梦
&gt; 拼图 --- 场景 + 人物 + 情节 + 其它 = 你的梦
</code></pre><p>DreamMark 还只是一个雏形，无论是设计还是代码，我们会努力做到更好。</p><h2>DreamMark 相关</h2><p>所有图片均由 <a href="http://chiakiq.com/">晴</a> 原创。 使用 <a href="https://www.parse.com/">Parse</a> 提供后台服务。 更新在 <a href="https://github.com/Ckitakishi/DreamMark">这里</a>。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/uikit-dynamics-ios7</guid><title>UIKit Dynamics--iOS7</title><description>Dynamic Items 为我们带来更丰富的动画体验。</description><link>ckitakishi.com/posts/uikit-dynamics-ios7</link><pubDate>Sat, 22 Mar 2014 22:17:00 +0900</pubDate><content:encoded><![CDATA[<h1>UIKit Dynamics--iOS7</h1><h2>Dynamic Items 简介</h2><p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDynamicItem_Protocol/Reference/Reference.html">Apple Library相关的</a> UIKit Dynamics 的焦点都是关于 items 之间相互的作用及其动画。有一个要求，为了在一个 item 上使用 dynamic behavior，item必须满足 <code>UIDynamicItem</code> 协议。该协议定义了三个重要的属性，<code>bounds</code>，<code>center</code>，<code>transform</code>。<code>bounds</code>属性是readonly的,<code>center</code>,<code>transform</code> 属性是read/write的，<code>center</code> 需要更新动画的进度,<code>transform</code> 属性返回一个 <code>CGAffineTransform</code> 的对象。</p><p>从 iOS7 开始，默认的只有 <code>UIView</code> 和 <code>UICollectionViewLayoutAttributes</code> 类可实现该协议。但是，仍然可以自己创建类去实现之。</p><pre><code><span class="keyword">@property</span>(nonatomic, readonly) <span class="type">CGRect</span> bounds
<span class="keyword">@property</span>(nonatomic, readwrite) <span class="type">CGPoint</span> center
<span class="keyword">@property</span>(nonatomic, readwrite) <span class="type">CGAffineTransform</span> transform
</code></pre><h3>Dynamic Behaviors</h3><p>在 UIKit Dynamics 中，一个 Dynamic Behavior 模拟的是真实世界的物理行为。包含以下六个类：</p><ul><li>UIAttachmentBehavior</li><li>UICollisionBehavior</li><li>UIGravityBehavior</li><li>UIPushBehavior</li><li>UISnapBehavior</li><li>UIDynamicItemBehavior</li></ul><p>前五个分别是--附着、碰撞、重力、推力、捕捉。最后一个不是一个具体的行为，但是也很有用~按我的理解就是可以设置一个物体的本质属性，不依赖于外界而存在的。</p><p>最近写代码用到 <code>UIDynamicItemBehavior</code>，感觉太棒了！</p><ul><li>allowsRotation 是否可以旋转；默认YES；</li><li>density 密度；默认1.0;</li><li>elasticity 弹性系数；默认0.0；</li><li>friction 摩擦系数；默认0.0；</li><li>resistance 阻力；默认0.0；</li></ul><p>当时想要让一个球能够一开始就有方向有速度的运动，以下两个函数不能再赞，很简便。</p><pre><code>– <span class="call">addAngularVelocity</span>(<span class="type">CGFloat</span>):<span class="call">forItem</span>(id[<span class="type">UIDynamicItem</span>]) <span class="comment">//设置角速度</span>
– <span class="call">addLinearVelocity</span>(<span class="type">CGPoint</span>):<span class="call">forItem</span>(id[<span class="type">UIDynamicItem</span>]) <span class="comment">//设置线速度</span>
</code></pre><h3>UIDynamicAnimator</h3><p><code>UIDynamicBehavior</code> 需要添加到 <code>animator</code> 上才能发生作用；</p><h3>ReferenceView</h3><p>等同于力学参考系。</p>]]></content:encoded></item><item><guid isPermaLink="true">ckitakishi.com/posts/hexo-note</guid><title>[Hexo] 遇到的一些问题与解决办法</title><description>基于 Hexo 搭建个人博客过程中遇到的一些问题和解决方案</description><link>ckitakishi.com/posts/hexo-note</link><pubDate>Mon, 6 Jan 2014 22:30:00 +0900</pubDate><content:encoded><![CDATA[<h1>[Hexo] 遇到的一些问题与解决办法</h1><p>一直有些博客写记录的习惯，但是越来越觉得定制的博客们很多时候无法满足需求，了解了一些框架后，最终选择了 <a href="http://zespia.tw/hexo/">hexo</a>，甚至打开主页的瞬间就认定它了。hexo 由 Node.js 驱动，迅速，简洁。</p><p>这两天也遇到了一些问题，简单地记录下来。</p><h2>1. 无法成功 deploy</h2><p>此时已经完成了 <a href="http://nodejs.org/">node.js</a> 的安装，并在 <a href="https://github.com/">github</a> 创建了名为 <code>username.github.io</code> 的 repository 。部署完成之后:</p><pre><code>hexo generate 
hexo server  
</code></pre><p>此时已经可以通过 <code>localhost:4000</code> 查看页面，landscape 的主题觉得很深沉。</p><pre><code>hexo deploy
</code></pre><p>竟然没有成功。出现了好几个 <code>fetal:......</code>，提示文件不存在。赶紧关掉 bash，用管理员权限打开，终于没有 fetal 了。windows 总是这样.....就在我得意的笑时，仔细一看，竟然没有成功 push 到 github。搜索良久，猜想也许是重装系统后 ssh key 出问题，重新生成了一个，依然未能解决。看到有网友说 github 名字有大写可能导致问题，一想自己的名儿，于是联系了 github 的工作人员，人家很快回邮件，开头就是 NO！往来了两封邮件，查看密钥可用性，以及我的命令和错误。结果第二天，就好了......是的，就好了。个人认为可能真的和 ssh key 有关吧。</p><h2>2. ico 图标的添加</h2><p>关于小图标的添加，参考了 <a href="http://zipperary.com/2013/05/30/hexo-guide-4/">zippera</a> 所写。</p><pre><code>&lt;% <span class="keyword">if</span> (config.<span class="property">root</span>){ %&gt;
  &lt;link href=<span class="string">"/favicon.ico"</span> rel=<span class="string">"shortcut icon"</span> type=<span class="string">"image/x-icon"</span> /&gt; #这段是faviconer提供的通用代码。
&lt;% } %&gt;
</code></pre><p>我的做法是直接将以上代码添加到 <code>head.ejs</code>。</p><p>特别感谢 <a href="http://chiakiq.com/">Qing</a> 设计的 A，B 图标，在自己在操作过程中，只能在 localhost 查看到图标。查看了 github 的 repo，发现反复 deploy B 图标但是依然存在的是 A 图标，纠其原因，放弃 A 图标之后缓存还在。查看了文档，根目录下的 <strong>db.json</strong> 即为缓存，删除之，重新 deploy，就成功了。</p><p>此后，如果由于缓存而导致的无法更新内容，删除 <strong>db.json</strong> 即可。</p><h2>3. 域名的解析</h2><p>选择了 <a href="https://www.dnspod.cn/">DNSPod</a> 解析域名，添加 A 记录时，记录值填了个二级域名的 ip，坐等~吃过饭后依然不行，参考了一些人的经历，又添加了一条 A 记录，ip 写了 <code>pages.github.com</code> 的 <code>204.232.175.78</code>；很奇怪，自己 ping 的 ip 地址是一个澳大利亚的地址 <code>103.***.***.***</code>。经过一番折腾，验证了 <code>204.232.175.78</code> 和 ping 的 ip 地址都是可以用的。而且后者更快。</p><h2>4. hexo generate 无法解析</h2><p>在本文修改再提交时又遇到问题，<code>hexo g</code> 出现了一下 log：</p><pre><code>rawMessage: '<span class="type">Unable</span> to parse.',
parsedLine: <span class="number">8</span>,
snippet: '  hexo generate ',
parsedFile: null,
message: '<span class="type">Unable</span> to parse.',
domain: 
{ domain: null,
 _events: { error: [<span class="type">Function</span>] },
 _maxListeners: <span class="number">10</span>,
 members: [],
 _disposed: <span class="keyword">true</span> },
domainThrown: <span class="keyword">true</span> }
</code></pre><p>去查看了 hexo 项目的 <a href="https://github.com/tommy351/hexo/issues?page=1&state=open">Issues</a>，有人遇到类似的一些问题，原因是 markdown 语法不太对，发现是因为汉字之间用了 <code>----</code>。</p><h2>尾声</h2><p>(*^^)v路漫漫其修远兮，吾将上下而求索。</p>]]></content:encoded></item></channel></rss>